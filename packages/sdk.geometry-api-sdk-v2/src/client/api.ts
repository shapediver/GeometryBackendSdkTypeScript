/* tslint:disable */
/* eslint-disable */
/**
 * Geometry Backend API v2
 * The ShapeDiver Geometry Backend system is used to: * host Grasshopper models in a secure, reliable, scalable, and performant way, * run computations of Grasshopper models, * and cache and output the results of computations and exports.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS,  RequiredError, operationServerMap } from './base';
import { BaseAPI } from '../base';

/**
 * Reference to the s-type parameter asset to be used.
 */
export interface CommmonsParameterAsset {
    /**
     * String ID of the asset.
     */
    'id': string;
    'chunk'?: CommonsParameterChunk;
}
/**
 * @type CommonsBasicParameter
 * Definition of a basic ShapeDiver parameter.
 */
export type CommonsBasicParameter = boolean | number | string;

/**
 * Status of a model computation.
 */

export const CommonsComputationStatus = {
    SUCCESS: 'success',
    TIMEOUT: 'timeout',
    CHECK_CONFIRMED: 'checkconfirmed',
    CHECK_DENIED: 'checkdenied',
    CHECK_PENDING: 'checkpending',
    MAX_COMBINED_ASSET_SIZE_EXCEEDED: 'maxcombinedassetsizeexceeded',
    MAX_DB_SIZE_PER_OUTPUT_EXCEEDED: 'maxdbsizeperoutputexceeded',
    MAX_PARTS_PER_OUTPUT_EXCEEDED: 'maxpartsperoutputexceeded',
    MAX_ASSET_PARTS_PER_OUTPUT_EXCEEDED: 'maxassetpartsperoutputexceeded',
    MAX_TRANSFORMATIONS_PER_OUTPUT_EXCEEDED: 'maxtransformationsperoutputexceeded',
    MAX_PARTS_EXCEEDED: 'maxpartsexceeded',
    MAX_ASSET_PARTS_EXCEEDED: 'maxassetpartsexceeded',
    RECOVERABLE_ERROR: 'recoverableerror',
    UNRECOVERABLE_ERROR: 'unrecoverableerror',
    NO_OUTPUT_DATA_FOR_DEFAULT_PARAMETER_VALUES: 'nooutputdatafordefaultparametervalues',
    MODEL_WITHOUT_GEOMETRY_OUTPUT: 'modelwithoutgeometryoutput',
    UNKNOWN: 'unknown'
} as const;

export type CommonsComputationStatus = typeof CommonsComputationStatus[keyof typeof CommonsComputationStatus];


/**
 * Group of a parameter, export or output.
 */
export interface CommonsGroup {
    'id': string;
    'name': string;
}
/**
 * Reasons why the model may be blocked.
 */
export interface CommonsModelBlockingReasons {
    /**
     * The model owner\'s credit limit has been exceeded.
     */
    'creditLimit'?: boolean;
    /**
     * The model has been blocked explicitly by its owner.
     */
    'owner'?: boolean;
}
/**
 * Status of a model.
 */

export const CommonsModelStatus = {
    UNKNOWN: 'unknown',
    NOT_UPLOADED: 'not_uploaded',
    UPLOADED: 'uploaded',
    PENDING: 'pending',
    CONFIRMED: 'confirmed',
    DENIED: 'denied',
    DELETED: 'deleted'
} as const;

export type CommonsModelStatus = typeof CommonsModelStatus[keyof typeof CommonsModelStatus];


/**
 * Describing which chunk of the s-type asset to use. When not specified, the chunk of an asset gets chosen based on parameter ID and name.
 */
export interface CommonsParameterChunk {
    /**
     * ID of the chunk to be used.
     */
    'id'?: string;
    /**
     * Name attribute of the chunk to be used.
     */
    'name'?: string;
}
/**
 * Definition of the value to use for s-type parameters.
 */
export interface CommonsStypeParameter {
    /**
     * Optional embedded value. If this is set the asset is ignored.
     */
    'value'?: string;
    'asset'?: CommmonsParameterAsset;
}
/**
 * Authorization ticket.
 */
export interface CommonsTicket {
    /**
     * List of domains (origins) this ticket should be limited to; may be empty.
     */
    'accessdomains'?: Array<string>;
    /**
     * Should this ticket provide access to model authoring (allows to change configuration)?
     */
    'author'?: boolean;
    /**
     * Should this ticket allow public access (ignore the model\'s `accessdomains` property)?
     */
    'pub': boolean;
    /**
     * The timestamp until which the ticket should be valid.
     */
    'until': string;
    /**
     * Does this ticket identify the model via its secondary ID (model property `id2`)?
     */
    'use_id2'?: boolean;
}
/**
 * Type of a ticket.
 */

export const CommonsTicketType = {
    BACKEND: 'backend',
    NONE: ''
} as const;

export type CommonsTicketType = typeof CommonsTicketType[keyof typeof CommonsTicketType];


/**
 * A substitution for the JSON-value `null`.
 */
export interface NullObj {
    /**
     * The value of this property does not matter.
     */
    'nullObj': boolean;
}
/**
 * Filter by model computation statistics status.
 */

export const QueryComputationStatisticsStatus = {
    SUCCESS: 'success',
    TIMEOUT: 'timeout',
    OTHER: 'other',
    ALL: '*'
} as const;

export type QueryComputationStatisticsStatus = typeof QueryComputationStatisticsStatus[keyof typeof QueryComputationStatisticsStatus];


/**
 * Filter by model computation status.
 */

export const QueryComputationStatus = {
    SUCCESS: 'success',
    TIMEOUT: 'timeout',
    CHECK_CONFIRMED: 'checkconfirmed',
    CHECK_DENIED: 'checkdenied',
    CHECK_PENDING: 'checkpending',
    MAX_COMBINED_ASSET_SIZE_EXCEEDED: 'maxcombinedassetsizeexceeded',
    MAX_DB_SIZE_PER_OUTPUT_EXCEEDED: 'maxdbsizeperoutputexceeded',
    MAX_PARTS_PER_OUTPUT_EXCEEDED: 'maxpartsperoutputexceeded',
    MAX_ASSET_PARTS_PER_OUTPUT_EXCEEDED: 'maxassetpartsperoutputexceeded',
    MAX_TRANSFORMATIONS_PER_OUTPUT_EXCEEDED: 'maxtransformationsperoutputexceeded',
    MAX_PARTS_EXCEEDED: 'maxpartsexceeded',
    MAX_ASSET_PARTS_EXCEEDED: 'maxassetpartsexceeded',
    RECOVERABLE_ERROR: 'recoverableerror',
    UNRECOVERABLE_ERROR: 'unrecoverableerror',
    NO_OUTPUT_DATA_FOR_DEFAULT_PARAMETER_VALUES: 'nooutputdatafordefaultparametervalues',
    MODEL_WITHOUT_GEOMETRY_OUTPUT: 'modelwithoutgeometryoutput',
    UNKNOWN: 'unknown'
} as const;

export type QueryComputationStatus = typeof QueryComputationStatus[keyof typeof QueryComputationStatus];


/**
 * Filter by computation type.
 */

export const QueryComputationType = {
    COMPUTATION: 'computation',
    EXPORT: 'export',
    LOAD: 'load',
    ALL: '*'
} as const;

export type QueryComputationType = typeof QueryComputationType[keyof typeof QueryComputationType];


/**
 * Conversion type of a glTF upoad: * `none`: no further processing of the file. * `usdz`: converts the glTF into the USDZ format. * `scene`: creates a temporary AR scene that holds both, a glTF and a USDZ file.
 */

export const QueryGltfConversion = {
    NONE: 'none',
    SCENE: 'scene',
    USDZ: 'usdz'
} as const;

export type QueryGltfConversion = typeof QueryGltfConversion[keyof typeof QueryGltfConversion];


/**
 * Filter by model status.
 */

export const QueryModelStatus = {
    UNKNOWN: 'unknown',
    NOT_UPLOADED: 'not_uploaded',
    UPLOADED: 'uploaded',
    PENDING: 'pending',
    CONFIRMED: 'confirmed',
    DENIED: 'denied',
    DELETED: 'deleted'
} as const;

export type QueryModelStatus = typeof QueryModelStatus[keyof typeof QueryModelStatus];


/**
 * Specifies the order of the results.
 */

export const QueryOrder = {
    ASC: 'asc',
    DESC: 'desc'
} as const;

export type QueryOrder = typeof QueryOrder[keyof typeof QueryOrder];


/**
 * @type ReqAnyCreditMetricId
 * Either a single or multiple IDs. Multiple IDs are aggregated and result in a single credit metrics object.
 */
export type ReqAnyCreditMetricId = ReqModelCreditMetricId | ReqModelOrganizationCreditMetricId | ReqModelUserCreditMetricId | ReqOrganizationCreditMetricId | ReqSystemCreditMetricId | ReqUserCreditMetricId;

/**
 * Body of an authorization group request.
 */
export interface ReqAuthorizationGroup {
    /**
     * The model IDs that should form the new authorization group.
     */
    'models'?: Array<string>;
    /**
     * The user IDs that should form the new authorization group.
     */
    'users'?: Array<string>;
    /**
     * The organization IDs that should form the new authorization group.
     */
    'organizations'?: Array<string>;
}
/**
 * @type ReqBasicParameter
 * Definition of a basic ShapeDiver parameter.
 */
export type ReqBasicParameter = boolean | number | string;

/**
 * Body of an export or output cache request. A directory of export-/output-IDs and version-IDs.
 */
export interface ReqCache {
    [key: string]: string;

}
/**
 * Body of a configure request.  A dictionary of string keys and values of any type.
 */
export interface ReqConfigure {
    [key: string]: any;

}
/**
 * Parameters of a credit metrics request. When IDs or timestamps are requested, the resulting response-item represents an aggregation of the requested data.
 */
export interface ReqCreditMetric {
    'id': ReqAnyCreditMetricId;
    /**
     * Either a single extended date or an array of extended dates. Multiple timestamps are aggregated and result in a single credit metrics object.
     */
    'timestamp'?: Array<string>;
    /**
     * Allows to define the beginning of a time range, instead of specifying individual timestamps.
     */
    'timestamp_from'?: string;
    /**
     * Allows to define the ending of a time range, instead of specifying individual timestamps.
     */
    'timestamp_to'?: string;
}
/**
 * Body of a credit metrics request. Every request-item results in exactly one response-item, whereby the order of response-items corresponds to the order of the request-items.
 */
export interface ReqCreditMetrics {
    'parameters': Array<ReqCreditMetric>;
}
/**
 * A directory of parameter keys and values.  Supported parameter keys are as follows, whereby the parameter resolution is done in the same order as the keys are listed: * `id` * `name` * `displayname`  Supported parameter values are: * Basic parameter (`ReqBasicParameter`) * S-type parameter (`ReqStypeParameter`)
 */
export interface ReqCustomization {
    [key: string]: ReqParameterValue;

}
/**
 * @type ReqCustomizationOrCache
 * Either a cache or a customization request.
 */
export type ReqCustomizationOrCache = ReqCache | ReqCustomization;

/**
 * @type ReqCustomizationOrExport
 */
export type ReqCustomizationOrExport = ReqCustomization | ReqExport;

/**
 * Body of an export request.
 */
export interface ReqExport {
    'parameters': ReqCustomization;
    'exports': Array<string>;
    'outputs'?: Array<string>;
    /**
     * Maximum amount of milliseconds to wait for completion of export request before responding.
     */
    'max_wait_time'?: number;
}
/**
 * Data for a single export definition.
 */
export interface ReqExportDefinition {
    /**
     * Parameter name to display instead of _name_.
     */
    'displayname'?: string;
    'group'?: ReqExportDefinitionGroup;
    /**
     * Controls whether the export should be hidden in the UI.
     */
    'hidden'?: boolean;
    /**
     * Ordering of the export in client applications.
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
}
/**
 * @type ReqExportDefinitionGroup
 * Set to `null` or `NullObj` to remove the export from the currently assigned group.
 */
export type ReqExportDefinitionGroup = NullObj | ReqGroup;

/**
 * Definition of a exports. A directory of export-IDs and export-definitions.
 */
export interface ReqExportDefinitions {
    [key: string]: ReqExportDefinition;

}
/**
 * @type ReqExportOrCache
 * Either a cache or an export request.
 */
export type ReqExportOrCache = ReqCache | ReqExport;

/**
 * Data for a single file parameter.
 */
export interface ReqFileDefinition {
    /**
     * Name of the file to be uploaded.  If this property is set, the file upload request must include a `Content-Disposition` HTTP header with the format `attachment; filename=\"{filename}\"`. Failure to do so will result in a signature mismatch. For convenience, the response will provide a preformatted HTTP header value that can be used directly.
     */
    'filename'?: string;
    /**
     * Content-Type (MIME type) of the file to be uploaded.
     */
    'format': string;
    /**
     * Size of the file to be uploaded, in bytes.
     */
    'size': number;
}
/**
 * Body of a file upload request. A directory of file-parameter-IDs and upload-definitions.
 */
export interface ReqFileUpload {
    [key: string]: ReqFileDefinition;

}
/**
 * Group of a parameter, export or output.
 */
export interface ReqGroup {
    'id': string;
    'name': string;
}
/**
 * Log message level for log requests.
 */

export const ReqLogLevel = {
    INFO: '0',
    WARN: '1',
    ERROR: '2'
} as const;

export type ReqLogLevel = typeof ReqLogLevel[keyof typeof ReqLogLevel];


/**
 * Body of a log message request.
 */
export interface ReqLogMessage {
    'level': ReqLogLevel;
    /**
     * The message that should be logged.
     */
    'message': string;
}


/**
 * Body of a template request.
 */
export interface ReqModel {
    /**
     * List of domains (origins) this model is limited to (is ignored in case `pub` is true).
     */
    'accessdomains'?: Array<string>;
    /**
     * List of allowed Grasshopper libraries.
     */
    'allowed_libraries'?: Array<string>;
    /**
     * List of allowed auth-groups.
     */
    'auth_groups'?: Array<string>;
    /**
     * Should backend access to the model be allowed.
     */
    'backendaccess'?: boolean;
    'blockingReasons'?: ReqModelBlockingReasons;
    /**
     * Original name of the model\'s grasshopper file.
     */
    'filename'?: string;
    /**
     * File type of the model.
     */
    'ftype'?: ReqModelFileType;
    /**
     * Allows to control whether the model should be warmed up immediately after loading by running a computation. This increases the likelihood of following computation requests to be faster.
     */
    'initial_warmup'?: boolean;
    /**
     * Optional second model ID.
     */
    'id2'?: string;
    /**
     * Maximum number of milliseconds allowed for computations of this model.
     */
    'max_comp_time'?: number;
    /**
     * Maximum number of bytes allowed to be exported from a model for a specific set of parameter values.
     */
    'max_export_size'?: number;
    /**
     * Maximum amount of minutes a loaded model may be unused before it gets unloaded.  Note: Models may get unloaded earlier than that.
     */
    'max_idle_minutes'?: number;
    /**
     * Maximum number of bytes allowed for the model\'s Grasshopper file size.
     */
    'max_model_size'?: number;
    /**
     * Maximum number of bytes allowed for an output of a model for a specific set of parameter values.
     */
    'max_output_size'?: number;
    /**
     * Allows to configure the maximum number of bytes allowed for a single texture.
     */
    'max_texture_size'?: number;
    /**
     * Maximum time a computation request may stay waiting before a further worker goes ahead regardless of whether it already has the model loaded, and regardless of `num_loaded_max`. This allows to configure a soft or a hard upper boundary for the number of loaded models.
     */
    'max_wait_time'?: number;
    /**
     * Name of the model.
     */
    'name'?: string;
    /**
     * Maximum number of workers that should have the model loaded at the same time.
     */
    'num_loaded_max'?: number;
    /**
     * Minimum number of workers which should have the model loaded once a session to the model gets opened.
     */
    'num_loaded_min'?: number;
    /**
     * Minimum number of workers that should always have the model loaded, regardless of session activity. This allows to minimise the likelihood of computation requests being slower due to model loading.
     */
    'num_preloaded_min'?: number;
    /**
     * Optional organization ID.
     */
    'org_id'?: string;
    /**
     * The Model ID of the previous version of this model. This property is applicable only when creating a new model and cannot be used in conjunction with `prev_id`.
     */
    'prev_id'?: string;
    /**
     * If set to `true`, a new repository will be created for the model. This property is applicable only when creating a new model and cannot be used in conjunction with `prev_id`.
     */
    'with_repo'?: boolean;
    /**
     * Allows public access (ignore `accessdomains`).
     */
    'pub'?: boolean;
    /**
     * Enforces iframe embedding instead of direct embedding.
     */
    'require_iframe'?: boolean;
    /**
     * Enforces token-based authentication for this model.
     */
    'require_token'?: boolean;
    /**
     * Limits the number of sessions that can be created by a specific IP address in one hour.
     */
    'session_rate_limit'?: number;
    /**
     * Can this model be trusted (controls whether failed computations will be retried).
     */
    'trust'?: ReqTrustLevel;
    /**
     * Allows the usage of the CDN for fast content distribution.
     */
    'use_cdn'?: boolean;
    /**
     * Optional user ID.
     */
    'user_id'?: string;
    /**
     * The webhook-url for updating the platform backend about model status changes.
     */
    'webhook_url'?: string;
    /**
     * The webhook-token for authentication used by the webhook-url.
     */
    'webhook_token'?: string;
    /**
     * Allows to control whether the model\'s Grasshopper file can contain scripts.
     */
    'deny_scripts'?: boolean;
}


/**
 * Reasons why the model may be blocked.
 */
export interface ReqModelBlockingReasons {
    /**
     * The model owner\'s credit limit has been exceeded.
     */
    'creditLimit'?: boolean;
    /**
     * The model has been blocked explicitly by its owner.
     */
    'owner'?: boolean;
}
/**
 * Model metrics
 */
export interface ReqModelCreditMetricId {
    'modelIds': Array<string>;
}
/**
 * Supported Grasshopper file types for models.
 */

export const ReqModelFileType = {
    GRASSHOPPER_BINARY: 'gh',
    GRASSHOPPER_XML: 'ghx'
} as const;

export type ReqModelFileType = typeof ReqModelFileType[keyof typeof ReqModelFileType];


/**
 * Model-Organization metrics
 */
export interface ReqModelOrganizationCreditMetricId {
    'modelIds': Array<string>;
    'orgIds': Array<string>;
}
/**
 * Description of a Model-State.
 */
export interface ReqModelState {
    'parameters': ReqCustomization;
    /**
     * Optional untyped data that can be used to store additional information.
     */
    'data'?: { [key: string]: any; };
    /**
     * Details of the Model-State image file. If provided, the response will include a URL for uploading the file.
     */
    'image'?: ReqFileDefinition;
    /**
     * The ID of an existing AR scene associated with this model. If provided, the scene\'s glTF and USDZ data will be duplicated into the newly created Model-State.
     */
    'arSceneId'?: string;
}
/**
 * Parameters of a single model-session analytics request. When multiple model IDs or timestamps are requested, the resulting response-item represents an aggregation of the requested data.
 */
export interface ReqModelStatistic {
    'modelid': Array<string>;
    /**
     * Either a single extended date or an array of extended dates. Multiple timestamps are aggregated and result in a single statistic object.
     */
    'timestamp'?: Array<string>;
    /**
     * Allows to define the beginning of a time range, instead of specifying individual timestamps.
     */
    'timestamp_from'?: string;
    /**
     * Allows to define the ending of a time range, instead of specifying individual timestamps.
     */
    'timestamp_to'?: string;
}
/**
 * Body of a model statistics request. Every request-item results in exactly one response-item, whereby the order of response-items corresponds to the order of the request-items.
 */
export interface ReqModelStatistics {
    'parameters': Array<ReqModelStatistic>;
}
/**
 * Model-User metrics
 */
export interface ReqModelUserCreditMetricId {
    'modelIds': Array<string>;
    'userIds': Array<string>;
}
/**
 * Organization metrics
 */
export interface ReqOrganizationCreditMetricId {
    'orgIds': Array<string>;
}
/**
 * Data for a single output definition.
 */
export interface ReqOutputDefinition {
    /**
     * Parameter name to display instead of `name`.
     */
    'displayname'?: string;
    'group'?: ReqOutputDefinitionGroup;
    /**
     * Controls whether the output should be hidden in the UI.
     */
    'hidden'?: boolean;
    /**
     * Ordering of the output in client applications.
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
    /**
     * The chunk definitions of the sdTF file that is generated by the output. If specified, all existing sdTF chunks of the output must be given. The order of the given chunk items determines the order in that the chunks will be shown in the UI.
     */
    'chunks'?: Array<ReqOutputDefinitionChunk>;
}
/**
 * Definition of a single \"chunk\" of data in an sdTF file that is generated by the output component.
 */
export interface ReqOutputDefinitionChunk {
    /**
     * ID of the chunk.
     */
    'id': string;
    /**
     * Chunk name to display instead of the chunk `name`. This value can be unset by specifying an empty string.
     */
    'displayname'?: string;
    /**
     * Controls whether the chunk should be hidden in the UI.
     */
    'hidden'?: boolean;
}
/**
 * @type ReqOutputDefinitionGroup
 * Set to `null` or `NullObj` to remove the export from the currently assigned group.
 */
export type ReqOutputDefinitionGroup = NullObj | ReqGroup;

/**
 * Definition of outputs. A directory of output-IDs and output-definitions.
 */
export interface ReqOutputDefinitions {
    [key: string]: ReqOutputDefinition;

}
/**
 * Data for a single parameter definition.
 */
export interface ReqParameterDefinition {
    /**
     * Parameter name to display instead of `name`.
     */
    'displayname'?: string;
    'group'?: ReqParameterDefinitionGroup;
    /**
     * Controls whether the parameter should be hidden in the UI.
     */
    'hidden'?: boolean;
    /**
     * Ordering of the parameter in client applications.
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
    /**
     * Holds parameter-type specific information.
     */
    'settings'?: object;
}
/**
 * @type ReqParameterDefinitionGroup
 * Set to `null` or `NullObj` to remove the export from the currently assigned group.
 */
export type ReqParameterDefinitionGroup = NullObj | ReqGroup;

/**
 * Definition of model parameters. A directory of parameter-IDs and parameter-definitions.
 */
export interface ReqParameterDefinitions {
    [key: string]: ReqParameterDefinition;

}
/**
 * @type ReqParameterValue
 * The value of a single model parameter.
 */
export type ReqParameterValue = ReqBasicParameter | ReqStypeParameter;

/**
 * Data for a single sdTF parameter.
 */
export interface ReqSdtfDefinition {
    /**
     * Encoding of the sdTF to be uploaded.
     */
    'content_encoding'?: string;
    /**
     * Size of the sdTF to be uploaded, in bytes.
     */
    'content_length': number;
    /**
     * Content-type of the sdTF to be uploaded.
     */
    'content_type': ReqSdtfType;
    /**
     * Namespace the asset shall be created in.
     */
    'namespace': string;
}


/**
 * Content-Type (MIME type) of the sdTF to be uploaded.
 */

export const ReqSdtfType = {
    MODEL_SDTF: 'model/vnd.sdtf'
} as const;

export type ReqSdtfType = typeof ReqSdtfType[keyof typeof ReqSdtfType];


/**
 * Definition of the value to use for s-type parameters.
 */
export interface ReqStypeParameter {
    /**
     * Optional embedded value. If this is set the asset is ignored.
     */
    'value'?: string;
    'asset'?: CommmonsParameterAsset;
}
/**
 * System-wide metrics
 */
export interface ReqSystemCreditMetricId {
    'systems': boolean;
}
/**
 * Body of a ticket request.
 */
export interface ReqTicket {
    /**
     * List of domains (origins) this ticket should be limited to; may be empty.
     */
    'accessdomains'?: Array<string>;
    /**
     * Should this ticket provide access to model authoring (allows to change configuration)?
     */
    'author'?: boolean;
    /**
     * Should this ticket allow public access (ignore the model\'s `accessdomains` property)?
     */
    'pub': boolean;
    /**
     * The timestamp until which the ticket should be valid.
     */
    'until': string;
    /**
     * Does this ticket identify the model via its secondary ID (model property `id2`)?
     */
    'use_id2'?: boolean;
    'type': ReqTicketType;
}


/**
 * The type of the ticket.
 */

export const ReqTicketType = {
    BACKEND: 'backend',
    NONE: ''
} as const;

export type ReqTicketType = typeof ReqTicketType[keyof typeof ReqTicketType];


/**
 * Level of trust granted for a model.
 */

export const ReqTrustLevel = {
    UNDEFINED: '',
    NONE: 'none',
    FULL: 'full'
} as const;

export type ReqTrustLevel = typeof ReqTrustLevel[keyof typeof ReqTrustLevel];


/**
 * User metrics
 */
export interface ReqUserCreditMetricId {
    'userIds': Array<string>;
}
/**
 * Defines the actions to be taken on the response data.
 */
export interface ResAction {
    /**
     * Name of the action, e.g. customize, close, default, etc.
     */
    'name': string;
    /**
     * Title of the action, e.g. \'Customize model\', \'Close session\', etc.
     */
    'title': string;
    /**
     * Hyperlink to make the request to.
     */
    'href': string;
    /**
     * HTTP method to use.
     */
    'method': string;
    /**
     * Template for the request body, references into the \'templates\' array of the response (e.g. \'customize-request\').
     */
    'template'?: string;
}
/**
 * Contains the model checking configuration for the Grasshopper plugins.
 */
export interface ResAllowedWorkerPlugin {
    /**
     * ID of the Grasshopper plugin.
     */
    'id': string;
    /**
     * Name of the Grasshopper plugin.
     */
    'name': string;
    /**
     * Minimum supported version of the plugin.
     */
    'minVersion': string;
    /**
     * Maximum supported version of the plugin.
     */
    'maxVersion': string;
    /**
     * Name of the plugin author.
     */
    'authorName'?: string;
    /**
     * Link to a website related to the plugin.
     */
    'description'?: string;
    /**
     * Link to a website related to the plugin.
     */
    'href'?: string;
    /**
     * When `true` then `GH_AssemblyInfo.AssemblyVersion` may be used instead of `GH_AssemblyInfo.Version` for version checking.  Defaults to `false`.
     */
    'allowFallbackToAssemblyVersion': boolean;
    /**
     * When `true` then only the major and minor version numbers recorded in Grasshopper models will be checked.  Defaults to `false`.
     */
    'checkMajorMinorVersionOnly': boolean;
    /**
     * When `false` then the installation check of the plugin will be skipped.  Defaults to `true`.
     */
    'checkIfInstalled': boolean;
    /**
     * List of previous plugin IDs supported by this plugin version. This is used for the obscure case of the plugin developer changing the plugin ID.
     */
    'previousIds': Array<string>;
    /**
     * List of plugin components that are explicitly allowed. When this property is set, only the listed components are allowed, overruling the list in `disallowedComponents`.
     */
    'allowedComponents': Array<ResWorkerPluginComponent>;
    /**
     * List of plugin components which may not be used. This list might be overruled by `allowedComponents`.
     */
    'disallowedComponents': Array<ResWorkerPluginComponent>;
}
/**
 * Analytics components.
 */
export interface ResAnalytics {
    'models': Array<ResModelStatistic>;
    'creditMetrics': Array<ResAnyCreditMetric>;
}
/**
 * @type ResAnyCreditMetric
 * The ID of any type of credit metric.
 */
export type ResAnyCreditMetric = ResModelCreditMetric | ResModelOrganizationCreditMetric | ResModelUserCreditMetric | ResOrganizationCreditMetric | ResSystemCreditMetric | ResUserCreditMetric;

/**
 * Downloads of AR scenes.
 */
export interface ResArCreditMetric {
    /**
     * Number of AR downloads charged.
     */
    'credits': number;
}
/**
 * ShapeDiver API response for asset upload requests.
 */
export interface ResAsset {
    /**
     * A directory of parameter-IDs and asset-definitions.
     */
    'file'?: { [key: string]: ResAssetDefinition; };
    'sdtf'?: Array<ResAssetDefinition>;
    /**
     * The asset-definition of a Model-State image.
     */
    'modelState'?: ResAssetDefinition;
}
/**
 * Result part for the response to an asset upload request.
 */
export interface ResAssetDefinition {
    /**
     * ID of the file to be uploaded (\'\' in case the asset is not linked to any specific ID).
     */
    'id': string;
    /**
     * href the file should be uploaded to (typically a time-limited pre-signed url).
     */
    'href': string;
    'headers': ResAssetUploadHeaders;
}
/**
 * HTTP headers to use when uploading an asset to ShapeDiver.
 */
export interface ResAssetUploadHeaders {
    /**
     * The value of the Content-Disposition HTTP header.
     */
    'contentDisposition'?: string;
    /**
     * The value of the Content-Type HTTP header.
     */
    'contentType': string;
}
export interface ResAuthorizationSettings {
    'ticket'?: ResTicketAuthorization;
    'token'?: ResTokenAuthorization;
}
export interface ResBase {
    'asset'?: ResAsset;
    'list'?: ResList;
    'modelState'?: ResModelStateOrData;
    'system'?: ResSystem;
    /**
     * Actions the client may take.
     */
    'actions'?: Array<ResAction>;
    /**
     * Statistics of the model for the given timespan.
     */
    'analytics'?: ResAnalytics;
    /**
     * The auth-group to use for ticked-based authentication.
     */
    'auth_group'?: string;
    /**
     * Model cleanup information.
     */
    'cleanup'?: Array<ResModelCleanupProcess>;
    /**
     * Decrypted ticket details.
     */
    'decryptedTicket'?: ResTicket;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Links regarding the model file.
     */
    'file'?: ResFile;
    /**
     * glTF information.
     */
    'gltf'?: ResGltfUpload;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     */
    'model'?: ResModel;
    /**
     * Statistics about model computations.
     */
    'computations'?: Array<ResModelComputation>;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Pagination information.
     */
    'pagination'?: ResPagination;
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     */
    'parameters'?: { [key: string]: ResParameter; };
    'plugins'?: ResPlugins;
    /**
     * The ID of the created session.
     */
    'sessionId'?: string;
    /**
     * Various settings.
     */
    'setting'?: ResSettings;
    /**
     * Statistics of a model.
     */
    'statistic'?: ResStatistic;
    /**
     * Request templates for actions.
     */
    'templates'?: Array<ResTemplate>;
    /**
     * The ticket to create a model session.
     */
    'ticket'?: string;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    /**
     * Viewer specific data.
     */
    'viewer'?: ResViewer;
    /**
     * The current version of the viewer settings.
     */
    'viewerSettingsVersion'?: string;
    /**
     * An array of warnings encountered during request processing. These warnings indicate potential issues or non-critical conditions but did not prevent the request from being successfully processed.
     */
    'warnings'?: Array<string>;
}
export interface ResBaseAsset {
    'asset'?: ResAsset;
}
export interface ResBaseCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     */
    'isCompilationDone': boolean;
    'ar': ResArCreditMetric;
    'loading': ResLoadingCreditMetric;
    'limited': ResLimitedCreditMetric;
    'default': ResDefaultCreditMetric;
}
export interface ResBaseList {
    'list'?: ResList;
}
export interface ResBaseModelState {
    'modelState'?: ResModelStateOrData;
}
export interface ResBaseSystem {
    'system'?: ResSystem;
}
/**
 * @type ResBasicParameter
 * Definition of a basic ShapeDiver parameter.
 */
export type ResBasicParameter = boolean | number | string;

export interface ResCleanupExports {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResCleanupOutputs {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResCleanupTextures {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResCloseSession {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
/**
 * Information about the components taking most computation time in the model computations log.
 */
export interface ResComputationComponent {
    /**
     * Components which were computed, ordered by descending processor time.
     */
    'computed': Array<ResComputedComponent>;
    /**
     * Components which were currently computing at the time the computation was stopped.
     */
    'computing': Array<ResComputingComponent>;
    /**
     * Component Errors.
     */
    'errors': Array<ResErrorComponent>;
    /**
     * Component Warnings.
     */
    'warnings': Array<ResWarningComponent>;
}
/**
 * Information about model computations.
 */
export interface ResComputationComponents {
    'components': ResComputationComponent;
    /**
     * Count of successful computations for the given loaded instance of the model.
     */
    'count_success'?: number;
    /**
     * Count of timed-out computations for the given loaded instance of the model.
     */
    'count_timeout'?: number;
    /**
     * Lists the ids of the parameters whose values were changed before the computation.
     */
    'changes'?: Array<string>;
}
/**
 * Limits of a model computation process.
 */
export interface ResComputationLimits {
    /**
     * Maximum computation time in milliseconds allowed for the model.
     */
    'max_comp_time': number;
    /**
     * Maximum output size in bytes allowed for the model.
     */
    'max_output_size': number;
    /**
     * Maximum export size in bytes allowed for the model.
     */
    'max_export_size': number;
}
/**
 * Status of a model computation.
 */

export const ResComputationStatus = {
    SUCCESS: 'success',
    TIMEOUT: 'timeout',
    CHECK_CONFIRMED: 'checkconfirmed',
    CHECK_DENIED: 'checkdenied',
    CHECK_PENDING: 'checkpending',
    MAX_COMBINED_ASSET_SIZE_EXCEEDED: 'maxcombinedassetsizeexceeded',
    MAX_DB_SIZE_PER_OUTPUT_EXCEEDED: 'maxdbsizeperoutputexceeded',
    MAX_PARTS_PER_OUTPUT_EXCEEDED: 'maxpartsperoutputexceeded',
    MAX_ASSET_PARTS_PER_OUTPUT_EXCEEDED: 'maxassetpartsperoutputexceeded',
    MAX_TRANSFORMATIONS_PER_OUTPUT_EXCEEDED: 'maxtransformationsperoutputexceeded',
    MAX_PARTS_EXCEEDED: 'maxpartsexceeded',
    MAX_ASSET_PARTS_EXCEEDED: 'maxassetpartsexceeded',
    RECOVERABLE_ERROR: 'recoverableerror',
    UNRECOVERABLE_ERROR: 'unrecoverableerror',
    NO_OUTPUT_DATA_FOR_DEFAULT_PARAMETER_VALUES: 'nooutputdatafordefaultparametervalues',
    MODEL_WITHOUT_GEOMETRY_OUTPUT: 'modelwithoutgeometryoutput',
    UNKNOWN: 'unknown'
} as const;

export type ResComputationStatus = typeof ResComputationStatus[keyof typeof ResComputationStatus];


export interface ResComputeExports {
    /**
     * Actions the client may take.
     */
    'actions'?: Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Request templates for actions.
     */
    'templates'?: Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResComputeOutputs {
    /**
     * Actions the client may take.
     */
    'actions'?: Array<ResAction>;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Request templates for actions.
     */
    'templates'?: Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResComputeSettings {
    /**
     * Allows to control whether the model\'s Grasshopper file can contain scripts.
     */
    'deny_scripts': boolean;
    /**
     * File type of the model.
     */
    'ftype': string;
    /**
     * Allows to control whether the model should be warmed up immediately after loading by running a computation. This increases the likelihood of following computation requests to be faster.
     */
    'initial_warmup': boolean;
    /**
     * Maximum number of milliseconds allowed for computations of this model.
     */
    'max_comp_time': number;
    /**
     * Maximum number of bytes allowed to be exported from a model for a specific set of parameter values.
     */
    'max_export_size': number;
    /**
     * Maximum amount of minutes a loaded model may be unused before it gets unloaded.  Note: Models may get unloaded earlier than that.
     */
    'max_idle_minutes': number;
    /**
     * Maximum number of bytes allowed for the model\'s Grasshopper file size.
     */
    'max_model_size'?: number;
    /**
     * Maximum number of bytes allowed for an output of a model for a specific set of parameter values.
     */
    'max_output_size': number;
    /**
     * Maximum number of bytes allowed for a single texture.
     */
    'max_texture_size'?: number;
    /**
     * Maximum time a computation request may stay waiting before a further worker goes ahead regardless of whether it already has the model loaded, and regardless of `num_loaded_max`. This allows to configure a soft or a hard upper boundary for the number of loaded models.
     */
    'max_wait_time': number;
    /**
     * Maximum number of workers that should have the model loaded at the same time.
     */
    'num_loaded_max': number;
    /**
     * Minimum number of workers that should load the model and keep it open while there is session activity.
     */
    'num_loaded_min': number;
    /**
     * Minimum number of workers that should always have the model loaded, regardless of session activity. This allows to minimise the likelihood of computation requests being slower due to model loading.
     */
    'num_preloaded_min': number;
    /**
     * Limits the number of sessions that can be created by a specific IP address in one hour.
     */
    'session_rate_limit'?: number;
    /**
     * Controls whether failed computations will be retried.
     */
    'trust': string;
}
export interface ResComputedComponent {
    /**
     * Instance ID of component.
     */
    'instance': string;
    /**
     * ID of the component.
     */
    'component': string;
    /**
     * Name of component.
     */
    'name': string;
    /**
     * Nickname of component.
     */
    'nick_name': string;
    /**
     * Computation time used.
     */
    'time': number;
}
export interface ResComputingComponent {
    /**
     * Instance ID of component.
     */
    'instance': string;
    /**
     * ID of component.
     */
    'component': string;
    /**
     * Name of component.
     */
    'name': string;
    /**
     * Nickname of component.
     */
    'nick_name': string;
}
export interface ResCreateAuthorizationGroup {
    /**
     * The auth-group to use for ticked-based authentication.
     */
    'auth_group': string;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResCreateModel {
    /**
     * Links regarding the model file.
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     */
    'model': ResModel;
    /**
     * Various settings.
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     */
    'statistic': ResStatistic;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResCreateModelConfig {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResCreateModelState {
    /**
     * Model-State information.
     */
    'modelState': ResModelState;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'asset'?: ResModelStateAsset;
}
export interface ResCreateSessionByModel {
    /**
     * Actions the client may take.
     */
    'actions': Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Links regarding the model file.
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     */
    'model': ResModel;
    /**
     * Model-State information.
     */
    'modelState'?: ResModelStateData;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     */
    'parameters'?: { [key: string]: ResParameter; };
    /**
     * The ID of the created session.
     */
    'sessionId': string;
    /**
     * Various settings.
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     */
    'statistic': ResStatistic;
    /**
     * Request templates for actions.
     */
    'templates': Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    /**
     * Viewer specific data.
     */
    'viewer': ResViewer;
    /**
     * The current version of the viewer settings.
     */
    'viewerSettingsVersion': string;
    /**
     * An array of warnings encountered during request processing. These warnings indicate potential issues or non-critical conditions but did not prevent the request from being successfully processed.
     */
    'warnings'?: Array<string>;
}
export interface ResCreateSessionByTicket {
    /**
     * Actions the client may take.
     */
    'actions': Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Links regarding the model file.
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     */
    'model': ResModel;
    /**
     * Model-State information.
     */
    'modelState'?: ResModelStateData;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     */
    'parameters'?: { [key: string]: ResParameter; };
    /**
     * The ID of the created session.
     */
    'sessionId': string;
    /**
     * Various settings.
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     */
    'statistic': ResStatistic;
    /**
     * Request templates for actions.
     */
    'templates': Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    /**
     * Viewer specific data.
     */
    'viewer': ResViewer;
    /**
     * The current version of the viewer settings.
     */
    'viewerSettingsVersion': string;
    /**
     * An array of warnings encountered during request processing. These warnings indicate potential issues or non-critical conditions but did not prevent the request from being successfully processed.
     */
    'warnings'?: Array<string>;
}
export interface ResCreateTicket {
    /**
     * Links regarding the model file.
     */
    'file': ResFile;
    /**
     * The definitions of a ShapeDiver model.
     */
    'model': ResModel;
    /**
     * Various settings.
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     */
    'statistic': ResStatistic;
    /**
     * The ticket to create a model session.
     */
    'ticket': string;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResDecryptTicket {
    /**
     * Decrypted ticket details.
     */
    'decryptedTicket': ResTicket;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
/**
 * Combined output and export requests.
 */
export interface ResDefaultCombinedMetric {
    /**
     * Number of combined output and export requests charged.
     */
    'credits': number;
}
/**
 * Computations information.
 */
export interface ResDefaultComputationMetric {
    /**
     * Number of computations.
     */
    'count': number;
    /**
     * Number of finished 10-second chunks charged.
     */
    'credits': number;
    /**
     * Total duration of computation time, in milliseconds.
     */
    'duration': number;
    /**
     * Count of computations per computation time expressed in started 10-second chunks.
     */
    'countPerChunks': { [key: string]: number; };
}
/**
 * Aggregated metrics for \'default\' sessions.
 */
export interface ResDefaultCreditMetric {
    'outputs': ResDefaultOutputMetric;
    'exports': ResDefaultExportMetric;
    'combined': ResDefaultCombinedMetric;
    'sessions': ResDefaultSessionMetric;
    'computations': ResDefaultComputationMetric;
}
/**
 * Pure export requests.
 */
export interface ResDefaultExportMetric {
    /**
     * Number of pure export requests charged.
     */
    'credits': number;
}
/**
 * Pure output requests.
 */
export interface ResDefaultOutputMetric {
    /**
     * Number of pure output requests charged.
     */
    'credits': number;
}
/**
 * Session information.
 */
export interface ResDefaultSessionMetric {
    /**
     * Number of sessions.
     */
    'count': number;
    /**
     * The total duration of all sessions, in milliseconds.
     */
    'duration': number;
}
export interface ResDeleteFile {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResDeleteModel {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResDeleteModelState {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResDeleteSdtf {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
/**
 * Body of an error object.
 */
export interface ResError {
    /**
     * The type of the error.
     */
    'error': ResErrorType;
    /**
     * General description of the error type.
     */
    'desc': string;
    /**
     * Detailed error description.
     */
    'message'?: string;
}


export interface ResErrorComponent {
    /**
     * ID of component.
     */
    'component': string;
    /**
     * Component Error descriptions.
     */
    'errors': Array<string>;
    /**
     * Instance ID of component.
     */
    'instance': string;
    /**
     * Name of component.
     */
    'name': string;
    /**
     * Nickname of component.
     */
    'nick_name': string;
    /**
     * Component Warnings descriptions.
     */
    'warnings': Array<string>;
}
/**
 * Possible error types.
 */

export const ResErrorType = {
    ASSERTION_ERROR: 'SdAssertionError',
    CACHE_ERROR_GENERIC: 'SdCacheErrorGeneric',
    CONNECTOR_ERROR: 'SdConnectorError',
    DATABASE_ERROR_GENERIC: 'SdDatabaseErrorGeneric',
    EMAILING_ERROR: 'SdEmailingError',
    ERROR_ENTITY_NOT_FOUND: 'SdErrorEntityNotFound',
    ERROR_FORBIDDEN: 'SdErrorForbidden',
    ERROR_GENERIC_CLIENT: 'SdErrorGenericClient',
    ERROR_GENERIC_INTERNAL: 'SdErrorGenericInternal',
    ERROR_UNAUTHORIZED: 'SdErrorUnauthorized',
    ILLEGAL_ARGUMENT_ERROR: 'SdIllegalArgumentError',
    JWT_VALIDATION_ERROR: 'SdJwtValidationError',
    METHOD_NOT_ALLOWED_ERROR: 'SdMethodNotAllowedError',
    MODEL_VALIDATION_ERROR: 'SdModelValidationError',
    NOT_ACCEPTABLE: 'SdNotAcceptable',
    NOT_FOUND_ERROR: 'SdNotFoundError',
    PARAMETER_VALIDATION_ERROR: 'SdParameterValidationError',
    RATE_LIMIT_ERROR_GENERIC: 'SdRateLimitErrorGeneric',
    REQUEST_TIMEOUT: 'SdRequestTimeout',
    REQUEST_VALIDATION_ERROR: 'SdRequestValidationError',
    RESOURCE_GONE_ERROR: 'SdResourceGoneError',
    SESSION_GONE_ERROR: 'SdSessionGoneError',
    SESSION_VALIDATION_ERROR: 'SdSessionValidationError',
    STORAGE_ERROR_GENERIC: 'SdStorageErrorGeneric',
    TEXTURE_URL_ERROR: 'SdTextureUrlError',
    TICKET_VALIDATION_ERROR: 'SdTicketValidationError',
    TOKEN_MISSING_ERROR: 'SdTokenMissingError',
    TRANSFORM_CONTENT_ARRAY_ERROR: 'SdTransformContentArrayError',
    UNCONFIRMED_MODEL_ERROR: 'SdUnconfirmedModelError',
    UNKNOWN: ''
} as const;

export type ResErrorType = typeof ResErrorType[keyof typeof ResErrorType];


/**
 * Export definition WITH results as exposed on the API.
 */
export interface ResExport {
    /**
     * ID of the export, dependent on model ID, and therefore changing each time a model gets uploaded.
     */
    'id': string;
    /**
     * Constant ID of the export, not dependent on model ID, and therefore NOT changing each time a model gets uploaded. Might be undefined because this property was introduced in summer 2020 and does not exist for exports of older models.
     */
    'uid'?: string;
    /**
     * Name of the export.
     */
    'name': string;
    /**
     * Type of export.
     */
    'type': ResExportDefinitionType;
    /**
     * List of IDs of parameters influencing this export.
     */
    'dependency': Array<string>;
    /**
     * Group information of an export definition.
     */
    'group'?: CommonsGroup;
    /**
     * Ordering of the export in client applications.
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     */
    'hidden': boolean;
    /**
     * Requested version of the export.
     */
    'version': string;
    /**
     * The delay in milliseconds after which an export cache request shall be sent to check again for this export version. This property is used ONLY if the export version has not been computed yet.  Note that the existence of this property does not necessarily imply the presence of an active or queued computation for the respective export version.
     */
    'delay'?: number;
    /**
     * Result parts. In case this array does not exist, this means that the workers have not finished computation for this output version.
     */
    'content'?: Array<ResExportContent>;
    /**
     * In case computation of the export version (temporarily) failed. Contains a message explaining what went wrong.
     */
    'msg'?: string;
    /**
     * Optional suggested filename for the files to be downloaded.
     */
    'filename'?: string;
    'result'?: ResExportResult;
    /**
     * Status of the computation which resulted in the export version.
     */
    'status_computation'?: ResComputationStatus;
    /**
     * Status of collecting results for the export version.
     */
    'status_collect'?: ResComputationStatus;
}


/**
 * An item of the `content` array for exports.
 */
export interface ResExportContent {
    /**
     * Format of export result (file extension).
     */
    'format': string;
    /**
     * Link for download of exported asset.
     */
    'href': string;
    /**
     * Optional size of exported asset, in bytes.
     */
    'size'?: number;
    /**
     * Optional Content-Type for parts of type `asset`.
     */
    'contentType'?: string;
}
/**
 * Export definition WITHOUT results as exposed on the API.
 */
export interface ResExportDefinition {
    /**
     * ID of the export, dependent on model ID, and therefore changing each time a model gets uploaded.
     */
    'id': string;
    /**
     * Constant ID of the export, not dependent on model ID, and therefore NOT changing each time a model gets uploaded. Might be undefined because this property was introduced in summer 2020 and does not exist for exports of older models.
     */
    'uid'?: string;
    /**
     * Name of the export.
     */
    'name': string;
    /**
     * Type of export.
     */
    'type': ResExportDefinitionType;
    /**
     * List of IDs of parameters influencing this export.
     */
    'dependency': Array<string>;
    /**
     * Group information of an export definition.
     */
    'group'?: CommonsGroup;
    /**
     * Ordering of the export in client applications.
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     */
    'hidden': boolean;
    /**
     * This property is never set.
     * @deprecated
     */
    'version'?: boolean | null;
}


/**
 * Types of exports.
 */

export const ResExportDefinitionType = {
    UNKNOWN: 'unknown',
    DOWNLOAD: 'download',
    EMAIL: 'email',
    SHAPEWAYS: 'shapeways'
} as const;

export type ResExportDefinitionType = typeof ResExportDefinitionType[keyof typeof ResExportDefinitionType];


export interface ResExportList {
    /**
     * A directory of file objects.
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     */
    'export': Array<ResExport>;
    /**
     * A directory of model textures.
     */
    'texture'?: Array<ResTexture>;
}
/**
 * @type ResExportOrDefinition
 * Either a full export or it\'s definition.
 */
export type ResExportOrDefinition = ResExport | ResExportDefinition;

/**
 * Optional result object for exports of type `email` and `shapeways`.
 */
export interface ResExportResult {
    /**
     * Optional success message for user.
     */
    'msg'?: string;
    /**
     * Optional error message for user.
     */
    'err'?: string;
    /**
     * Optional href to redirect user to for download.
     */
    'href'?: string;
    /**
     * Optional shapeways model ID.
     */
    'modelId'?: string;
}
/**
 * Definitions of a model file.
 */
export interface ResFile {
    /**
     * URL to upload a model file.
     */
    'upload'?: string;
    /**
     * URL to download a model file.
     */
    'download'?: string;
}
/**
 * File assets.
 */
export interface ResFileAsset {
    /**
     * A directory of parameter-IDs and asset-definitions.
     */
    'file': { [key: string]: ResAssetDefinition; };
    'sdtf'?: Array<ResAssetDefinition>;
    /**
     * The asset-definition of a Model-State image.
     */
    'modelState'?: ResAssetDefinition;
}
/**
 * Result part for the response to a list request for file objects.
 */
export interface ResFileInfo {
    /**
     * ID of the file.
     */
    'id': string;
    /**
     * ID of the parameter that the file is assigned to.
     */
    'parameterId': string;
    /**
     * The size of the file in bytes.
     */
    'size': number;
    /**
     * The name of the file, when specified during the upload.
     */
    'filename'?: string;
}
export interface ResFileList {
    /**
     * A directory of file objects.
     */
    'file': Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     */
    'texture'?: Array<ResTexture>;
}
export interface ResGetCachedExports {
    /**
     * Actions the client may take.
     */
    'actions'?: Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Request templates for actions.
     */
    'templates'?: Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetCachedOutputs {
    /**
     * Actions the client may take.
     */
    'actions'?: Array<ResAction>;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Request templates for actions.
     */
    'templates'?: Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetCleanupStatus {
    /**
     * Model cleanup information.
     */
    'cleanup': Array<ResModelCleanupProcess>;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     */
    'analytics': ResAnalytics;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetMinionsInfo {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'system': ResMinionSystem;
}
export interface ResGetModel {
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Links regarding the model file.
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     */
    'model': ResModel;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     */
    'parameters'?: { [key: string]: ResParameter; };
    'plugins'?: ResPlugins;
    /**
     * Various settings.
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     */
    'statistic': ResStatistic;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetModelComputations {
    /**
     * Statistics about model computations.
     */
    'computations': Array<ResModelComputation>;
    /**
     * Pagination information.
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetModelConfig {
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    /**
     * Viewer specific data.
     */
    'viewer': ResViewer;
}
export interface ResGetModelOrganizationCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     */
    'analytics': ResAnalytics;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetModelState {
    /**
     * Model-State information.
     */
    'modelState': ResModelState;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetModelStateData {
    /**
     * Model-State information.
     */
    'modelState': ResModelStateData;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetModelStatistics {
    /**
     * Statistics of the model for the given timespan.
     */
    'analytics': ResAnalytics;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetModelUserCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     */
    'analytics': ResAnalytics;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetOrganizationCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     */
    'analytics': ResAnalytics;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetScaleInCandidate {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'system': ResScaleInCandidate;
}
export interface ResGetSessionDefaults {
    /**
     * Actions the client may take.
     */
    'actions': Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     */
    'model': ResModel;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     */
    'parameters'?: { [key: string]: ResParameter; };
    /**
     * The ID of the created session.
     */
    'sessionId': string;
    /**
     * Statistics of a model.
     */
    'statistic': ResStatistic;
    /**
     * Request templates for actions.
     */
    'templates': Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    /**
     * Viewer specific data.
     */
    'viewer': ResViewer;
    /**
     * The current version of the viewer settings.
     */
    'viewerSettingsVersion': string;
}
export interface ResGetUserCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     */
    'analytics': ResAnalytics;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResGetWorkersInfo {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'system': ResWorkerSystem;
}
/**
 * Information about uploaded glTF object.
 */
export interface ResGltfUpload {
    /**
     * The URL to download the glTF file.
     */
    'href': string;
    /**
     * Contains the unique ID of the uploaded scene. Only present for uploads with the conversion type `scene`.
     */
    'sceneId'?: string;
}
/**
 * Contains information about all installed Grasshopper plugins.
 */
export interface ResInstalledWorkerPlugin {
    /**
     * ID of the Grasshopper plugin.
     */
    'id': string;
    /**
     * Name of the Grasshopper plugin.
     */
    'name': string;
    /**
     * Version of the Grasshopper plugin.
     */
    'version': string;
    /**
     * Name of the plugin author.
     */
    'authorName': string;
    /**
     * Contact information of the plugin author (homepage URL, email address, etc.).
     */
    'authorContact': string;
    /**
     * General description of the Grasshopper plugin.
     */
    'description': string;
    /**
     * Assembly version of the Grasshopper plugin DLL.  See the [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assemblyname.version?view=net-8.0) for more information.
     */
    'assemblyVersion': string;
    /**
     * Full assembly name of the Grasshopper plugin DLL.  See the [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assembly.fullname?view=net-8.0) for more information.
     */
    'assemblyFullName': string;
    /**
     * Gets whether this library is a Grasshopper core library. Core libraries are installed along with Grasshopper and thus should always be available anywhere.
     */
    'isCoreLibrary': boolean;
    /**
     * The license type of the plugin.  See the [documentation](https://developer.rhino3d.com/api/grasshopper/html/T_Grasshopper_Kernel_GH_LibraryLicense.htm) for more information.
     */
    'license': number;
    /**
     * The mechanism used to load the plugin.  See the [documentation](https://developer.rhino3d.com/api/grasshopper/html/T_Grasshopper_Kernel_GH_LoadingMechanism.htm) for more information.
     */
    'loadingMechanism': number;
    /**
     * Installation path of the Grasshopper plugin.
     */
    'location': string;
}
/**
 * Aggregated metrics for \'rate-limited timeslot\' sessions.
 */
export interface ResLimitedCreditMetric {
    'outputs': ResRateLimitedOutputMetric;
    'exports': ResRateLimitedExportMetric;
    'combined': ResRateLimitedCombinedMetric;
    'sessions': ResRateLimitedSessionMetric;
    'computations': ResRateLimitedComputationMetric;
}
/**
 * ShapeDiver API response of a list-request.
 */
export interface ResList {
    /**
     * A directory of file objects.
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     */
    'texture'?: Array<ResTexture>;
}
export interface ResListExportVersions {
    /**
     * Pagination information.
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'list': ResExportList;
}
export interface ResListFiles {
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Pagination information.
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'list': ResFileList;
}
export interface ResListModelStates {
    /**
     * Pagination information.
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'list': ResModelStateList;
}
export interface ResListModels {
    /**
     * Pagination information.
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'list': ResModelList;
}
export interface ResListOutputVersions {
    /**
     * Pagination information.
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'list': ResOutputList;
}
export interface ResListSdtfs {
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Pagination information.
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'list': ResSdtfList;
}
export interface ResListTextures {
    /**
     * Pagination information.
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'list': ResTextureList;
}
/**
 * Information about loading times on the Geometry Workers.
 */
export interface ResLoadingCreditMetric {
    /**
     * Number of started 10-second chunks charged.
     */
    'credits': number;
    /**
     * Number of load requests.
     */
    'count': number;
}
export interface ResLogMessage {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
/**
 * Holds system information of all currently running Geometry Minion services.
 */
export interface ResMinionInfo {
    /**
     * Information per instance. A directory of process-IDs and process data.
     */
    'instances': { [key: string]: ResMinionProcess; };
    /**
     * Aggregated task information. A directory of task types and task data.
     */
    'tasks': { [key: string]: ResMinionTask; };
}
/**
 * System information a single Geometry Minions process.
 */
export interface ResMinionProcess {
    /**
     * Information about completed tasks, listed per task type.
     */
    'tasks': { [key: string]: ResMinionTask; };
}
/**
 * Minion system information.
 */
export interface ResMinionSystem {
    /**
     * System information about the Geometry Minions.
     */
    'minions': ResMinionInfo;
    /**
     * System information about the Geometry Workers.
     */
    'workers'?: ResWorkerInfo;
    /**
     * Scale-in candidate information for worker instances.
     */
    'scaleInCandidate'?: ResWorkerScaleInCandidate;
}
/**
 * Statistics of a single Minion task.
 */
export interface ResMinionTask {
    /**
     * Average duration of the task in milliseconds.
     */
    'avgDuration': number;
    /**
     * Maximum duration of the task in milliseconds.
     */
    'maxDuration': number;
    /**
     * Average difference between the configured task interval and the last global task execution in milliseconds.
     */
    'avgIntervalDiff': number;
    /**
     * Maximum difference between the configured task interval and the last global task execution in milliseconds.
     */
    'maxIntervalDiff': number;
    /**
     * Execution interval of this task type in milliseconds.
     */
    'interval': number;
    /**
     * Timestamp of the latest task completion.
     */
    'latest': string;
    /**
     * The number of aggregated items.
     */
    'count': number;
}
/**
 * Definition of a ShapeDiver model.
 */
export interface ResModel {
    /**
     * List of allowed Grasshopper libraries.
     */
    'allowed_libraries'?: Array<string>;
    /**
     * Link to view the model on the ShapeDiver Platform.
     */
    'backlinkurl'?: string;
    /**
     * Link to continue the checking process of the model on the ShapeDiver Platform.
     */
    'checkurl'?: string;
    /**
     * Timestamp of creation of the model.
     */
    'createdate'?: string;
    /**
     * ID of the Grasshopper document.
     */
    'documentid'?: string;
    /**
     * Original name of the model\'s grasshopper file.
     */
    'filename'?: string;
    /**
     * ID of the model.
     */
    'id': string;
    /**
     * Optional second ID of the model. This value can be unset via an empty string.
     */
    'id2'?: string;
    /**
     * Optional message, used in case the model was denied.
     */
    'msg'?: string;
    /**
     * Model name.
     */
    'name'?: string;
    /**
     * Organization ID of the user that owns the model.
     */
    'org_id'?: string;
    'stat': ResModelStatus;
    /**
     * ShapeDiver User ID of the model owner.
     */
    'user_id'?: string;
    /**
     * The webhook-url for updating the platform backend about model status changes.
     */
    'webhook_url'?: string;
    /**
     * The webhook-token for authentication used by the webhook-url.
     */
    'webhook_token'?: string;
}


export interface ResModelBlockingReasons {
    /**
     * The model owner\'s credit limit has been exceeded.
     */
    'creditLimit': boolean;
    /**
     * The model has been blocked explicitly by its owner.
     */
    'owner': boolean;
    /**
     * The model uses a Grasshopper plugin that is not allowed for the owner.
     */
    'pluginPermission': boolean;
}
/**
 * Information about a model cleanup process.
 */
export interface ResModelCleanupProcess {
    /**
     * Type of the model cleanup process.
     */
    'type': ResModelCleanupProcessType;
    /**
     * The timestamp when the deletion job has been enqueued.
     */
    'timestamp_enqueued': string;
    /**
     * The total number of items of this type that are going to be deleted.
     */
    'total'?: number;
    /**
     * The number of already deleted items of this type.
     */
    'deleted'?: number;
}


/**
 * Model cleanup process types.
 */

export const ResModelCleanupProcessType = {
    DELETE_EXPORT_VERSION: 'delete_export_version',
    DELETE_MODEL_TEXTURE: 'delete_model_texture',
    DELETE_OUTPUT_VERSION: 'delete_output_version'
} as const;

export type ResModelCleanupProcessType = typeof ResModelCleanupProcessType[keyof typeof ResModelCleanupProcessType];


/**
 * Components of a model computation request.
 */
export interface ResModelComputation {
    /**
     * ID of the model.
     */
    'id': string;
    /**
     * Numeric timestamp in format `YYYYMMDDHHMMSSMMM`.  Deprecated: Use `timestamp_str` instead.
     * @deprecated
     */
    'timestamp': number;
    /**
     * Timestamp.
     */
    'timestamp_str': string;
    /**
     * The ID of the compute request that was processed.
     */
    'compute_request_id': string;
    /**
     * Requested export versions.
     */
    'exports': { [key: string]: string; };
    /**
     * Requested output versions.
     */
    'outputs': { [key: string]: string; };
    /**
     * Parameter values.
     */
    'params': object;
    /**
     * The stats of the computation request.
     */
    'stats': ResModelComputationStats;
    /**
     * Result of processing request.
     */
    'status': ResComputationStatus;
    /**
     * Timestamp when the computation request was finished.
     */
    'timestamp_fin': string;
    /**
     * Timestamp when the work request was filed.
     */
    'timestamp_req': string;
    /**
     * Timestamp when the computation request was filed.
     */
    'timestamp_req_iso': string;
    /**
     * Timestamp when the computation request was picked up.
     */
    'timestamp_resp': string;
    /**
     * Message containing information about the computation process.
     */
    'msg'?: string;
    /**
     * Model\'s limits at the time of the computation process.
     */
    'limit'?: ResComputationLimits;
    /**
     * The number of credits that are charged for this computation.
     */
    'credits'?: number;
}


/**
 * Stats of a computation request.
 */
export interface ResModelComputationStats {
    /**
     * Total size in bytes of the uncompressed resulting assets.
     */
    'size_assets'?: number;
    /**
     * Total size in bytes of the (potentially compressed) assets uploaded to storage.
     */
    'size_assets_storage'?: number;
    /**
     * The number of milliseconds it took to answer the request.
     */
    'time_completion': number;
    /**
     * The number of milliseconds it took to download the model from storage. `0` in case model was already downloaded to the instance.
     */
    'time_model_download': number;
    /**
     * The number of milliseconds it took to  load (open) the model. `0` in case model was already loaded.  Note: Does not include time for script compilation and first computation.
     */
    'time_model_open': number;
    /**
     * The number of milliseconds it took to process the request.
     */
    'time_processing': number;
    /**
     * The number of milliseconds it took to carry out checks that are done before loading the model.
     */
    'time_check_stored': number;
    /**
     * The number of milliseconds it took to carry out check that are done after loading the model.
     */
    'time_check_loaded': number;
    /**
     * The number of milliseconds it took to upload assets to storage.
     */
    'time_storage'?: number;
    /**
     * The number of milliseconds for Grasshopper solver.
     */
    'time_solver': number;
    /**
     * The number of milliseconds it took to collect output and export data after computation.
     */
    'time_solver_collect'?: number;
    /**
     * The number of milliseconds it took to download and load the model and setting parameters, and to compute the solution.
     */
    'time_solver_ext': number;
    /**
     * The number of milliseconds the request was waiting before being processed.
     */
    'time_wait': number;
    /**
     * The number of milliseconds it took to store the results of the request in the cache.
     */
    'time_cache_outputs'?: number;
    /**
     * Information about model computations.
     */
    'model'?: ResComputationComponents;
    /**
     * The number of milliseconds the CPU was used to carry out checks which are done before loading the model.
     */
    'cpu_time_check_stored'?: number;
    /**
     * The number of milliseconds the CPU was used to carry out checks which are done after loading the model.
     */
    'cpu_time_check_loaded'?: number;
    /**
     * The number of milliseconds the CPU was used to upload assets to storage.
     */
    'cpu_time_storage'?: number;
    /**
     * The number of milliseconds the CPU was used to download the model from storage.
     */
    'cpu_time_model_download'?: number;
    /**
     * The number of milliseconds the CPU was used to  load (open) the model. `0` in case model was already loaded.
     */
    'cpu_time_model_open'?: number;
    /**
     * The number of milliseconds the CPU was used for Grasshopper solver.
     */
    'cpu_time_solver'?: number;
    /**
     * The number of milliseconds the CPU was used to collect output and export data after computation.
     */
    'cpu_time_solver_collect'?: number;
    /**
     * The number of milliseconds the CPU was used to download and load the model and setting parameters, and to compute the solution.
     */
    'cpu_time_solver_ext'?: number;
    /**
     * The number of milliseconds the CPU was used to store the results of the request in the cache.
     */
    'cpu_time_cache_outputs'?: number;
    /**
     * The number of milliseconds it took to prepare the model after loading it. As an example, preparation includes compilation of scripts.
     */
    'time_model_prepare'?: number;
    /**
     * The number of milliseconds the CPU was used to prepare the model after loading it. As an example, preparation includes compilation of scripts.
     */
    'cpu_time_model_prepare'?: number;
}
/**
 * Aggregated credit metrics for a model.
 */
export interface ResModelCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     */
    'isCompilationDone': boolean;
    'ar': ResArCreditMetric;
    'loading': ResLoadingCreditMetric;
    'limited': ResLimitedCreditMetric;
    'default': ResDefaultCreditMetric;
    /**
     * Requested model ID.
     */
    'modelId': string;
    /**
     * This property is never set.
     * @deprecated
     */
    'userId'?: boolean | null;
    /**
     * This property is never set.
     * @deprecated
     */
    'orgId'?: boolean | null;
}
export interface ResModelList {
    /**
     * A directory of file objects.
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     */
    'model': Array<ResModel>;
    /**
     * A directory of Model-States.
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     */
    'texture'?: Array<ResTexture>;
}
/**
 * Aggregated credit metrics for a model-organization.
 */
export interface ResModelOrganizationCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     */
    'isCompilationDone': boolean;
    'ar': ResArCreditMetric;
    'loading': ResLoadingCreditMetric;
    'limited': ResLimitedCreditMetric;
    'default': ResDefaultCreditMetric;
    /**
     * Requested model ID.
     */
    'modelId': string;
    /**
     * Requested organization ID.
     */
    'orgId': string;
}
export interface ResModelSettings {
    /**
     * Allows the usage of the CDN for fast content distribution.
     */
    'use_cdn'?: boolean;
    /**
     * Indicates if the model supports CDN-based asset URLs.
     */
    'cdn_supported'?: boolean;
    'blockingReasons'?: ResModelBlockingReasons;
}
/**
 * Definition of a Model-State.
 */
export interface ResModelState {
    /**
     * A directory of parameter IDs and values.
     */
    'parameters': { [key: string]: ResParameterValue; };
    /**
     * Optional untyped data that holds additional information.
     */
    'data'?: { [key: string]: any; };
    /**
     * ID of the Model-State.
     */
    'id': string;
    /**
     * ID of the ShapeDiver model.
     */
    'modelId': string;
    /**
     * Timestamp of creation of the Model-State.
     */
    'createdate': string;
    /**
     * The URL of the Model-State image.
     */
    'imageUrl'?: string;
}
/**
 * Model-State image asset.
 */
export interface ResModelStateAsset {
    /**
     * A directory of parameter-IDs and asset-definitions.
     */
    'file'?: { [key: string]: ResAssetDefinition; };
    'sdtf'?: Array<ResAssetDefinition>;
    /**
     * The asset-definition of a Model-State image.
     */
    'modelState': ResAssetDefinition;
}
/**
 * Parameter and additional data of a Model-State.
 */
export interface ResModelStateData {
    /**
     * A directory of parameter IDs and values.
     */
    'parameters': { [key: string]: ResParameterValue; };
    /**
     * Optional untyped data that holds additional information.
     */
    'data'?: { [key: string]: any; };
}
/**
 * Basic information about a Model-State.
 */
export interface ResModelStateInfo {
    /**
     * ID of the Model-State.
     */
    'id': string;
    /**
     * A directory of parameter IDs and values.
     */
    'parameters': { [key: string]: ResParameterValue; };
    /**
     * Indicates whether the Model-State includes an image.
     */
    'hasImage': boolean;
    /**
     * Indicates whether the Model-State includes a glTF asset.
     */
    'hasGltf': boolean;
    /**
     * Indicates whether the Model-State includes a USDZ asset.
     */
    'hasUsdz': boolean;
}
export interface ResModelStateList {
    /**
     * A directory of file objects.
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     */
    'modelState': Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     */
    'texture'?: Array<ResTexture>;
}
/**
 * @type ResModelStateOrData
 */
export type ResModelStateOrData = ResModelState | ResModelStateData;

/**
 * Aggregated model session statistics.
 */
export interface ResModelStatistic {
    /**
     * Requested model ID.
     */
    'modelid': string;
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     */
    'isCompilationDone': boolean;
    /**
     * Number of (technical) sessions for the given model and timestamp. A technical session may last up to two hours, after which it will get cancelled by the backend.  CAUTION: Not to be confused with credits!
     */
    'count': number;
    /**
     * Billable duration-based credit count, based on maximum duration of 10 minutes per credit.
     */
    'billableCount': number;
    /**
     * Statistics on the duration of all sessions.
     */
    'duration': ResOnDurationStatistic;
    /**
     * Statistics on the duration of app sessions.
     */
    'app': ResOnDurationStatistic;
    /**
     * Statistics on the duration of backend sessions.
     */
    'backend': ResOnDurationStatistic;
    /**
     * Statistics on the duration of embedded sessions.
     */
    'embedded': ResOnDurationStatistic;
    /**
     * Statistics on the duration of desktop sessions.
     */
    'desktop': ResOnDurationStatistic;
    /**
     * Statistics on customization requests per session.
     */
    'customize': ResOnActionStatistic;
    /**
     * Statistics on export requests per session.
     */
    'export': ResOnActionStatistic;
}
/**
 * Status of the model.
 */

export const ResModelStatus = {
    UNKNOWN: 'unknown',
    NOT_UPLOADED: 'not_uploaded',
    UPLOADED: 'uploaded',
    PENDING: 'pending',
    CONFIRMED: 'confirmed',
    DENIED: 'denied',
    DELETED: 'deleted'
} as const;

export type ResModelStatus = typeof ResModelStatus[keyof typeof ResModelStatus];


/**
 * Aggregated credit metrics for a model-user.
 */
export interface ResModelUserCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     */
    'isCompilationDone': boolean;
    'ar': ResArCreditMetric;
    'loading': ResLoadingCreditMetric;
    'limited': ResLimitedCreditMetric;
    'default': ResDefaultCreditMetric;
    /**
     * Requested model ID.
     */
    'modelId': string;
    /**
     * Requested user ID.
     */
    'userId': string;
}
export interface ResOnActionStatistic {
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Number of (technical) sessions   from all sources (duration) or from one specific source (app, embedded, backend,   desktop), for the given model and timestamp. * `export`, `customize`: Number of sessions which have export requests.
     */
    'count': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Billable duration-based credit   count for all sessions, based on maximum duration of 10 minutes per credit. * `export`, `customize`: Billable duration-based credit count for sessions which have   export requests, based on maximum duration of 10 minutes per credit.
     */
    'billableCount': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Cumulative distribution function   of the duration, for all sessions for the given model and timestamp. * `export`, `customize`: Cumulative distribution function of the number of export   requests per session, for sessions which have export requests.
     */
    'min': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Cumulative distribution function   of the duration, for all sessions for the given model and timestamp. * `export`, `customize`: Cumulative distribution function of the number of export   requests per session, for sessions which have export requests.
     */
    'max': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Average duration of all sessions   for the given model and timestamp. * `export`, `customize`: Average number of export requests per session, for sessions   which have export requests.
     */
    'avg': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Total duration of all sessions   for the given model and timestamp. * `export`, `customize`: Total number of export requests for all sessions which have   export requests.
     */
    'sum': number;
    /**
     * `customize`: Total number of actions, for ShapeDiver Platform sessions for which the type of action happened.  Note: New property - will contain `0` for entries before November 2019.
     */
    'sumApp': number;
    /**
     * `customize`: Total number of customization requests for backend sessions which have customization requests.  `export`: Total number of export requests for backend sessions which have export requests.  Note: New property - will contain `0` for entries before November 2019.
     */
    'sumBackend': number;
    /**
     * `customize`: Total number of customization requests for embedded sessions which have customization requests.  `export`: Total number of export requests for embedded sessions which have export requests.  Note: New property - will contain `0` for entries before November 2019.
     */
    'sumEmbedded': number;
    /**
     * `customize`: Total number of actions, for desktop client sessions for which the type of action happened.  Note: New property - will contain `0` for entries before January 2021.
     */
    'sumDesktop': number;
}
export interface ResOnDurationStatistic {
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Number of (technical) sessions   from all sources (duration) or from one specific source (app, embedded, backend,   desktop), for the given model and timestamp. * `export`, `customize`: Number of sessions which have export requests.
     */
    'count': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Billable duration-based credit   count for all sessions, based on maximum duration of 10 minutes per credit. * `export`, `customize`: Billable duration-based credit count for sessions which have   export requests, based on maximum duration of 10 minutes per credit.
     */
    'billableCount': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Cumulative distribution function   of the duration, for all sessions for the given model and timestamp. * `export`, `customize`: Cumulative distribution function of the number of export   requests per session, for sessions which have export requests.
     */
    'min': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Cumulative distribution function   of the duration, for all sessions for the given model and timestamp. * `export`, `customize`: Cumulative distribution function of the number of export   requests per session, for sessions which have export requests.
     */
    'max': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Average duration of all sessions   for the given model and timestamp. * `export`, `customize`: Average number of export requests per session, for sessions   which have export requests.
     */
    'avg': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Total duration of all sessions   for the given model and timestamp. * `export`, `customize`: Total number of export requests for all sessions which have   export requests.
     */
    'sum': number;
}
/**
 * Aggregated credit metrics for a organization.
 */
export interface ResOrganizationCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     */
    'isCompilationDone': boolean;
    'ar': ResArCreditMetric;
    'loading': ResLoadingCreditMetric;
    'limited': ResLimitedCreditMetric;
    'default': ResDefaultCreditMetric;
    /**
     * This property is never set.
     * @deprecated
     */
    'modelId'?: boolean | null;
    /**
     * Requested organization ID.
     */
    'orgId': string;
}
/**
 * Output definition WITH results as exposed on the API.
 */
export interface ResOutput {
    /**
     * ID of the output, dependent on model ID, and therefore changing each time a model gets uploaded.
     */
    'id': string;
    /**
     * Constant ID of the output, not dependent on model ID, and therefore NOT changing each time a model gets uploaded. Might be undefined because this property was introduced in summer 2020 and does not exist for outputs of older models.
     */
    'uid'?: string;
    /**
     * Name of the output.
     */
    'name': string;
    /**
     * Optional ID of the output holding material information for this output.
     */
    'material'?: string;
    /**
     * Information about which chunks exist in the asset/sdTF.
     */
    'chunks'?: Array<ResOutputChunk>;
    /**
     * List of IDs of parameters influencing this output.
     */
    'dependency': Array<string>;
    /**
     * Group information of an output definition.
     */
    'group'?: CommonsGroup;
    /**
     * Ordering of the output in client applications.
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     */
    'hidden': boolean;
    /**
     * A unique identifier for the particular version of the output. This is a hash code which is based on the parameter values that were used to compute the resulting data. The hash code only depends on the values of the parameters which may theoretically influence the results of the output. As an example, parameters which are in no way connected to the output component in Grasshopper are not considered.
     */
    'version': string;
    /**
     * The delay in milliseconds after which a cache request shall be sent to check again for this output version. This property is used ONLY if the output version has not been computed yet.  Note that the existence of this property does not necessarily imply the presence of an active or queued computation for the respective output version.
     */
    'delay'?: number;
    /**
     * Result parts. In case this array does not exist, this means that the workers have not finished computation for this output version.
     */
    'content'?: Array<ResOutputContent>;
    /**
     * Optional bounding box, minimum corner.
     */
    'bbmin'?: Array<number>;
    /**
     * Optional bounding box, maximum corner.
     */
    'bbmax'?: Array<number>;
    /**
     * In case computation of the export version (temporarily) failed. Contains a message explaining what went wrong.
     */
    'msg'?: string;
    /**
     * Status of the computation which resulted in the output version.
     */
    'status_computation'?: ResComputationStatus;
    /**
     * Status of collecting results for the output version.
     */
    'status_collect'?: ResComputationStatus;
}


/**
 * Represents a collection of nodes where to start enumerating the content of the sdTF file (entry points).
 */
export interface ResOutputChunk {
    /**
     * ID of the chunk.
     */
    'id': string;
    /**
     * Name of the chunk.
     */
    'name': string;
    /**
     * Indicates what type of data the data item holds.
     */
    'typeHint': string;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
    /**
     * Custom name to display instead of `name`. Empty string if not set.
     */
    'displayname': string;
    /**
     * Controls whether the chunk should be hidden in the UI.
     */
    'hidden': boolean;
}
/**
 * An item of the `content` array for outputs.
 */
export interface ResOutputContent {
    /**
     * Optional link to asset.
     */
    'href'?: string;
    /**
     * Size in bytes for parts of type `asset`.
     */
    'size'?: number;
    /**
     * Optionally used for type `data`.
     */
    'name'?: string;
    /**
     * Transformations to be applied in case of type `external` or `asset`.
     */
    'transformations'?: Array<Array<number>>;
    /**
     * Format of part, used by all types of parts. * File ending for parts of type `asset`. * `material` (data contains a material definition). * `data` (data contains arbitrary data). * `external` (href or storage information that refer to an external asset).
     */
    'format': string;
    /**
     * This was used by legacy `transform_content_array` in case of an error in getting texture URLs.
     */
    'msg'?: string;
    /**
     * Used for types `material` and `data`.
     */
    'data'?: any;
    /**
     * Optional Content-Type for parts of type `asset`.
     */
    'contentType'?: string;
}
/**
 * Output definition WITHOUT results as exposed on the API.
 */
export interface ResOutputDefinition {
    /**
     * ID of the output, dependent on model ID, and therefore changing each time a model gets uploaded.
     */
    'id': string;
    /**
     * Constant ID of the output, not dependent on model ID, and therefore NOT changing each time a model gets uploaded. Might be undefined because this property was introduced in summer 2020 and does not exist for outputs of older models.
     */
    'uid'?: string;
    /**
     * Name of the output.
     */
    'name': string;
    /**
     * Optional ID of the output holding material information for this output.
     */
    'material'?: string;
    /**
     * Information about which chunks exist in the asset/sdTF.
     */
    'chunks'?: Array<ResOutputChunk>;
    /**
     * List of IDs of parameters influencing this output.
     */
    'dependency': Array<string>;
    /**
     * Group information of an output definition.
     */
    'group'?: CommonsGroup;
    /**
     * Ordering of the output in client applications.
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     */
    'hidden': boolean;
    /**
     * This property is never set.
     * @deprecated
     */
    'version'?: boolean | null;
}
export interface ResOutputList {
    /**
     * A directory of file objects.
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     */
    'output': Array<ResOutput>;
    /**
     * A directory of export versions.
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     */
    'texture'?: Array<ResTexture>;
}
/**
 * @type ResOutputOrDefinition
 * Either a full output or it\'s definition.
 */
export type ResOutputOrDefinition = ResOutput | ResOutputDefinition;

/**
 * Pagination component.
 */
export interface ResPagination {
    /**
     * The query limit that has been used in the request.
     */
    'limit': number;
    /**
     * The offset that can be used in the next request to query the remaining items. This property is missing when all items have been processed.
     */
    'next_offset'?: string;
}
/**
 * Definition of a parameter of a ShapeDiver Model.
 */
export interface ResParameter {
    /**
     * Unique ID of parameter, stays constant each time a model gets uploaded.
     */
    'id': string;
    /**
     * Choice of parameter values for types `STRINGLIST`.
     */
    'choices'?: Array<string>;
    /**
     * Number of decimal places for numeric types.
     */
    'decimalplaces'?: number;
    /**
     * Default value of parameter, stringified.
     */
    'defval'?: string;
    /**
     * Optional expression to be applied to value for visualisation.
     */
    'expression'?: string;
    /**
     * List of file formats (content types) supported, used for type `FILE`.
     */
    'format'?: Array<string>;
    /**
     * Minimum value (stringified) for numeric types.
     */
    'min'?: number;
    /**
     * Maximum: * value (stringified) for numeric types. * string length for type `STRING`. * file size allowed (stringified) for type FILE.
     */
    'max'?: number;
    /**
     * Minimum `u` value for two dimensional domain parameters.
     */
    'umin'?: number;
    /**
     * Maximum `u` value for two dimensional domain parameters.
     */
    'umax'?: number;
    /**
     * Minimum `v` value for two dimensional domain parameters.
     */
    'vmin'?: number;
    /**
     * Maximum `v` value for two dimensional domain parameters.
     */
    'vmax'?: number;
    /**
     * Step size used for domain parameters.
     */
    'interval'?: number;
    /**
     * Name of the parameter.
     */
    'name': string;
    /**
     * Type of parameter.
     */
    'type': ResParameterType;
    /**
     * Optional preferred visualization for parameters of type `FILE` and `STRINGLIST`.
     */
    'visualization'?: ResVisualizationType;
    /**
     * Structure of a parameter.
     */
    'structure'?: ResStructureType;
    /**
     * Group information of a parameter.
     */
    'group'?: CommonsGroup;
    /**
     * Technical hint for the UI implementation.
     */
    'hint'?: string;
    /**
     * Ordering of the parameter in client applications.
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     */
    'hidden': boolean;
    /**
     * Holds parameter-type specific information.
     */
    'settings'?: object;
}


/**
 * Type of parameter.  All types starting with \'s\' are s-type parameters while the others are basic parameter types.
 */

export const ResParameterType = {
    S_BITMAP: 'sBitmap',
    S_BOOL: 'sBool',
    S_BOX: 'sBox',
    S_BREP: 'sBrep',
    S_CIRCLE: 'sCircle',
    S_COLOR: 'sColor',
    S_CURVE: 'sCurve',
    S_DOMAIN: 'sDomain',
    S_DOMAIN_2D: 'sDomain2D',
    S_INTEGER: 'sInteger',
    S_LINE: 'sLine',
    S_MESH: 'sMesh',
    S_NUMBER: 'sNumber',
    S_PLANE: 'sPlane',
    S_POINT: 'sPoint',
    S_RECTANGLE: 'sRectangle',
    S_STRING: 'sString',
    S_SUBDIV: 'sSubdiv',
    S_SURFACE: 'sSurface',
    S_TIME: 'sTime',
    S_VECTOR: 'sVector',
    BOOL: 'Bool',
    COLOR: 'Color',
    DRAWING: 'Drawing',
    EVEN: 'Even',
    FILE: 'File',
    FLOAT: 'Float',
    INT: 'Int',
    INTERACTION: 'Interaction',
    ODD: 'Odd',
    STRING: 'String',
    STRINGLIST: 'StringList',
    TIME: 'Time',
    UNKNOWN: 'unknown'
} as const;

export type ResParameterType = typeof ResParameterType[keyof typeof ResParameterType];


/**
 * @type ResParameterValue
 * The value of a single model parameter. Supported parameter values are: * Basic parameter (`ResBasicParameter`) * S-type parameter (`ResStypeParameter`)
 */
export type ResParameterValue = ResBasicParameter | ResStypeParameter;

export interface ResPartActions {
    /**
     * Actions the client may take.
     */
    'actions'?: Array<ResAction>;
}
export interface ResPartAnalytics {
    /**
     * Statistics of the model for the given timespan.
     */
    'analytics'?: ResAnalytics;
}
export interface ResPartAuthorizationGroup {
    /**
     * The auth-group to use for ticked-based authentication.
     */
    'auth_group'?: string;
}
export interface ResPartCleanup {
    /**
     * Model cleanup information.
     */
    'cleanup'?: Array<ResModelCleanupProcess>;
}
export interface ResPartDecryptedTicket {
    /**
     * Decrypted ticket details.
     */
    'decryptedTicket'?: ResTicket;
}
export interface ResPartExports {
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
}
export interface ResPartFile {
    /**
     * Links regarding the model file.
     */
    'file'?: ResFile;
}
export interface ResPartGltfUpload {
    /**
     * glTF information.
     */
    'gltf'?: ResGltfUpload;
}
export interface ResPartMessage {
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
}
export interface ResPartModel {
    /**
     * The definitions of a ShapeDiver model.
     */
    'model'?: ResModel;
}
export interface ResPartModelComputation {
    /**
     * Statistics about model computations.
     */
    'computations'?: Array<ResModelComputation>;
}
export interface ResPartModelState {
    /**
     * Model-State information.
     */
    'modelState'?: ResModelState;
}
export interface ResPartModelStateData {
    /**
     * Model-State information.
     */
    'modelState'?: ResModelStateData;
}
export interface ResPartOutputs {
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
}
export interface ResPartPagination {
    /**
     * Pagination information.
     */
    'pagination'?: ResPagination;
}
export interface ResPartParameters {
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     */
    'parameters'?: { [key: string]: ResParameter; };
}
export interface ResPartPlugins {
    'plugins'?: ResPlugins;
}
export interface ResPartSessionId {
    /**
     * The ID of the created session.
     */
    'sessionId'?: string;
}
export interface ResPartSetting {
    /**
     * Various settings.
     */
    'setting'?: ResSettings;
}
export interface ResPartStatistic {
    /**
     * Statistics of a model.
     */
    'statistic'?: ResStatistic;
}
export interface ResPartTemplates {
    /**
     * Request templates for actions.
     */
    'templates'?: Array<ResTemplate>;
}
export interface ResPartTicket {
    /**
     * The ticket to create a model session.
     */
    'ticket'?: string;
}
export interface ResPartVersion {
    /**
     * Version of the Geometry Backend API.
     */
    'version'?: string;
}
export interface ResPartViewer {
    /**
     * Viewer specific data.
     */
    'viewer'?: ResViewer;
}
export interface ResPartViewerSettingsVersion {
    /**
     * The current version of the viewer settings.
     */
    'viewerSettingsVersion'?: string;
}
export interface ResPartWarnings {
    /**
     * An array of warnings encountered during request processing. These warnings indicate potential issues or non-critical conditions but did not prevent the request from being successfully processed.
     */
    'warnings'?: Array<string>;
}
/**
 * Information about Grasshopper plugins.
 */
export interface ResPlugins {
    /**
     * Libraries used by the model.
     */
    'libraries'?: Array<ResPluginsLibrary>;
}
/**
 * Definition of a model library.
 */
export interface ResPluginsLibrary {
    /**
     * Library ID.
     */
    'id': string;
    /**
     * Library version.
     */
    'version': string;
    /**
     * Library name.
     */
    'name': string;
    /**
     * Library author.
     */
    'author': string;
    /**
     * Assembly name (not present in Rhino 5).
     */
    'assemblyFullName'?: string;
    /**
     * Assembly version (not present in Rhino 5).
     */
    'assemblyVersion'?: string;
}
/**
 * Combined output and export requests.
 */
export interface ResRateLimitedCombinedMetric {
    /**
     * Number of combined output and export requests charged.
     */
    'credits': number;
}
/**
 * Computations information.
 */
export interface ResRateLimitedComputationMetric {
    /**
     * Number of computations.
     */
    'count': number;
    /**
     * Number of finished 10-second chunks charged.
     */
    'credits': number;
    /**
     * Total duration of computation time, in milliseconds.
     */
    'duration': number;
    /**
     * Count of computations per computation time expressed in started 10-second chunks.
     */
    'countPerChunks': { [key: string]: number; };
}
/**
 * Pure export requests.
 */
export interface ResRateLimitedExportMetric {
    /**
     * Number of pure export requests charged.
     */
    'credits': number;
}
/**
 * Pure output requests.
 */
export interface ResRateLimitedOutputMetric {
    /**
     * Number of pure output requests.
     */
    'count': number;
}
/**
 * Session information.
 */
export interface ResRateLimitedSessionMetric {
    /**
     * Number of sessions.
     */
    'count': number;
    /**
     * Number of started 10-minute periods of sessions charged.
     */
    'credits': number;
    /**
     * The total duration of all sessions, in milliseconds.
     */
    'duration': number;
}
/**
 * Scale-in candidate system information.
 */
export interface ResScaleInCandidate {
    /**
     * System information about the Geometry Minions.
     */
    'minions'?: ResMinionInfo;
    /**
     * System information about the Geometry Workers.
     */
    'workers'?: ResWorkerInfo;
    /**
     * Scale-in candidate information for worker instances.
     */
    'scaleInCandidate': ResWorkerScaleInCandidate;
}
/**
 * sdTF assets.
 */
export interface ResSdtfAsset {
    /**
     * A directory of parameter-IDs and asset-definitions.
     */
    'file'?: { [key: string]: ResAssetDefinition; };
    'sdtf': Array<ResAssetDefinition>;
    /**
     * The asset-definition of a Model-State image.
     */
    'modelState'?: ResAssetDefinition;
}
/**
 * Result part for the response to a list request for sdTF objects.
 */
export interface ResSdtfInfo {
    /**
     * ID of the sdTF.
     */
    'id': string;
    /**
     * The namespace of the sdTF.
     */
    'namespace': string;
    /**
     * The size of the sdTF in bytes.
     */
    'size': number;
}
export interface ResSdtfList {
    /**
     * A directory of file objects.
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     */
    'sdtf': Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     */
    'texture'?: Array<ResTexture>;
}
/**
 * Definition of settings.
 */
export interface ResSettings {
    'auth'?: ResAuthorizationSettings;
    'compute'?: ResComputeSettings;
    'model'?: ResModelSettings;
}
/**
 * Model statistic object.
 */
export interface ResStatistic {
    /**
     * Cumulative time (msec) which has been spent for processing computation requests by the workers (pure computation time).
     */
    'comptime'?: number;
    /**
     * Timestamp of last session created for the model.
     */
    'lastsession'?: string;
    /**
     * Timestamp of last view of the model.
     */
    'lastview'?: string;
    /**
     * Approximate memory usage of model on workers, in bytes.
     */
    'memUsage'?: number;
    /**
     * Number of computations which have been carried out for the model by the workers so far.
     */
    'numcomp'?: number;
    /**
     * Number of sessions which have been opened for the model so far.
     */
    'numsessions'?: number;
    /**
     * Cumulative time (msec) which has been spent for processing computation requests by the workers (computation time plus overheads).
     */
    'requesttime'?: number;
    /**
     * File size of the model file in bytes.
     */
    'size'?: number;
}
/**
 * Structural information of a parameter.
 */

export const ResStructureType = {
    ITEM: 'item',
    LIST: 'list',
    TREE: 'tree'
} as const;

export type ResStructureType = typeof ResStructureType[keyof typeof ResStructureType];


/**
 * Definition of the value to use for s-type parameters.
 */
export interface ResStypeParameter {
    /**
     * Optional embedded value. If this is set the asset is ignored.
     */
    'value'?: string;
    'asset'?: CommmonsParameterAsset;
}
/**
 * ShapeDiver API response of system-request.
 */
export interface ResSystem {
    /**
     * System information about the Geometry Minions.
     */
    'minions'?: ResMinionInfo;
    /**
     * System information about the Geometry Workers.
     */
    'workers'?: ResWorkerInfo;
    /**
     * Scale-in candidate information for worker instances.
     */
    'scaleInCandidate'?: ResWorkerScaleInCandidate;
}
/**
 * Aggregated credit metrics for a system.
 */
export interface ResSystemCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     */
    'isCompilationDone': boolean;
    'ar': ResArCreditMetric;
    'loading': ResLoadingCreditMetric;
    'limited': ResLimitedCreditMetric;
    'default': ResDefaultCreditMetric;
    /**
     * Requested system.
     */
    'system': boolean;
}
/**
 * Provides templates for actions.
 */
export interface ResTemplate {
    /**
     * Name of the template, e.g. \'customize-request\'.
     */
    'name': string;
    /**
     * Title of the template, e.g. \'Template for model customization request\'.
     */
    'title': string;
    /**
     * Template for the request body.
     */
    'data': object;
}
/**
 * Information about a model texture.
 */
export interface ResTexture {
    /**
     * The ID of the ShapeDiver model.
     */
    'modelId': string;
    /**
     * The texture ID.
     */
    'textureId': string;
    /**
     * The original URL of the texture asset.
     */
    'url'?: string;
    /**
     * The width of the texture.
     */
    'width'?: number;
    /**
     * The height of the texture.
     */
    'height'?: number;
    /**
     * Is `true` when the texture has been cached, otherwise `false`.
     */
    'isAssetAvailable': boolean;
}
export interface ResTextureList {
    /**
     * A directory of file objects.
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     */
    'texture': Array<ResTexture>;
}
export interface ResTicket {
    /**
     * List of domains (origins) this ticket should be limited to; may be empty.
     */
    'accessdomains': Array<string>;
    /**
     * Should this ticket provide access to model authoring (allows to change configuration)?
     */
    'author': boolean;
    /**
     * Should this ticket allow public access (ignore the model\'s `accessdomains` property)?
     */
    'pub': boolean;
    /**
     * The timestamp until which the ticket should be valid.
     */
    'until': string;
    /**
     * Does this ticket identify the model via its secondary ID (model property `id2`)?
     */
    'use_id2': boolean;
    'type': ResTicketType;
    /**
     * Either the model\'s `id` or `id2` property, depending on the ticket property `use_id2`.
     */
    'model_id': string;
}


export interface ResTicketAuthorization {
    /**
     * List of domains (origins) this model is limited to (is ignored in case `model.pub` is true).
     */
    'accessdomains': Array<string>;
    /**
     * Should backend access to the model be allowed.
     */
    'backendaccess': boolean;
    /**
     * If this model allows public access (ignore `model.accessdomains`)?
     */
    'pub': boolean;
}
/**
 * The type of the ticket.
 */

export const ResTicketType = {
    BACKEND: 'backend',
    NONE: ''
} as const;

export type ResTicketType = typeof ResTicketType[keyof typeof ResTicketType];


export interface ResTokenAuthorization {
    /**
     * List of allowed auth-groups.
     */
    'auth_groups'?: Array<string>;
    /**
     * Enforces iframe embedding instead of direct embedding.
     */
    'require_iframe'?: boolean;
    /**
     * Enforces token-based authentication for this model.
     */
    'require_token'?: boolean;
}
export interface ResUpdateExportDefinitions {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResUpdateModel {
    /**
     * Links regarding the model file.
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     */
    'model': ResModel;
    /**
     * Various settings.
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     */
    'statistic': ResStatistic;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResUpdateModelConfig {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResUpdateOutputDefinitions {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResUpdateParameterDefaultValues {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResUpdateParameterDefinitions {
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResUploadFile {
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'asset': ResFileAsset;
}
export interface ResUploadGltf {
    /**
     * glTF information.
     */
    'gltf': ResGltfUpload;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
}
export interface ResUploadSdtf {
    /**
     * Contains urgent information about the system.
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     */
    'version': string;
    'asset': ResSdtfAsset;
}
/**
 * Aggregated credit metrics for a user.
 */
export interface ResUserCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     */
    'isCompilationDone': boolean;
    'ar': ResArCreditMetric;
    'loading': ResLoadingCreditMetric;
    'limited': ResLimitedCreditMetric;
    'default': ResDefaultCreditMetric;
    /**
     * This property is never set.
     * @deprecated
     */
    'modelId'?: boolean | null;
    /**
     * Requested user ID.
     */
    'userId': string;
}
/**
 * Viewer config object.
 */
export interface ResViewer {
    'config': { [key: string]: any; };
}
/**
 * Optional preferred visualization for parameters of type `FILE` and `STRINGLIST`.
 */

export const ResVisualizationType = {
    UNKNOWN: 'unknown',
    BUTTON: 'button',
    CALENDAR: 'calendar',
    CHECKLIST: 'checklist',
    CLOCK: 'clock',
    CYCLE: 'cycle',
    DIAL: 'dial',
    DROPDOWN: 'dropdown',
    GEOMETRY: 'geometry',
    IMAGE: 'image',
    SEQUENCE: 'sequence',
    SLIDER: 'slider',
    SWATCH: 'swatch',
    TEXT: 'text',
    TOGGLE: 'toggle'
} as const;

export type ResVisualizationType = typeof ResVisualizationType[keyof typeof ResVisualizationType];


export interface ResWarningComponent {
    /**
     * ID of component.
     */
    'component'?: string;
    /**
     * Instance ID of component.
     */
    'instance': string;
    /**
     * Name of component.
     */
    'name': string;
    /**
     * Nickname of component.
     */
    'nick_name': string;
    /**
     * Component Warnings descriptions.
     */
    'warnings': Array<string>;
}
/**
 * System information about the Geometry Workers.
 */
export interface ResWorkerInfo {
    /**
     * Version of the Grasshopper application.
     */
    'grasshopperVersion': string;
    /**
     * Holds information of all installed and allowed Grasshopper plugins.
     */
    'plugins': ResWorkerPlugins;
    /**
     * Version of the Rhino application.
     */
    'rhinoVersion': string;
    /**
     * Version of the ShapeDiver worker plugin.
     */
    'shapeDiverVersion': string;
}
/**
 * A Grasshopper plugin component that may not be used.
 */
export interface ResWorkerPluginComponent {
    /**
     * ID of the plugin component.
     */
    'id': string;
    /**
     * Name of the plugin component.
     */
    'name': string;
}
/**
 * Holds information of all installed and allowed Grasshopper plugins.
 */
export interface ResWorkerPlugins {
    /**
     * Contains information about all installed Grasshopper plugins.
     */
    'installed': Array<ResInstalledWorkerPlugin>;
    /**
     * Contains the model checking configuration for the Grasshopper plugins.
     */
    'allowed': Array<ResAllowedWorkerPlugin>;
    /**
     * Contains information about plugin inconsistencies.
     */
    'inconsistent': Array<string>;
}
/**
 * Information about a recommended scale-in candidate.
 */
export interface ResWorkerScaleInCandidate {
    /**
     * Indicates whether a scale-in candidate was successfully identified.
     */
    'success': boolean;
    /**
     * EC2 instance ID of the recommended scale-in candidate.
     */
    'instanceId'?: string;
}
/**
 * Worker system information.
 */
export interface ResWorkerSystem {
    /**
     * System information about the Geometry Minions.
     */
    'minions'?: ResMinionInfo;
    /**
     * System information about the Geometry Workers.
     */
    'workers': ResWorkerInfo;
    /**
     * Scale-in candidate information for worker instances.
     */
    'scaleInCandidate'?: ResWorkerScaleInCandidate;
}

/**
 * AnalyticsApi - axios parameter creator
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Subject-Restriction: __backend__ - ONLY for _system-metrics_.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics.
         * @param {ReqCreditMetrics} reqCreditMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditMetrics: async (reqCreditMetrics: ReqCreditMetrics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqCreditMetrics' is not null or undefined
            assertParamExists('getCreditMetrics', 'reqCreditMetrics', reqCreditMetrics)
            const localVarPath = `/api/v2/analytics/credit-metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCreditMetrics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the organization at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} orgId ID of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelOrganizationCreditMetrics: async (timestamp: string, orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getModelOrganizationCreditMetrics', 'timestamp', timestamp)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getModelOrganizationCreditMetrics', 'orgId', orgId)
            const localVarPath = `/api/v2/analytics/credit-metrics/timestamp/{timestamp}/org/{orgId}`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)))
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model session analytics.
         * @param {ReqModelStatistics} reqModelStatistics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStatistics: async (reqModelStatistics: ReqModelStatistics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqModelStatistics' is not null or undefined
            assertParamExists('getModelStatistics', 'reqModelStatistics', reqModelStatistics)
            const localVarPath = `/api/v2/analytics/session/model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqModelStatistics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the user at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} userId ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelUserCreditMetrics: async (timestamp: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getModelUserCreditMetrics', 'timestamp', timestamp)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getModelUserCreditMetrics', 'userId', userId)
            const localVarPath = `/api/v2/analytics/credit-metrics/timestamp/{timestamp}/user/{userId}`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all organizations with users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCreditMetrics: async (timestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrganizationCreditMetrics', 'timestamp', timestamp)
            const localVarPath = `/api/v2/analytics/credit-metrics/timestamp/{timestamp}/org`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditMetrics: async (timestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserCreditMetrics', 'timestamp', timestamp)
            const localVarPath = `/api/v2/analytics/credit-metrics/timestamp/{timestamp}/user`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Subject-Restriction: __backend__ - ONLY for _system-metrics_.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics.
         * @param {ReqCreditMetrics} reqCreditMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditMetrics(reqCreditMetrics: ReqCreditMetrics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditMetrics(reqCreditMetrics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the organization at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} orgId ID of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelOrganizationCreditMetrics(timestamp: string, orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelOrganizationCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelOrganizationCreditMetrics(timestamp, orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getModelOrganizationCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model session analytics.
         * @param {ReqModelStatistics} reqModelStatistics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelStatistics(reqModelStatistics: ReqModelStatistics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelStatistics(reqModelStatistics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getModelStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the user at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} userId ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelUserCreditMetrics(timestamp: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelUserCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelUserCreditMetrics(timestamp, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getModelUserCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all organizations with users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetOrganizationCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCreditMetrics(timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getOrganizationCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetUserCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCreditMetrics(timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getUserCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Subject-Restriction: __backend__ - ONLY for _system-metrics_.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics.
         * @param {ReqCreditMetrics} reqCreditMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditMetrics(reqCreditMetrics: ReqCreditMetrics, options?: RawAxiosRequestConfig): AxiosPromise<ResGetCreditMetrics> {
            return localVarFp.getCreditMetrics(reqCreditMetrics, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the organization at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} orgId ID of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelOrganizationCreditMetrics(timestamp: string, orgId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelOrganizationCreditMetrics> {
            return localVarFp.getModelOrganizationCreditMetrics(timestamp, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model session analytics.
         * @param {ReqModelStatistics} reqModelStatistics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStatistics(reqModelStatistics: ReqModelStatistics, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelStatistics> {
            return localVarFp.getModelStatistics(reqModelStatistics, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the user at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} userId ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelUserCreditMetrics(timestamp: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelUserCreditMetrics> {
            return localVarFp.getModelUserCreditMetrics(timestamp, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all organizations with users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetOrganizationCreditMetrics> {
            return localVarFp.getOrganizationCreditMetrics(timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetUserCreditMetrics> {
            return localVarFp.getUserCreditMetrics(timestamp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Subject-Restriction: __backend__ - ONLY for _system-metrics_.  Permissions: * `analytics.model.get.*` - __required__.
     * @summary Get credit metrics.
     * @param {ReqCreditMetrics} reqCreditMetrics 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCreditMetrics(reqCreditMetrics: ReqCreditMetrics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getCreditMetrics(reqCreditMetrics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `analytics.model.get.*` - __required__.
     * @summary Get model credit metrics of the organization at timestamp.
     * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
     * @param {string} orgId ID of the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelOrganizationCreditMetrics(timestamp: string, orgId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getModelOrganizationCreditMetrics(timestamp, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `analytics.model.get.*` - __required__.
     * @summary Get model session analytics.
     * @param {ReqModelStatistics} reqModelStatistics 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelStatistics(reqModelStatistics: ReqModelStatistics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getModelStatistics(reqModelStatistics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `analytics.model.get.*` - __required__.
     * @summary Get model credit metrics of the user at timestamp.
     * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
     * @param {string} userId ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelUserCreditMetrics(timestamp: string, userId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getModelUserCreditMetrics(timestamp, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions: * `analytics.model.get.*` - __required__.
     * @summary Get credit metrics of all organizations with users active at timestamp.
     * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrganizationCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getOrganizationCreditMetrics(timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions: * `analytics.model.get.*` - __required__.
     * @summary Get credit metrics of all users active at timestamp.
     * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getUserCreditMetrics(timestamp, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ArSceneApi - axios parameter creator
 */
export const ArSceneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads the glTF asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArSceneGltf: async (sceneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sceneId' is not null or undefined
            assertParamExists('downloadArSceneGltf', 'sceneId', sceneId)
            const localVarPath = `/api/v2/ar-scene/{sceneId}/gltf`
                .replace(`{${"sceneId"}}`, encodeURIComponent(String(sceneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads the USDZ asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArSceneUsdz: async (sceneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sceneId' is not null or undefined
            assertParamExists('downloadArSceneUsdz', 'sceneId', sceneId)
            const localVarPath = `/api/v2/ar-scene/{sceneId}/usdz`
                .replace(`{${"sceneId"}}`, encodeURIComponent(String(sceneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies whether an AR scene exists or if a Model-State is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArSceneMetadata: async (sceneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sceneId' is not null or undefined
            assertParamExists('getArSceneMetadata', 'sceneId', sceneId)
            const localVarPath = `/api/v2/ar-scene/{sceneId}`
                .replace(`{${"sceneId"}}`, encodeURIComponent(String(sceneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArSceneApi - functional programming interface
 */
export const ArSceneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArSceneApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Downloads the glTF asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArSceneGltf(sceneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArSceneGltf(sceneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArSceneApi.downloadArSceneGltf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Downloads the USDZ asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArSceneUsdz(sceneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArSceneUsdz(sceneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArSceneApi.downloadArSceneUsdz']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verifies whether an AR scene exists or if a Model-State is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArSceneMetadata(sceneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArSceneMetadata(sceneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArSceneApi.getArSceneMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArSceneApi - factory interface
 */
export const ArSceneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArSceneApiFp(configuration)
    return {
        /**
         * 
         * @summary Downloads the glTF asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArSceneGltf(sceneId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadArSceneGltf(sceneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads the USDZ asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArSceneUsdz(sceneId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadArSceneUsdz(sceneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verifies whether an AR scene exists or if a Model-State is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArSceneMetadata(sceneId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getArSceneMetadata(sceneId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArSceneApi - object-oriented interface
 */
export class ArSceneApi extends BaseAPI {
    /**
     * 
     * @summary Downloads the glTF asset of an AR scene or a Model-State that is linked to an AR scene.
     * @param {string} sceneId ID of the AR scene or Model-State.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadArSceneGltf(sceneId: string, options?: RawAxiosRequestConfig) {
        return ArSceneApiFp(this.configuration).downloadArSceneGltf(sceneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads the USDZ asset of an AR scene or a Model-State that is linked to an AR scene.
     * @param {string} sceneId ID of the AR scene or Model-State.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadArSceneUsdz(sceneId: string, options?: RawAxiosRequestConfig) {
        return ArSceneApiFp(this.configuration).downloadArSceneUsdz(sceneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verifies whether an AR scene exists or if a Model-State is linked to an AR scene.
     * @param {string} sceneId ID of the AR scene or Model-State.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getArSceneMetadata(sceneId: string, options?: RawAxiosRequestConfig) {
        return ArSceneApiFp(this.configuration).getArSceneMetadata(sceneId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetsApi - axios parameter creator
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Download an asset without a session (can be used via an URL in an email).
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAsset: async (assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadAsset', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/download/{assetDataEncrypted}`
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a single export.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExport: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadExport', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadExport', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/export/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a glTF file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadGltf: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadGltf', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadGltf', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/gltf/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download an image.
         * @param {string} sessionId Session ID.
         * @param {string} url Specify the Base64-encoded image URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadImage: async (sessionId: string, url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadImage', 'sessionId', sessionId)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('downloadImage', 'url', url)
            const localVarPath = `/api/v2/session/{sessionId}/image`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a single output.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOutput: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadOutput', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadOutput', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/output/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a single texture.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTexture: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadTexture', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadTexture', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/texture/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a USDZ file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUsdz: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadUsdz', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadUsdz', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/usdz/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Download an asset without a session (can be used via an URL in an email).
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAsset(assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAsset(assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a single export.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadExport(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadExport(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a glTF file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadGltf(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadGltf(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadGltf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download an image.
         * @param {string} sessionId Session ID.
         * @param {string} url Specify the Base64-encoded image URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadImage(sessionId: string, url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadImage(sessionId, url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a single output.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadOutput(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadOutput(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadOutput']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a single texture.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTexture(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTexture(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadTexture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a USDZ file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadUsdz(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadUsdz(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadUsdz']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsApi - factory interface
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Download an asset without a session (can be used via an URL in an email).
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAsset(assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadAsset(assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a single export.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExport(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadExport(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a glTF file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadGltf(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadGltf(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download an image.
         * @param {string} sessionId Session ID.
         * @param {string} url Specify the Base64-encoded image URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadImage(sessionId: string, url: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadImage(sessionId, url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a single output.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOutput(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadOutput(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a single texture.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTexture(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadTexture(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a USDZ file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUsdz(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<ResError> {
            return localVarFp.downloadUsdz(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 */
export class AssetsApi extends BaseAPI {
    /**
     * 
     * @summary Download an asset without a session (can be used via an URL in an email).
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadAsset(assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadAsset(assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a single export.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadExport(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadExport(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a glTF file.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadGltf(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadGltf(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download an image.
     * @param {string} sessionId Session ID.
     * @param {string} url Specify the Base64-encoded image URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadImage(sessionId: string, url: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadImage(sessionId, url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a single output.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadOutput(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadOutput(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a single texture.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadTexture(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadTexture(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a USDZ file.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadUsdz(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadUsdz(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the public keys of the JSON Web Key Set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKeySets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/jwks.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the public keys of the JSON Web Key Set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonWebKeySets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonWebKeySets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getJsonWebKeySets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the public keys of the JSON Web Key Set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKeySets(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getJsonWebKeySets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Get the public keys of the JSON Web Key Set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJsonWebKeySets(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getJsonWebKeySets(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthGroupApi - axios parameter creator
 */
export const AuthGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Subject-Restriction: __backend__.  Permissions: * `auth_group.create` - __required__.
         * @summary Create new authorization group.
         * @param {ReqAuthorizationGroup} reqAuthorizationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorizationGroup: async (reqAuthorizationGroup: ReqAuthorizationGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqAuthorizationGroup' is not null or undefined
            assertParamExists('createAuthorizationGroup', 'reqAuthorizationGroup', reqAuthorizationGroup)
            const localVarPath = `/api/v2/auth_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqAuthorizationGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthGroupApi - functional programming interface
 */
export const AuthGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Subject-Restriction: __backend__.  Permissions: * `auth_group.create` - __required__.
         * @summary Create new authorization group.
         * @param {ReqAuthorizationGroup} reqAuthorizationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthorizationGroup(reqAuthorizationGroup: ReqAuthorizationGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateAuthorizationGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthorizationGroup(reqAuthorizationGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthGroupApi.createAuthorizationGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthGroupApi - factory interface
 */
export const AuthGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthGroupApiFp(configuration)
    return {
        /**
         * Subject-Restriction: __backend__.  Permissions: * `auth_group.create` - __required__.
         * @summary Create new authorization group.
         * @param {ReqAuthorizationGroup} reqAuthorizationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorizationGroup(reqAuthorizationGroup: ReqAuthorizationGroup, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateAuthorizationGroup> {
            return localVarFp.createAuthorizationGroup(reqAuthorizationGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthGroupApi - object-oriented interface
 */
export class AuthGroupApi extends BaseAPI {
    /**
     * Subject-Restriction: __backend__.  Permissions: * `auth_group.create` - __required__.
     * @summary Create new authorization group.
     * @param {ReqAuthorizationGroup} reqAuthorizationGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAuthorizationGroup(reqAuthorizationGroup: ReqAuthorizationGroup, options?: RawAxiosRequestConfig) {
        return AuthGroupApiFp(this.configuration).createAuthorizationGroup(reqAuthorizationGroup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExportApi - axios parameter creator
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions: * `compute.export.*` - __required__. * `compute.output.*` - __required__ when _outputs_ are requested.
         * @summary Compute a Grasshopper exports for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqExport} reqExport 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeExports: async (sessionId: string, reqExport: ReqExport, ignoreUnknownParams?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('computeExports', 'sessionId', sessionId)
            // verify required parameter 'reqExport' is not null or undefined
            assertParamExists('computeExports', 'reqExport', reqExport)
            const localVarPath = `/api/v2/session/{sessionId}/export`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ignoreUnknownParams !== undefined) {
                localVarQueryParameter['ignoreUnknownParams'] = ignoreUnknownParams;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `cache.export.get.*` - __required__. * `cache.output.get.*` - __required__ when _outputs_ are requested.
         * @summary Get Export from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqExportOrCache} reqExportOrCache 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedExports: async (sessionId: string, reqExportOrCache: ReqExportOrCache, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getCachedExports', 'sessionId', sessionId)
            // verify required parameter 'reqExportOrCache' is not null or undefined
            assertParamExists('getCachedExports', 'reqExportOrCache', reqExportOrCache)
            const localVarPath = `/api/v2/session/{sessionId}/export/cache`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqExportOrCache, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `cache.export.list.*` - __required__.
         * @summary List export versions.
         * @param {string} sessionId Session ID.
         * @param {string} exportId Export ID.
         * @param {QueryComputationStatus} [statusComputation] Filter export versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter export versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportVersions: async (sessionId: string, exportId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listExportVersions', 'sessionId', sessionId)
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists('listExportVersions', 'exportId', exportId)
            const localVarPath = `/api/v2/session/{sessionId}/export/{exportId}/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (statusComputation !== undefined) {
                localVarQueryParameter['statusComputation'] = statusComputation;
            }

            if (statusCollect !== undefined) {
                localVarQueryParameter['statusCollect'] = statusCollect;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `set.export.ui` - __required__.
         * @summary Update definition of exports.
         * @param {string} modelId Model ID.
         * @param {ReqExportDefinitions} reqExportDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportDefinitions: async (modelId: string, reqExportDefinitions: ReqExportDefinitions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateExportDefinitions', 'modelId', modelId)
            // verify required parameter 'reqExportDefinitions' is not null or undefined
            assertParamExists('updateExportDefinitions', 'reqExportDefinitions', reqExportDefinitions)
            const localVarPath = `/api/v2/model/{modelId}/export`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqExportDefinitions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 */
export const ExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions: * `compute.export.*` - __required__. * `compute.output.*` - __required__ when _outputs_ are requested.
         * @summary Compute a Grasshopper exports for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqExport} reqExport 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeExports(sessionId: string, reqExport: ReqExport, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResComputeExports>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeExports(sessionId, reqExport, ignoreUnknownParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.computeExports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `cache.export.get.*` - __required__. * `cache.output.get.*` - __required__ when _outputs_ are requested.
         * @summary Get Export from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqExportOrCache} reqExportOrCache 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCachedExports(sessionId: string, reqExportOrCache: ReqExportOrCache, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetCachedExports>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCachedExports(sessionId, reqExportOrCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.getCachedExports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `cache.export.list.*` - __required__.
         * @summary List export versions.
         * @param {string} sessionId Session ID.
         * @param {string} exportId Export ID.
         * @param {QueryComputationStatus} [statusComputation] Filter export versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter export versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExportVersions(sessionId: string, exportId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListExportVersions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExportVersions(sessionId, exportId, statusComputation, statusCollect, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.listExportVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `set.export.ui` - __required__.
         * @summary Update definition of exports.
         * @param {string} modelId Model ID.
         * @param {ReqExportDefinitions} reqExportDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExportDefinitions(modelId: string, reqExportDefinitions: ReqExportDefinitions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateExportDefinitions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExportDefinitions(modelId, reqExportDefinitions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.updateExportDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExportApi - factory interface
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportApiFp(configuration)
    return {
        /**
         * Permissions: * `compute.export.*` - __required__. * `compute.output.*` - __required__ when _outputs_ are requested.
         * @summary Compute a Grasshopper exports for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqExport} reqExport 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeExports(sessionId: string, reqExport: ReqExport, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResComputeExports> {
            return localVarFp.computeExports(sessionId, reqExport, ignoreUnknownParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `cache.export.get.*` - __required__. * `cache.output.get.*` - __required__ when _outputs_ are requested.
         * @summary Get Export from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqExportOrCache} reqExportOrCache 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedExports(sessionId: string, reqExportOrCache: ReqExportOrCache, options?: RawAxiosRequestConfig): AxiosPromise<ResGetCachedExports> {
            return localVarFp.getCachedExports(sessionId, reqExportOrCache, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `cache.export.list.*` - __required__.
         * @summary List export versions.
         * @param {string} sessionId Session ID.
         * @param {string} exportId Export ID.
         * @param {QueryComputationStatus} [statusComputation] Filter export versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter export versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportVersions(sessionId: string, exportId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListExportVersions> {
            return localVarFp.listExportVersions(sessionId, exportId, statusComputation, statusCollect, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `set.export.ui` - __required__.
         * @summary Update definition of exports.
         * @param {string} modelId Model ID.
         * @param {ReqExportDefinitions} reqExportDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportDefinitions(modelId: string, reqExportDefinitions: ReqExportDefinitions, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateExportDefinitions> {
            return localVarFp.updateExportDefinitions(modelId, reqExportDefinitions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - object-oriented interface
 */
export class ExportApi extends BaseAPI {
    /**
     * Permissions: * `compute.export.*` - __required__. * `compute.output.*` - __required__ when _outputs_ are requested.
     * @summary Compute a Grasshopper exports for given parameter values.
     * @param {string} sessionId Session ID.
     * @param {ReqExport} reqExport 
     * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public computeExports(sessionId: string, reqExport: ReqExport, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).computeExports(sessionId, reqExport, ignoreUnknownParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `cache.export.get.*` - __required__. * `cache.output.get.*` - __required__ when _outputs_ are requested.
     * @summary Get Export from cache / check if computation is done.
     * @param {string} sessionId Session ID.
     * @param {ReqExportOrCache} reqExportOrCache 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCachedExports(sessionId: string, reqExportOrCache: ReqExportOrCache, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).getCachedExports(sessionId, reqExportOrCache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `cache.export.list.*` - __required__.
     * @summary List export versions.
     * @param {string} sessionId Session ID.
     * @param {string} exportId Export ID.
     * @param {QueryComputationStatus} [statusComputation] Filter export versions by &#x60;status_computation&#x60;.
     * @param {QueryComputationStatus} [statusCollect] Filter export versions by &#x60;status_collect&#x60;.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listExportVersions(sessionId: string, exportId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).listExportVersions(sessionId, exportId, statusComputation, statusCollect, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `set.export.ui` - __required__.
     * @summary Update definition of exports.
     * @param {string} modelId Model ID.
     * @param {ReqExportDefinitions} reqExportDefinitions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateExportDefinitions(modelId: string, reqExportDefinitions: ReqExportDefinitions, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).updateExportDefinitions(modelId, reqExportDefinitions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileApi - axios parameter creator
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions: * `asset.file.delete.*` - __required__.
         * @summary Delete a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (sessionId: string, paramId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteFile', 'sessionId', sessionId)
            // verify required parameter 'paramId' is not null or undefined
            assertParamExists('deleteFile', 'paramId', paramId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFile', 'fileId', fileId)
            const localVarPath = `/api/v2/session/{sessionId}/file/{paramId}/{fileId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"paramId"}}`, encodeURIComponent(String(paramId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `asset.file.get.*` - __required__.
         * @summary Download a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (sessionId: string, paramId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadFile', 'sessionId', sessionId)
            // verify required parameter 'paramId' is not null or undefined
            assertParamExists('downloadFile', 'paramId', paramId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadFile', 'fileId', fileId)
            const localVarPath = `/api/v2/session/{sessionId}/file/{paramId}/{fileId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"paramId"}}`, encodeURIComponent(String(paramId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a file-asset of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMetadata: async (sessionId: string, paramId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getFileMetadata', 'sessionId', sessionId)
            // verify required parameter 'paramId' is not null or undefined
            assertParamExists('getFileMetadata', 'paramId', paramId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileMetadata', 'fileId', fileId)
            const localVarPath = `/api/v2/session/{sessionId}/file/{paramId}/{fileId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"paramId"}}`, encodeURIComponent(String(paramId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `asset.file.list.*` - __required__.
         * @summary List all file-assets of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (sessionId: string, paramId: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listFiles', 'sessionId', sessionId)
            // verify required parameter 'paramId' is not null or undefined
            assertParamExists('listFiles', 'paramId', paramId)
            const localVarPath = `/api/v2/session/{sessionId}/file/{paramId}/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"paramId"}}`, encodeURIComponent(String(paramId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `asset.file.create.*` - __required__.
         * @summary Request upload URL for a file-asset.
         * @param {string} sessionId Session ID.
         * @param {ReqFileUpload} reqFileUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (sessionId: string, reqFileUpload: ReqFileUpload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('uploadFile', 'sessionId', sessionId)
            // verify required parameter 'reqFileUpload' is not null or undefined
            assertParamExists('uploadFile', 'reqFileUpload', reqFileUpload)
            const localVarPath = `/api/v2/session/{sessionId}/file/upload`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqFileUpload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions: * `asset.file.delete.*` - __required__.
         * @summary Delete a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(sessionId, paramId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.deleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `asset.file.get.*` - __required__.
         * @summary Download a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(sessionId, paramId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about a file-asset of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileMetadata(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileMetadata(sessionId, paramId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getFileMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `asset.file.list.*` - __required__.
         * @summary List all file-assets of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(sessionId: string, paramId: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListFiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(sessionId, paramId, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.listFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `asset.file.create.*` - __required__.
         * @summary Request upload URL for a file-asset.
         * @param {string} sessionId Session ID.
         * @param {ReqFileUpload} reqFileUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(sessionId: string, reqFileUpload: ReqFileUpload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUploadFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(sessionId, reqFileUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileApi - factory interface
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Permissions: * `asset.file.delete.*` - __required__.
         * @summary Delete a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteFile> {
            return localVarFp.deleteFile(sessionId, paramId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `asset.file.get.*` - __required__.
         * @summary Download a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadFile(sessionId, paramId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a file-asset of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMetadata(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFileMetadata(sessionId, paramId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `asset.file.list.*` - __required__.
         * @summary List all file-assets of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(sessionId: string, paramId: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListFiles> {
            return localVarFp.listFiles(sessionId, paramId, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `asset.file.create.*` - __required__.
         * @summary Request upload URL for a file-asset.
         * @param {string} sessionId Session ID.
         * @param {ReqFileUpload} reqFileUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(sessionId: string, reqFileUpload: ReqFileUpload, options?: RawAxiosRequestConfig): AxiosPromise<ResUploadFile> {
            return localVarFp.uploadFile(sessionId, reqFileUpload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 */
export class FileApi extends BaseAPI {
    /**
     * Permissions: * `asset.file.delete.*` - __required__.
     * @summary Delete a file-asset.
     * @param {string} sessionId Session ID.
     * @param {string} paramId Parameter ID of the file asset.
     * @param {string} fileId ID of the file asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).deleteFile(sessionId, paramId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `asset.file.get.*` - __required__.
     * @summary Download a file-asset.
     * @param {string} sessionId Session ID.
     * @param {string} paramId Parameter ID of the file asset.
     * @param {string} fileId ID of the file asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).downloadFile(sessionId, paramId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a file-asset of a parameter.
     * @param {string} sessionId Session ID.
     * @param {string} paramId Parameter ID of the file asset.
     * @param {string} fileId ID of the file asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFileMetadata(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getFileMetadata(sessionId, paramId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `asset.file.list.*` - __required__.
     * @summary List all file-assets of a parameter.
     * @param {string} sessionId Session ID.
     * @param {string} paramId Parameter ID of the file asset.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFiles(sessionId: string, paramId: string, offset?: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).listFiles(sessionId, paramId, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `asset.file.create.*` - __required__.
     * @summary Request upload URL for a file-asset.
     * @param {string} sessionId Session ID.
     * @param {ReqFileUpload} reqFileUpload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadFile(sessionId: string, reqFileUpload: ReqFileUpload, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).uploadFile(sessionId, reqFileUpload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GltfApi - axios parameter creator
 */
export const GltfApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload and optionally convert a glTF object.
         * @param {string} sessionId Session ID.
         * @param {File} body 
         * @param {QueryGltfConversion} [conversion] Specify to convert the uploaded glTF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGltf: async (sessionId: string, body: File, conversion?: QueryGltfConversion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('uploadGltf', 'sessionId', sessionId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadGltf', 'body', body)
            const localVarPath = `/api/v2/session/{sessionId}/gltf`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (conversion !== undefined) {
                localVarQueryParameter['conversion'] = conversion;
            }

            localVarHeaderParameter['Content-Type'] = 'model/gltf-binary';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GltfApi - functional programming interface
 */
export const GltfApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GltfApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload and optionally convert a glTF object.
         * @param {string} sessionId Session ID.
         * @param {File} body 
         * @param {QueryGltfConversion} [conversion] Specify to convert the uploaded glTF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadGltf(sessionId: string, body: File, conversion?: QueryGltfConversion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUploadGltf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadGltf(sessionId, body, conversion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GltfApi.uploadGltf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GltfApi - factory interface
 */
export const GltfApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GltfApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload and optionally convert a glTF object.
         * @param {string} sessionId Session ID.
         * @param {File} body 
         * @param {QueryGltfConversion} [conversion] Specify to convert the uploaded glTF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGltf(sessionId: string, body: File, conversion?: QueryGltfConversion, options?: RawAxiosRequestConfig): AxiosPromise<ResUploadGltf> {
            return localVarFp.uploadGltf(sessionId, body, conversion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GltfApi - object-oriented interface
 */
export class GltfApi extends BaseAPI {
    /**
     * 
     * @summary Upload and optionally convert a glTF object.
     * @param {string} sessionId Session ID.
     * @param {File} body 
     * @param {QueryGltfConversion} [conversion] Specify to convert the uploaded glTF.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadGltf(sessionId: string, body: File, conversion?: QueryGltfConversion, options?: RawAxiosRequestConfig) {
        return GltfApiFp(this.configuration).uploadGltf(sessionId, body, conversion, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogApi - axios parameter creator
 */
export const LogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Log message.
         * @param {string} sessionId Session ID.
         * @param {ReqLogMessage} reqLogMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logMessage: async (sessionId: string, reqLogMessage: ReqLogMessage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('logMessage', 'sessionId', sessionId)
            // verify required parameter 'reqLogMessage' is not null or undefined
            assertParamExists('logMessage', 'reqLogMessage', reqLogMessage)
            const localVarPath = `/api/v2/session/{sessionId}/log/message`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqLogMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogApi - functional programming interface
 */
export const LogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Log message.
         * @param {string} sessionId Session ID.
         * @param {ReqLogMessage} reqLogMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logMessage(sessionId: string, reqLogMessage: ReqLogMessage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResLogMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logMessage(sessionId, reqLogMessage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogApi.logMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogApi - factory interface
 */
export const LogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogApiFp(configuration)
    return {
        /**
         * 
         * @summary Log message.
         * @param {string} sessionId Session ID.
         * @param {ReqLogMessage} reqLogMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logMessage(sessionId: string, reqLogMessage: ReqLogMessage, options?: RawAxiosRequestConfig): AxiosPromise<ResLogMessage> {
            return localVarFp.logMessage(sessionId, reqLogMessage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogApi - object-oriented interface
 */
export class LogApi extends BaseAPI {
    /**
     * 
     * @summary Log message.
     * @param {string} sessionId Session ID.
     * @param {ReqLogMessage} reqLogMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logMessage(sessionId: string, reqLogMessage: ReqLogMessage, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logMessage(sessionId, reqLogMessage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelApi - axios parameter creator
 */
export const ModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions: * `cache.export.delete.*` - __required__.
         * @summary Delete old export components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupExports: async (modelId: string, untilLastSeen: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('cleanupExports', 'modelId', modelId)
            // verify required parameter 'untilLastSeen' is not null or undefined
            assertParamExists('cleanupExports', 'untilLastSeen', untilLastSeen)
            const localVarPath = `/api/v2/model/{modelId}/cleanup/export`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (untilLastSeen !== undefined) {
                localVarQueryParameter['untilLastSeen'] = untilLastSeen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `cache.output.delete.*` - __required__.
         * @summary Delete old output components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupOutputs: async (modelId: string, untilLastSeen: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('cleanupOutputs', 'modelId', modelId)
            // verify required parameter 'untilLastSeen' is not null or undefined
            assertParamExists('cleanupOutputs', 'untilLastSeen', untilLastSeen)
            const localVarPath = `/api/v2/model/{modelId}/cleanup/output`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (untilLastSeen !== undefined) {
                localVarQueryParameter['untilLastSeen'] = untilLastSeen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `cache.texture.delete.*` - __required__.
         * @summary Delete old texture components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupTextures: async (modelId: string, untilLastSeen: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('cleanupTextures', 'modelId', modelId)
            // verify required parameter 'untilLastSeen' is not null or undefined
            assertParamExists('cleanupTextures', 'untilLastSeen', untilLastSeen)
            const localVarPath = `/api/v2/model/{modelId}/cleanup/texture`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (untilLastSeen !== undefined) {
                localVarQueryParameter['untilLastSeen'] = untilLastSeen;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `create` - __required__ * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response if no model has already been   uploaded. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create model.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModel: async (reqModel: ReqModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqModel' is not null or undefined
            assertParamExists('createModel', 'reqModel', reqModel)
            const localVarPath = `/api/v2/model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `setting.viewer.set.*` - __required__.
         * @summary Create model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelConfig: async (modelId: string, reqConfigure: ReqConfigure, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('createModelConfig', 'modelId', modelId)
            // verify required parameter 'reqConfigure' is not null or undefined
            assertParamExists('createModelConfig', 'reqConfigure', reqConfigure)
            const localVarPath = `/api/v2/model/{modelId}/config`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqConfigure, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `delete.soft` - __required__.
         * @summary Delete model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('deleteModel', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `file.download` - __required__.
         * @summary Download Grasshopper file.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadModelFile: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('downloadModelFile', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/file/download`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of all running model cleanup processes.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCleanupStatus: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getCleanupStatus', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/cleanup/status`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_. * `setting.compute.get.*` - optional: adds _settings.compute_. * `file.upload` - optional: adds _file.upload_. * `file.download` - optional: adds _file.download_. * `get.statistic.*` - optional: adds _statistic_. * `setting.viewer.get.*` - optional: adds _viewer_. * `get.parameter.*` - optional: adds _parameters_. * `get.output*` - optional: adds _output definitions_. * `get.export*` - optional: adds _export definitions_.
         * @summary Get model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getModel', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model computation statistics.
         * @param {string} modelId Model ID.
         * @param {QueryOrder} [order] Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60;
         * @param {string} [timestampFrom] Timestamp to query from.  _Default:_ &#x60;0&#x60;
         * @param {string} [timestampTo] Timestamp to query to.  _Default:_ &#x60;infinity&#x60;
         * @param {QueryComputationStatisticsStatus} [status] Filter computations by the result status.  _Default:_ &#x60;*&#x60;
         * @param {QueryComputationType} [type] Filter computations by type.  _Default:_ &#x60;*&#x60;
         * @param {number} [limit] How many items to return at most.  _Default:_ &#x60;100&#x60;
         * @param {boolean} [strictLimit] Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60;
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelComputations: async (modelId: string, order?: QueryOrder, timestampFrom?: string, timestampTo?: string, status?: QueryComputationStatisticsStatus, type?: QueryComputationType, limit?: number, strictLimit?: boolean, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getModelComputations', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/computations`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (timestampFrom !== undefined) {
                localVarQueryParameter['timestamp_from'] = timestampFrom;
            }

            if (timestampTo !== undefined) {
                localVarQueryParameter['timestamp_to'] = timestampTo;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (strictLimit !== undefined) {
                localVarQueryParameter['strict_limit'] = strictLimit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `setting.viewer.get.*` - __required__.
         * @summary Get model config.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelConfig: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getModelConfig', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/config`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List models.
         * @param {QueryModelStatus} [modelStatus] Filter models by &#x60;stat&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (modelStatus?: QueryModelStatus, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/model/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (modelStatus !== undefined) {
                localVarQueryParameter['modelStatus'] = modelStatus;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Restore a soft-deleted model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('restoreModel', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/restore`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Update model.
         * @param {string} modelId Model ID.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel: async (modelId: string, reqModel: ReqModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateModel', 'modelId', modelId)
            // verify required parameter 'reqModel' is not null or undefined
            assertParamExists('updateModel', 'reqModel', reqModel)
            const localVarPath = `/api/v2/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating the model configuration requires _model authoring privilege_.  Permissions: * `setting.viewer.set.*` - __required__.
         * @summary Update model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModelConfig: async (modelId: string, reqConfigure: ReqConfigure, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateModelConfig', 'modelId', modelId)
            // verify required parameter 'reqConfigure' is not null or undefined
            assertParamExists('updateModelConfig', 'reqConfigure', reqConfigure)
            const localVarPath = `/api/v2/model/{modelId}/config`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqConfigure, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating default parameter values requires model authoring privilege.  Permissions: * `set.parameter.defval` - __required__.
         * @summary Update default value of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameterDefaultValues: async (modelId: string, reqCustomization: ReqCustomization, ignoreUnknownParams?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateParameterDefaultValues', 'modelId', modelId)
            // verify required parameter 'reqCustomization' is not null or undefined
            assertParamExists('updateParameterDefaultValues', 'reqCustomization', reqCustomization)
            const localVarPath = `/api/v2/model/{modelId}/parameter/defval`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ignoreUnknownParams !== undefined) {
                localVarQueryParameter['ignoreUnknownParams'] = ignoreUnknownParams;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCustomization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `set.parameter.ui` - __required__.
         * @summary Update definition of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqParameterDefinitions} reqParameterDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameterDefinitions: async (modelId: string, reqParameterDefinitions: ReqParameterDefinitions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateParameterDefinitions', 'modelId', modelId)
            // verify required parameter 'reqParameterDefinitions' is not null or undefined
            assertParamExists('updateParameterDefinitions', 'reqParameterDefinitions', reqParameterDefinitions)
            const localVarPath = `/api/v2/model/{modelId}/parameter`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqParameterDefinitions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelApi - functional programming interface
 */
export const ModelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions: * `cache.export.delete.*` - __required__.
         * @summary Delete old export components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupExports(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCleanupExports>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupExports(modelId, untilLastSeen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.cleanupExports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `cache.output.delete.*` - __required__.
         * @summary Delete old output components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupOutputs(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCleanupOutputs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupOutputs(modelId, untilLastSeen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.cleanupOutputs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `cache.texture.delete.*` - __required__.
         * @summary Delete old texture components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupTextures(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCleanupTextures>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupTextures(modelId, untilLastSeen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.cleanupTextures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `create` - __required__ * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response if no model has already been   uploaded. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create model.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModel(reqModel: ReqModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModel(reqModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.createModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `setting.viewer.set.*` - __required__.
         * @summary Create model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateModelConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModelConfig(modelId, reqConfigure, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.createModelConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `delete.soft` - __required__.
         * @summary Delete model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.deleteModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `file.download` - __required__.
         * @summary Download Grasshopper file.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadModelFile(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadModelFile(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.downloadModelFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the status of all running model cleanup processes.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCleanupStatus(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetCleanupStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCleanupStatus(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.getCleanupStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_. * `setting.compute.get.*` - optional: adds _settings.compute_. * `file.upload` - optional: adds _file.upload_. * `file.download` - optional: adds _file.download_. * `get.statistic.*` - optional: adds _statistic_. * `setting.viewer.get.*` - optional: adds _viewer_. * `get.parameter.*` - optional: adds _parameters_. * `get.output*` - optional: adds _output definitions_. * `get.export*` - optional: adds _export definitions_.
         * @summary Get model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.getModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model computation statistics.
         * @param {string} modelId Model ID.
         * @param {QueryOrder} [order] Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60;
         * @param {string} [timestampFrom] Timestamp to query from.  _Default:_ &#x60;0&#x60;
         * @param {string} [timestampTo] Timestamp to query to.  _Default:_ &#x60;infinity&#x60;
         * @param {QueryComputationStatisticsStatus} [status] Filter computations by the result status.  _Default:_ &#x60;*&#x60;
         * @param {QueryComputationType} [type] Filter computations by type.  _Default:_ &#x60;*&#x60;
         * @param {number} [limit] How many items to return at most.  _Default:_ &#x60;100&#x60;
         * @param {boolean} [strictLimit] Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60;
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelComputations(modelId: string, order?: QueryOrder, timestampFrom?: string, timestampTo?: string, status?: QueryComputationStatisticsStatus, type?: QueryComputationType, limit?: number, strictLimit?: boolean, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelComputations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelComputations(modelId, order, timestampFrom, timestampTo, status, type, limit, strictLimit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.getModelComputations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `setting.viewer.get.*` - __required__.
         * @summary Get model config.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelConfig(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelConfig(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.getModelConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List models.
         * @param {QueryModelStatus} [modelStatus] Filter models by &#x60;stat&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(modelStatus?: QueryModelStatus, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListModels>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(modelStatus, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.listModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Restore a soft-deleted model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.restoreModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Update model.
         * @param {string} modelId Model ID.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModel(modelId: string, reqModel: ReqModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModel(modelId, reqModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.updateModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updating the model configuration requires _model authoring privilege_.  Permissions: * `setting.viewer.set.*` - __required__.
         * @summary Update model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateModelConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModelConfig(modelId, reqConfigure, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.updateModelConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updating default parameter values requires model authoring privilege.  Permissions: * `set.parameter.defval` - __required__.
         * @summary Update default value of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateParameterDefaultValues(modelId: string, reqCustomization: ReqCustomization, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateParameterDefaultValues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateParameterDefaultValues(modelId, reqCustomization, ignoreUnknownParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.updateParameterDefaultValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `set.parameter.ui` - __required__.
         * @summary Update definition of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqParameterDefinitions} reqParameterDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateParameterDefinitions(modelId: string, reqParameterDefinitions: ReqParameterDefinitions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateParameterDefinitions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateParameterDefinitions(modelId, reqParameterDefinitions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.updateParameterDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelApi - factory interface
 */
export const ModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelApiFp(configuration)
    return {
        /**
         * Permissions: * `cache.export.delete.*` - __required__.
         * @summary Delete old export components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupExports(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): AxiosPromise<ResCleanupExports> {
            return localVarFp.cleanupExports(modelId, untilLastSeen, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `cache.output.delete.*` - __required__.
         * @summary Delete old output components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupOutputs(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): AxiosPromise<ResCleanupOutputs> {
            return localVarFp.cleanupOutputs(modelId, untilLastSeen, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `cache.texture.delete.*` - __required__.
         * @summary Delete old texture components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupTextures(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): AxiosPromise<ResCleanupTextures> {
            return localVarFp.cleanupTextures(modelId, untilLastSeen, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `create` - __required__ * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response if no model has already been   uploaded. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create model.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModel(reqModel: ReqModel, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateModel> {
            return localVarFp.createModel(reqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `setting.viewer.set.*` - __required__.
         * @summary Create model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateModelConfig> {
            return localVarFp.createModelConfig(modelId, reqConfigure, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `delete.soft` - __required__.
         * @summary Delete model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteModel> {
            return localVarFp.deleteModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `file.download` - __required__.
         * @summary Download Grasshopper file.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadModelFile(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadModelFile(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of all running model cleanup processes.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCleanupStatus(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetCleanupStatus> {
            return localVarFp.getCleanupStatus(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_. * `setting.compute.get.*` - optional: adds _settings.compute_. * `file.upload` - optional: adds _file.upload_. * `file.download` - optional: adds _file.download_. * `get.statistic.*` - optional: adds _statistic_. * `setting.viewer.get.*` - optional: adds _viewer_. * `get.parameter.*` - optional: adds _parameters_. * `get.output*` - optional: adds _output definitions_. * `get.export*` - optional: adds _export definitions_.
         * @summary Get model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModel> {
            return localVarFp.getModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `analytics.model.get.*` - __required__.
         * @summary Get model computation statistics.
         * @param {string} modelId Model ID.
         * @param {QueryOrder} [order] Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60;
         * @param {string} [timestampFrom] Timestamp to query from.  _Default:_ &#x60;0&#x60;
         * @param {string} [timestampTo] Timestamp to query to.  _Default:_ &#x60;infinity&#x60;
         * @param {QueryComputationStatisticsStatus} [status] Filter computations by the result status.  _Default:_ &#x60;*&#x60;
         * @param {QueryComputationType} [type] Filter computations by type.  _Default:_ &#x60;*&#x60;
         * @param {number} [limit] How many items to return at most.  _Default:_ &#x60;100&#x60;
         * @param {boolean} [strictLimit] Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60;
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelComputations(modelId: string, order?: QueryOrder, timestampFrom?: string, timestampTo?: string, status?: QueryComputationStatisticsStatus, type?: QueryComputationType, limit?: number, strictLimit?: boolean, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelComputations> {
            return localVarFp.getModelComputations(modelId, order, timestampFrom, timestampTo, status, type, limit, strictLimit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `setting.viewer.get.*` - __required__.
         * @summary Get model config.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelConfig(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelConfig> {
            return localVarFp.getModelConfig(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List models.
         * @param {QueryModelStatus} [modelStatus] Filter models by &#x60;stat&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(modelStatus?: QueryModelStatus, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListModels> {
            return localVarFp.listModels(modelStatus, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Restore a soft-deleted model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteModel> {
            return localVarFp.restoreModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Update model.
         * @param {string} modelId Model ID.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel(modelId: string, reqModel: ReqModel, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateModel> {
            return localVarFp.updateModel(modelId, reqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating the model configuration requires _model authoring privilege_.  Permissions: * `setting.viewer.set.*` - __required__.
         * @summary Update model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateModelConfig> {
            return localVarFp.updateModelConfig(modelId, reqConfigure, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating default parameter values requires model authoring privilege.  Permissions: * `set.parameter.defval` - __required__.
         * @summary Update default value of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameterDefaultValues(modelId: string, reqCustomization: ReqCustomization, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateParameterDefaultValues> {
            return localVarFp.updateParameterDefaultValues(modelId, reqCustomization, ignoreUnknownParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `set.parameter.ui` - __required__.
         * @summary Update definition of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqParameterDefinitions} reqParameterDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameterDefinitions(modelId: string, reqParameterDefinitions: ReqParameterDefinitions, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateParameterDefinitions> {
            return localVarFp.updateParameterDefinitions(modelId, reqParameterDefinitions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelApi - object-oriented interface
 */
export class ModelApi extends BaseAPI {
    /**
     * Permissions: * `cache.export.delete.*` - __required__.
     * @summary Delete old export components.
     * @param {string} modelId Model ID.
     * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cleanupExports(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).cleanupExports(modelId, untilLastSeen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `cache.output.delete.*` - __required__.
     * @summary Delete old output components.
     * @param {string} modelId Model ID.
     * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cleanupOutputs(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).cleanupOutputs(modelId, untilLastSeen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `cache.texture.delete.*` - __required__.
     * @summary Delete old texture components.
     * @param {string} modelId Model ID.
     * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cleanupTextures(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).cleanupTextures(modelId, untilLastSeen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions: * `create` - __required__ * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response if no model has already been   uploaded. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
     * @summary Create model.
     * @param {ReqModel} reqModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createModel(reqModel: ReqModel, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).createModel(reqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `setting.viewer.set.*` - __required__.
     * @summary Create model config.
     * @param {string} modelId Model ID.
     * @param {ReqConfigure} reqConfigure 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).createModelConfig(modelId, reqConfigure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions: * `delete.soft` - __required__.
     * @summary Delete model.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteModel(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).deleteModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `file.download` - __required__.
     * @summary Download Grasshopper file.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadModelFile(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).downloadModelFile(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of all running model cleanup processes.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCleanupStatus(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).getCleanupStatus(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_. * `setting.compute.get.*` - optional: adds _settings.compute_. * `file.upload` - optional: adds _file.upload_. * `file.download` - optional: adds _file.download_. * `get.statistic.*` - optional: adds _statistic_. * `setting.viewer.get.*` - optional: adds _viewer_. * `get.parameter.*` - optional: adds _parameters_. * `get.output*` - optional: adds _output definitions_. * `get.export*` - optional: adds _export definitions_.
     * @summary Get model.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModel(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).getModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `analytics.model.get.*` - __required__.
     * @summary Get model computation statistics.
     * @param {string} modelId Model ID.
     * @param {QueryOrder} [order] Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60;
     * @param {string} [timestampFrom] Timestamp to query from.  _Default:_ &#x60;0&#x60;
     * @param {string} [timestampTo] Timestamp to query to.  _Default:_ &#x60;infinity&#x60;
     * @param {QueryComputationStatisticsStatus} [status] Filter computations by the result status.  _Default:_ &#x60;*&#x60;
     * @param {QueryComputationType} [type] Filter computations by type.  _Default:_ &#x60;*&#x60;
     * @param {number} [limit] How many items to return at most.  _Default:_ &#x60;100&#x60;
     * @param {boolean} [strictLimit] Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60;
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelComputations(modelId: string, order?: QueryOrder, timestampFrom?: string, timestampTo?: string, status?: QueryComputationStatisticsStatus, type?: QueryComputationType, limit?: number, strictLimit?: boolean, offset?: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).getModelComputations(modelId, order, timestampFrom, timestampTo, status, type, limit, strictLimit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `setting.viewer.get.*` - __required__.
     * @summary Get model config.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelConfig(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).getModelConfig(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary List models.
     * @param {QueryModelStatus} [modelStatus] Filter models by &#x60;stat&#x60;.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listModels(modelStatus?: QueryModelStatus, offset?: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).listModels(modelStatus, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary Restore a soft-deleted model.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreModel(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).restoreModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
     * @summary Update model.
     * @param {string} modelId Model ID.
     * @param {ReqModel} reqModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateModel(modelId: string, reqModel: ReqModel, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).updateModel(modelId, reqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating the model configuration requires _model authoring privilege_.  Permissions: * `setting.viewer.set.*` - __required__.
     * @summary Update model config.
     * @param {string} modelId Model ID.
     * @param {ReqConfigure} reqConfigure 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).updateModelConfig(modelId, reqConfigure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating default parameter values requires model authoring privilege.  Permissions: * `set.parameter.defval` - __required__.
     * @summary Update default value of parameters.
     * @param {string} modelId Model ID.
     * @param {ReqCustomization} reqCustomization 
     * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateParameterDefaultValues(modelId: string, reqCustomization: ReqCustomization, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).updateParameterDefaultValues(modelId, reqCustomization, ignoreUnknownParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `set.parameter.ui` - __required__.
     * @summary Update definition of parameters.
     * @param {string} modelId Model ID.
     * @param {ReqParameterDefinitions} reqParameterDefinitions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateParameterDefinitions(modelId: string, reqParameterDefinitions: ReqParameterDefinitions, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).updateParameterDefinitions(modelId, reqParameterDefinitions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelStateApi - axios parameter creator
 */
export const ModelStateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Model-State.
         * @param {string} sessionId Session ID.
         * @param {ReqModelState} reqModelState 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelState: async (sessionId: string, reqModelState: ReqModelState, ignoreUnknownParams?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('createModelState', 'sessionId', sessionId)
            // verify required parameter 'reqModelState' is not null or undefined
            assertParamExists('createModelState', 'reqModelState', reqModelState)
            const localVarPath = `/api/v2/session/{sessionId}/model-state`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ignoreUnknownParams !== undefined) {
                localVarQueryParameter['ignoreUnknownParams'] = ignoreUnknownParams;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqModelState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Delete a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelState: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('deleteModelState', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads the Model-State image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadModelStateImage: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('downloadModelStateImage', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}/image`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelState: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('getModelState', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Model-State\'s parameter and additional data.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateData: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('getModelStateData', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}/data`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the Model-State has an image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateImageMetadata: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('getModelStateImageMetadata', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}/image`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks the existence of a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateMetadata: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('getModelStateMetadata', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List Model-States of a ShapeDiver model.
         * @param {string} modelId Model ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelStates: async (modelId: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('listModelStates', 'modelId', modelId)
            const localVarPath = `/api/v2/model-state/model/{modelId}/list`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelStateApi - functional programming interface
 */
export const ModelStateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelStateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Model-State.
         * @param {string} sessionId Session ID.
         * @param {ReqModelState} reqModelState 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModelState(sessionId: string, reqModelState: ReqModelState, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateModelState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModelState(sessionId, reqModelState, ignoreUnknownParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.createModelState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Delete a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModelState(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteModelState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModelState(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.deleteModelState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Downloads the Model-State image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadModelStateImage(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadModelStateImage(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.downloadModelStateImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelState(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelState(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.getModelState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a Model-State\'s parameter and additional data.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelStateData(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelStateData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelStateData(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.getModelStateData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the Model-State has an image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelStateImageMetadata(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelStateImageMetadata(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.getModelStateImageMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Checks the existence of a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelStateMetadata(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelStateMetadata(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.getModelStateMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List Model-States of a ShapeDiver model.
         * @param {string} modelId Model ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModelStates(modelId: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListModelStates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModelStates(modelId, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.listModelStates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelStateApi - factory interface
 */
export const ModelStateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelStateApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Model-State.
         * @param {string} sessionId Session ID.
         * @param {ReqModelState} reqModelState 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelState(sessionId: string, reqModelState: ReqModelState, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateModelState> {
            return localVarFp.createModelState(sessionId, reqModelState, ignoreUnknownParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Delete a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelState(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteModelState> {
            return localVarFp.deleteModelState(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads the Model-State image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadModelStateImage(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadModelStateImage(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelState(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelState> {
            return localVarFp.getModelState(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Model-State\'s parameter and additional data.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateData(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelStateData> {
            return localVarFp.getModelStateData(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the Model-State has an image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateImageMetadata(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getModelStateImageMetadata(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks the existence of a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateMetadata(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getModelStateMetadata(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List Model-States of a ShapeDiver model.
         * @param {string} modelId Model ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelStates(modelId: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListModelStates> {
            return localVarFp.listModelStates(modelId, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelStateApi - object-oriented interface
 */
export class ModelStateApi extends BaseAPI {
    /**
     * 
     * @summary Create new Model-State.
     * @param {string} sessionId Session ID.
     * @param {ReqModelState} reqModelState 
     * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createModelState(sessionId: string, reqModelState: ReqModelState, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).createModelState(sessionId, reqModelState, ignoreUnknownParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary Delete a Model-State.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteModelState(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).deleteModelState(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads the Model-State image.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadModelStateImage(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).downloadModelStateImage(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Model-State.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelState(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).getModelState(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Model-State\'s parameter and additional data.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelStateData(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).getModelStateData(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the Model-State has an image.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelStateImageMetadata(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).getModelStateImageMetadata(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks the existence of a Model-State.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getModelStateMetadata(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).getModelStateMetadata(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary List Model-States of a ShapeDiver model.
     * @param {string} modelId Model ID.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listModelStates(modelId: string, offset?: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).listModelStates(modelId, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OutputApi - axios parameter creator
 */
export const OutputApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions: * `compute.output.*` - __required__.
         * @summary Compute all outputs for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeOutputs: async (sessionId: string, reqCustomization: ReqCustomization, ignoreUnknownParams?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('computeOutputs', 'sessionId', sessionId)
            // verify required parameter 'reqCustomization' is not null or undefined
            assertParamExists('computeOutputs', 'reqCustomization', reqCustomization)
            const localVarPath = `/api/v2/session/{sessionId}/output`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ignoreUnknownParams !== undefined) {
                localVarQueryParameter['ignoreUnknownParams'] = ignoreUnknownParams;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCustomization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `cache.output.get.*` - __required__.
         * @summary Get output from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqCache | ReqCustomization} reqCacheReqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedOutputs: async (sessionId: string, reqCacheReqCustomization: ReqCache | ReqCustomization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getCachedOutputs', 'sessionId', sessionId)
            // verify required parameter 'reqCacheReqCustomization' is not null or undefined
            assertParamExists('getCachedOutputs', 'reqCacheReqCustomization', reqCacheReqCustomization)
            const localVarPath = `/api/v2/session/{sessionId}/output/cache`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCacheReqCustomization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `cache.output.list.*` - __required__.
         * @summary List output versions.
         * @param {string} sessionId Session ID.
         * @param {string} outputId Output ID.
         * @param {QueryComputationStatus} [statusComputation] Filter output versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter output versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutputVersions: async (sessionId: string, outputId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listOutputVersions', 'sessionId', sessionId)
            // verify required parameter 'outputId' is not null or undefined
            assertParamExists('listOutputVersions', 'outputId', outputId)
            const localVarPath = `/api/v2/session/{sessionId}/output/{outputId}/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"outputId"}}`, encodeURIComponent(String(outputId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (statusComputation !== undefined) {
                localVarQueryParameter['statusComputation'] = statusComputation;
            }

            if (statusCollect !== undefined) {
                localVarQueryParameter['statusCollect'] = statusCollect;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `set.output.ui` - __required__.
         * @summary Update definition of outputs.
         * @param {string} modelId Model ID.
         * @param {ReqOutputDefinitions} reqOutputDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOutputDefinitions: async (modelId: string, reqOutputDefinitions: ReqOutputDefinitions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateOutputDefinitions', 'modelId', modelId)
            // verify required parameter 'reqOutputDefinitions' is not null or undefined
            assertParamExists('updateOutputDefinitions', 'reqOutputDefinitions', reqOutputDefinitions)
            const localVarPath = `/api/v2/model/{modelId}/output`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqOutputDefinitions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OutputApi - functional programming interface
 */
export const OutputApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OutputApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions: * `compute.output.*` - __required__.
         * @summary Compute all outputs for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeOutputs(sessionId: string, reqCustomization: ReqCustomization, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResComputeOutputs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeOutputs(sessionId, reqCustomization, ignoreUnknownParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputApi.computeOutputs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `cache.output.get.*` - __required__.
         * @summary Get output from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqCache | ReqCustomization} reqCacheReqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCachedOutputs(sessionId: string, reqCacheReqCustomization: ReqCache | ReqCustomization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetCachedOutputs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCachedOutputs(sessionId, reqCacheReqCustomization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputApi.getCachedOutputs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `cache.output.list.*` - __required__.
         * @summary List output versions.
         * @param {string} sessionId Session ID.
         * @param {string} outputId Output ID.
         * @param {QueryComputationStatus} [statusComputation] Filter output versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter output versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOutputVersions(sessionId: string, outputId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListOutputVersions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOutputVersions(sessionId, outputId, statusComputation, statusCollect, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputApi.listOutputVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `set.output.ui` - __required__.
         * @summary Update definition of outputs.
         * @param {string} modelId Model ID.
         * @param {ReqOutputDefinitions} reqOutputDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOutputDefinitions(modelId: string, reqOutputDefinitions: ReqOutputDefinitions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateOutputDefinitions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOutputDefinitions(modelId, reqOutputDefinitions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputApi.updateOutputDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OutputApi - factory interface
 */
export const OutputApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OutputApiFp(configuration)
    return {
        /**
         * Permissions: * `compute.output.*` - __required__.
         * @summary Compute all outputs for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeOutputs(sessionId: string, reqCustomization: ReqCustomization, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ResComputeOutputs> {
            return localVarFp.computeOutputs(sessionId, reqCustomization, ignoreUnknownParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `cache.output.get.*` - __required__.
         * @summary Get output from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqCache | ReqCustomization} reqCacheReqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedOutputs(sessionId: string, reqCacheReqCustomization: ReqCache | ReqCustomization, options?: RawAxiosRequestConfig): AxiosPromise<ResGetCachedOutputs> {
            return localVarFp.getCachedOutputs(sessionId, reqCacheReqCustomization, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `cache.output.list.*` - __required__.
         * @summary List output versions.
         * @param {string} sessionId Session ID.
         * @param {string} outputId Output ID.
         * @param {QueryComputationStatus} [statusComputation] Filter output versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter output versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutputVersions(sessionId: string, outputId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListOutputVersions> {
            return localVarFp.listOutputVersions(sessionId, outputId, statusComputation, statusCollect, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `set.output.ui` - __required__.
         * @summary Update definition of outputs.
         * @param {string} modelId Model ID.
         * @param {ReqOutputDefinitions} reqOutputDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOutputDefinitions(modelId: string, reqOutputDefinitions: ReqOutputDefinitions, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateOutputDefinitions> {
            return localVarFp.updateOutputDefinitions(modelId, reqOutputDefinitions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OutputApi - object-oriented interface
 */
export class OutputApi extends BaseAPI {
    /**
     * Permissions: * `compute.output.*` - __required__.
     * @summary Compute all outputs for given parameter values.
     * @param {string} sessionId Session ID.
     * @param {ReqCustomization} reqCustomization 
     * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers. When set to &#x60;true&#x60;, unrecognized parameters will be ignored rather than causing an error.  Defaults to &#x60;false&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public computeOutputs(sessionId: string, reqCustomization: ReqCustomization, ignoreUnknownParams?: boolean, options?: RawAxiosRequestConfig) {
        return OutputApiFp(this.configuration).computeOutputs(sessionId, reqCustomization, ignoreUnknownParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `cache.output.get.*` - __required__.
     * @summary Get output from cache / check if computation is done.
     * @param {string} sessionId Session ID.
     * @param {ReqCache | ReqCustomization} reqCacheReqCustomization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCachedOutputs(sessionId: string, reqCacheReqCustomization: ReqCache | ReqCustomization, options?: RawAxiosRequestConfig) {
        return OutputApiFp(this.configuration).getCachedOutputs(sessionId, reqCacheReqCustomization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `cache.output.list.*` - __required__.
     * @summary List output versions.
     * @param {string} sessionId Session ID.
     * @param {string} outputId Output ID.
     * @param {QueryComputationStatus} [statusComputation] Filter output versions by &#x60;status_computation&#x60;.
     * @param {QueryComputationStatus} [statusCollect] Filter output versions by &#x60;status_collect&#x60;.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listOutputVersions(sessionId: string, outputId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig) {
        return OutputApiFp(this.configuration).listOutputVersions(sessionId, outputId, statusComputation, statusCollect, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `set.output.ui` - __required__.
     * @summary Update definition of outputs.
     * @param {string} modelId Model ID.
     * @param {ReqOutputDefinitions} reqOutputDefinitions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateOutputDefinitions(modelId: string, reqOutputDefinitions: ReqOutputDefinitions, options?: RawAxiosRequestConfig) {
        return OutputApiFp(this.configuration).updateOutputDefinitions(modelId, reqOutputDefinitions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScriptApi - axios parameter creator
 */
export const ScriptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions: * `script.confirm.*` - __required__.
         * @summary Confirm script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmScript: async (scriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptId' is not null or undefined
            assertParamExists('confirmScript', 'scriptId', scriptId)
            const localVarPath = `/api/v2/script/{scriptId}/confirm`
                .replace(`{${"scriptId"}}`, encodeURIComponent(String(scriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'text/html,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `script.deny.*` - __required__.
         * @summary Deny script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyScript: async (scriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptId' is not null or undefined
            assertParamExists('denyScript', 'scriptId', scriptId)
            const localVarPath = `/api/v2/script/{scriptId}/deny`
                .replace(`{${"scriptId"}}`, encodeURIComponent(String(scriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'text/html,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScriptApi - functional programming interface
 */
export const ScriptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScriptApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions: * `script.confirm.*` - __required__.
         * @summary Confirm script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmScript(scriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmScript(scriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScriptApi.confirmScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `script.deny.*` - __required__.
         * @summary Deny script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denyScript(scriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denyScript(scriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScriptApi.denyScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScriptApi - factory interface
 */
export const ScriptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScriptApiFp(configuration)
    return {
        /**
         * Permissions: * `script.confirm.*` - __required__.
         * @summary Confirm script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmScript(scriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.confirmScript(scriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `script.deny.*` - __required__.
         * @summary Deny script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyScript(scriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.denyScript(scriptId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScriptApi - object-oriented interface
 */
export class ScriptApi extends BaseAPI {
    /**
     * Permissions: * `script.confirm.*` - __required__.
     * @summary Confirm script.
     * @param {string} scriptId Script ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public confirmScript(scriptId: string, options?: RawAxiosRequestConfig) {
        return ScriptApiFp(this.configuration).confirmScript(scriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `script.deny.*` - __required__.
     * @summary Deny script.
     * @param {string} scriptId Script ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public denyScript(scriptId: string, options?: RawAxiosRequestConfig) {
        return ScriptApiFp(this.configuration).denyScript(scriptId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SdtfApi - axios parameter creator
 */
export const SdtfApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions: * `asset.sdtf.delete.*` - __required__.
         * @summary Delete a sdTF-assets.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSdtf: async (sessionId: string, namespace: string, sdtfId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteSdtf', 'sessionId', sessionId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteSdtf', 'namespace', namespace)
            // verify required parameter 'sdtfId' is not null or undefined
            assertParamExists('deleteSdtf', 'sdtfId', sdtfId)
            const localVarPath = `/api/v2/session/{sessionId}/sdtf/{namespace}/{sdtfId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"sdtfId"}}`, encodeURIComponent(String(sdtfId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `asset.sdtf.get.*` - __required__.
         * @summary Download a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSdtf: async (sessionId: string, namespace: string, sdtfId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadSdtf', 'sessionId', sessionId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('downloadSdtf', 'namespace', namespace)
            // verify required parameter 'sdtfId' is not null or undefined
            assertParamExists('downloadSdtf', 'sdtfId', sdtfId)
            const localVarPath = `/api/v2/session/{sessionId}/sdtf/{namespace}/{sdtfId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"sdtfId"}}`, encodeURIComponent(String(sdtfId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/octet-stream,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `asset.sdtf.list.*` - __required__.
         * @summary List all sdTF-assets of a namespace.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSdtfs: async (sessionId: string, namespace: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listSdtfs', 'sessionId', sessionId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listSdtfs', 'namespace', namespace)
            const localVarPath = `/api/v2/session/{sessionId}/sdtf/{namespace}/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `asset.sdtf.create.*` - __required__.
         * @summary Request upload URL for a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {Array<ReqSdtfDefinition>} reqSdtfDefinition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSdtf: async (sessionId: string, reqSdtfDefinition: Array<ReqSdtfDefinition>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('uploadSdtf', 'sessionId', sessionId)
            // verify required parameter 'reqSdtfDefinition' is not null or undefined
            assertParamExists('uploadSdtf', 'reqSdtfDefinition', reqSdtfDefinition)
            const localVarPath = `/api/v2/session/{sessionId}/sdtf/upload`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqSdtfDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SdtfApi - functional programming interface
 */
export const SdtfApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SdtfApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions: * `asset.sdtf.delete.*` - __required__.
         * @summary Delete a sdTF-assets.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteSdtf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSdtf(sessionId, namespace, sdtfId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SdtfApi.deleteSdtf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `asset.sdtf.get.*` - __required__.
         * @summary Download a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSdtf(sessionId, namespace, sdtfId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SdtfApi.downloadSdtf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `asset.sdtf.list.*` - __required__.
         * @summary List all sdTF-assets of a namespace.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSdtfs(sessionId: string, namespace: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListSdtfs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSdtfs(sessionId, namespace, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SdtfApi.listSdtfs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `asset.sdtf.create.*` - __required__.
         * @summary Request upload URL for a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {Array<ReqSdtfDefinition>} reqSdtfDefinition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSdtf(sessionId: string, reqSdtfDefinition: Array<ReqSdtfDefinition>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUploadSdtf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSdtf(sessionId, reqSdtfDefinition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SdtfApi.uploadSdtf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SdtfApi - factory interface
 */
export const SdtfApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SdtfApiFp(configuration)
    return {
        /**
         * Permissions: * `asset.sdtf.delete.*` - __required__.
         * @summary Delete a sdTF-assets.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteSdtf> {
            return localVarFp.deleteSdtf(sessionId, namespace, sdtfId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `asset.sdtf.get.*` - __required__.
         * @summary Download a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadSdtf(sessionId, namespace, sdtfId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `asset.sdtf.list.*` - __required__.
         * @summary List all sdTF-assets of a namespace.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSdtfs(sessionId: string, namespace: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListSdtfs> {
            return localVarFp.listSdtfs(sessionId, namespace, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `asset.sdtf.create.*` - __required__.
         * @summary Request upload URL for a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {Array<ReqSdtfDefinition>} reqSdtfDefinition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSdtf(sessionId: string, reqSdtfDefinition: Array<ReqSdtfDefinition>, options?: RawAxiosRequestConfig): AxiosPromise<ResUploadSdtf> {
            return localVarFp.uploadSdtf(sessionId, reqSdtfDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SdtfApi - object-oriented interface
 */
export class SdtfApi extends BaseAPI {
    /**
     * Permissions: * `asset.sdtf.delete.*` - __required__.
     * @summary Delete a sdTF-assets.
     * @param {string} sessionId Session ID.
     * @param {string} namespace Namespace of the sdTF asset.
     * @param {string} sdtfId ID of the sdTF asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig) {
        return SdtfApiFp(this.configuration).deleteSdtf(sessionId, namespace, sdtfId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `asset.sdtf.get.*` - __required__.
     * @summary Download a sdTF-asset.
     * @param {string} sessionId Session ID.
     * @param {string} namespace Namespace of the sdTF asset.
     * @param {string} sdtfId ID of the sdTF asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig) {
        return SdtfApiFp(this.configuration).downloadSdtf(sessionId, namespace, sdtfId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `asset.sdtf.list.*` - __required__.
     * @summary List all sdTF-assets of a namespace.
     * @param {string} sessionId Session ID.
     * @param {string} namespace Namespace of the sdTF asset.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSdtfs(sessionId: string, namespace: string, offset?: string, options?: RawAxiosRequestConfig) {
        return SdtfApiFp(this.configuration).listSdtfs(sessionId, namespace, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `asset.sdtf.create.*` - __required__.
     * @summary Request upload URL for a sdTF-asset.
     * @param {string} sessionId Session ID.
     * @param {Array<ReqSdtfDefinition>} reqSdtfDefinition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadSdtf(sessionId: string, reqSdtfDefinition: Array<ReqSdtfDefinition>, options?: RawAxiosRequestConfig) {
        return SdtfApiFp(this.configuration).uploadSdtf(sessionId, reqSdtfDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionApi - axios parameter creator
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Close session.
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('closeSession', 'sessionId', sessionId)
            const localVarPath = `/api/v2/session/{sessionId}/close`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `auth.session` - __required__. * `get.parameter.*` - optional: adds _parameters_ to response. * Output:   * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by model ID.
         * @param {string} modelId Model ID.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers for customization and export requests. When set to &#x60;true&#x60;, unknown parameter IDs will be ignored instead of causing an error.  Defaults to &#x60;false&#x60;.
         * @param {boolean} [strictModelStateValidation] When set to &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model - either because the parameter ID is unknown or the parameter value is invalid - will be ignored. When set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionByModel: async (modelId: string, modelStateId?: string, ignoreUnknownParams?: boolean, strictModelStateValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('createSessionByModel', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/session`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (modelStateId !== undefined) {
                localVarQueryParameter['modelStateId'] = modelStateId;
            }

            if (ignoreUnknownParams !== undefined) {
                localVarQueryParameter['ignoreUnknownParams'] = ignoreUnknownParams;
            }

            if (strictModelStateValidation !== undefined) {
                localVarQueryParameter['strictModelStateValidation'] = strictModelStateValidation;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCustomizationOrExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `get.parameter.*` - optional: adds _parameters_ to response. * Output:   * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by ticket.
         * @param {string} ticketId Encrypted ticket.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers for customization and export requests. When set to &#x60;true&#x60;, unknown parameter IDs will be ignored instead of causing an error.  Defaults to &#x60;false&#x60;.
         * @param {boolean} [strictModelStateValidation] When set to &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model - either because the parameter ID is unknown or the parameter value is invalid - will be ignored. When set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionByTicket: async (ticketId: string, modelStateId?: string, ignoreUnknownParams?: boolean, strictModelStateValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('createSessionByTicket', 'ticketId', ticketId)
            const localVarPath = `/api/v2/ticket/{ticketId}`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (modelStateId !== undefined) {
                localVarQueryParameter['modelStateId'] = modelStateId;
            }

            if (ignoreUnknownParams !== undefined) {
                localVarQueryParameter['ignoreUnknownParams'] = ignoreUnknownParams;
            }

            if (strictModelStateValidation !== undefined) {
                localVarQueryParameter['strictModelStateValidation'] = strictModelStateValidation;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCustomizationOrExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `setting.auth.ticket.create.*` - __required__. * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create a new ticket that allows to initialize a new session.
         * @param {string} modelId Model ID.
         * @param {ReqTicket} reqTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (modelId: string, reqTicket: ReqTicket, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('createTicket', 'modelId', modelId)
            // verify required parameter 'reqTicket' is not null or undefined
            assertParamExists('createTicket', 'reqTicket', reqTicket)
            const localVarPath = `/api/v2/model/{modelId}/ticket`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqTicket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `setting.auth.ticket.decrypt.*` - __required__.
         * @summary Decrypt the given ticket and return its details.
         * @param {string} ticketEncrypted Encrypted ShapeDiver ticket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decryptTicket: async (ticketEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketEncrypted' is not null or undefined
            assertParamExists('decryptTicket', 'ticketEncrypted', ticketEncrypted)
            const localVarPath = `/api/v2/ticket/{ticketEncrypted}`
                .replace(`{${"ticketEncrypted"}}`, encodeURIComponent(String(ticketEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions: * `get.parameter.*` - optional: adds _parameter defaults_ to response. * `get.export.*` - optional: adds _export definitions_ to response. * `compute.output.*` - optional: adds _outputs for default parameters_ to response. * `get.output.*` - optional: adds _output definitions_ to response.
         * @summary Get session defaults (corresponds to the content of the session initialization request).
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionDefaults: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSessionDefaults', 'sessionId', sessionId)
            const localVarPath = `/api/v2/session/{sessionId}/default`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Close session.
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCloseSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.closeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `auth.session` - __required__. * `get.parameter.*` - optional: adds _parameters_ to response. * Output:   * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by model ID.
         * @param {string} modelId Model ID.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers for customization and export requests. When set to &#x60;true&#x60;, unknown parameter IDs will be ignored instead of causing an error.  Defaults to &#x60;false&#x60;.
         * @param {boolean} [strictModelStateValidation] When set to &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model - either because the parameter ID is unknown or the parameter value is invalid - will be ignored. When set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSessionByModel(modelId: string, modelStateId?: string, ignoreUnknownParams?: boolean, strictModelStateValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateSessionByModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSessionByModel(modelId, modelStateId, ignoreUnknownParams, strictModelStateValidation, reqCustomizationOrExport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.createSessionByModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `get.parameter.*` - optional: adds _parameters_ to response. * Output:   * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by ticket.
         * @param {string} ticketId Encrypted ticket.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers for customization and export requests. When set to &#x60;true&#x60;, unknown parameter IDs will be ignored instead of causing an error.  Defaults to &#x60;false&#x60;.
         * @param {boolean} [strictModelStateValidation] When set to &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model - either because the parameter ID is unknown or the parameter value is invalid - will be ignored. When set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSessionByTicket(ticketId: string, modelStateId?: string, ignoreUnknownParams?: boolean, strictModelStateValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateSessionByTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSessionByTicket(ticketId, modelStateId, ignoreUnknownParams, strictModelStateValidation, reqCustomizationOrExport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.createSessionByTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `setting.auth.ticket.create.*` - __required__. * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create a new ticket that allows to initialize a new session.
         * @param {string} modelId Model ID.
         * @param {ReqTicket} reqTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(modelId: string, reqTicket: ReqTicket, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(modelId, reqTicket, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.createTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `setting.auth.ticket.decrypt.*` - __required__.
         * @summary Decrypt the given ticket and return its details.
         * @param {string} ticketEncrypted Encrypted ShapeDiver ticket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decryptTicket(ticketEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDecryptTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decryptTicket(ticketEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.decryptTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions: * `get.parameter.*` - optional: adds _parameter defaults_ to response. * `get.export.*` - optional: adds _export definitions_ to response. * `compute.output.*` - optional: adds _outputs for default parameters_ to response. * `get.output.*` - optional: adds _output definitions_ to response.
         * @summary Get session defaults (corresponds to the content of the session initialization request).
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionDefaults(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetSessionDefaults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionDefaults(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.getSessionDefaults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary Close session.
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeSession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResCloseSession> {
            return localVarFp.closeSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `auth.session` - __required__. * `get.parameter.*` - optional: adds _parameters_ to response. * Output:   * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by model ID.
         * @param {string} modelId Model ID.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers for customization and export requests. When set to &#x60;true&#x60;, unknown parameter IDs will be ignored instead of causing an error.  Defaults to &#x60;false&#x60;.
         * @param {boolean} [strictModelStateValidation] When set to &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model - either because the parameter ID is unknown or the parameter value is invalid - will be ignored. When set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionByModel(modelId: string, modelStateId?: string, ignoreUnknownParams?: boolean, strictModelStateValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateSessionByModel> {
            return localVarFp.createSessionByModel(modelId, modelStateId, ignoreUnknownParams, strictModelStateValidation, reqCustomizationOrExport, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `get.parameter.*` - optional: adds _parameters_ to response. * Output:   * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by ticket.
         * @param {string} ticketId Encrypted ticket.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers for customization and export requests. When set to &#x60;true&#x60;, unknown parameter IDs will be ignored instead of causing an error.  Defaults to &#x60;false&#x60;.
         * @param {boolean} [strictModelStateValidation] When set to &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model - either because the parameter ID is unknown or the parameter value is invalid - will be ignored. When set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionByTicket(ticketId: string, modelStateId?: string, ignoreUnknownParams?: boolean, strictModelStateValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateSessionByTicket> {
            return localVarFp.createSessionByTicket(ticketId, modelStateId, ignoreUnknownParams, strictModelStateValidation, reqCustomizationOrExport, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `setting.auth.ticket.create.*` - __required__. * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create a new ticket that allows to initialize a new session.
         * @param {string} modelId Model ID.
         * @param {ReqTicket} reqTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(modelId: string, reqTicket: ReqTicket, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateTicket> {
            return localVarFp.createTicket(modelId, reqTicket, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `setting.auth.ticket.decrypt.*` - __required__.
         * @summary Decrypt the given ticket and return its details.
         * @param {string} ticketEncrypted Encrypted ShapeDiver ticket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decryptTicket(ticketEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDecryptTicket> {
            return localVarFp.decryptTicket(ticketEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions: * `get.parameter.*` - optional: adds _parameter defaults_ to response. * `get.export.*` - optional: adds _export definitions_ to response. * `compute.output.*` - optional: adds _outputs for default parameters_ to response. * `get.output.*` - optional: adds _output definitions_ to response.
         * @summary Get session defaults (corresponds to the content of the session initialization request).
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionDefaults(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetSessionDefaults> {
            return localVarFp.getSessionDefaults(sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Close session.
     * @param {string} sessionId Session ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public closeSession(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).closeSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `auth.session` - __required__. * `get.parameter.*` - optional: adds _parameters_ to response. * Output:   * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
     * @summary Initialize new session by model ID.
     * @param {string} modelId Model ID.
     * @param {string} [modelStateId] ID of the Model-State to apply.
     * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers for customization and export requests. When set to &#x60;true&#x60;, unknown parameter IDs will be ignored instead of causing an error.  Defaults to &#x60;false&#x60;.
     * @param {boolean} [strictModelStateValidation] When set to &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model - either because the parameter ID is unknown or the parameter value is invalid - will be ignored. When set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
     * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSessionByModel(modelId: string, modelStateId?: string, ignoreUnknownParams?: boolean, strictModelStateValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).createSessionByModel(modelId, modelStateId, ignoreUnknownParams, strictModelStateValidation, reqCustomizationOrExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `get.parameter.*` - optional: adds _parameters_ to response. * Output:   * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
     * @summary Initialize new session by ticket.
     * @param {string} ticketId Encrypted ticket.
     * @param {string} [modelStateId] ID of the Model-State to apply.
     * @param {boolean} [ignoreUnknownParams] Allow relaxed validation of parameter identifiers for customization and export requests. When set to &#x60;true&#x60;, unknown parameter IDs will be ignored instead of causing an error.  Defaults to &#x60;false&#x60;.
     * @param {boolean} [strictModelStateValidation] When set to &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model - either because the parameter ID is unknown or the parameter value is invalid - will be ignored. When set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
     * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSessionByTicket(ticketId: string, modelStateId?: string, ignoreUnknownParams?: boolean, strictModelStateValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).createSessionByTicket(ticketId, modelStateId, ignoreUnknownParams, strictModelStateValidation, reqCustomizationOrExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions: * `setting.auth.ticket.create.*` - __required__. * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
     * @summary Create a new ticket that allows to initialize a new session.
     * @param {string} modelId Model ID.
     * @param {ReqTicket} reqTicket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTicket(modelId: string, reqTicket: ReqTicket, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).createTicket(modelId, reqTicket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions: * `setting.auth.ticket.decrypt.*` - __required__.
     * @summary Decrypt the given ticket and return its details.
     * @param {string} ticketEncrypted Encrypted ShapeDiver ticket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public decryptTicket(ticketEncrypted: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).decryptTicket(ticketEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions: * `get.parameter.*` - optional: adds _parameter defaults_ to response. * `get.export.*` - optional: adds _export definitions_ to response. * `compute.output.*` - optional: adds _outputs for default parameters_ to response. * `get.output.*` - optional: adds _output definitions_ to response.
     * @summary Get session defaults (corresponds to the content of the session initialization request).
     * @param {string} sessionId Session ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionDefaults(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).getSessionDefaults(sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Subject-Restriction: __backend__.
         * @summary Create a signed URL for the specified endpoint and target.
         * @param {string} endpoint CDN endpoint.
         * @param {string} encodedUri Base64 encoded target URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignedUrl: async (endpoint: string, encodedUri: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('createSignedUrl', 'endpoint', endpoint)
            // verify required parameter 'encodedUri' is not null or undefined
            assertParamExists('createSignedUrl', 'encodedUri', encodedUri)
            const localVarPath = `/api/v2/system/sign/cdn/{endpoint}/{encodedUri}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)))
                .replace(`{${"encodedUri"}}`, encodeURIComponent(String(encodedUri)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'text/plain,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `delete.hard` - __required__.
         * @summary Delete model permanently.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eraseModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('eraseModel', 'modelId', modelId)
            const localVarPath = `/api/v2/system/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Get system information about the Geometry Minions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMinionsInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/system/minions/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Geometry Worker that is a candidate for scaling in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScaleInCandidate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/system/workers/scale-in-candidate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A __backend__ subject adds `system.plugins.inconsistent`.
         * @summary Get system information about the Geometry Workers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkersInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/system/workers/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Subject-Restriction: __backend__.
         * @summary Create a signed URL for the specified endpoint and target.
         * @param {string} endpoint CDN endpoint.
         * @param {string} encodedUri Base64 encoded target URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSignedUrl(endpoint: string, encodedUri: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSignedUrl(endpoint, encodedUri, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.createSignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `delete.hard` - __required__.
         * @summary Delete model permanently.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eraseModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eraseModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.eraseModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Get system information about the Geometry Minions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMinionsInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetMinionsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMinionsInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getMinionsInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a Geometry Worker that is a candidate for scaling in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScaleInCandidate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetScaleInCandidate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScaleInCandidate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getScaleInCandidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A __backend__ subject adds `system.plugins.inconsistent`.
         * @summary Get system information about the Geometry Workers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkersInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetWorkersInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkersInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getWorkersInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Subject-Restriction: __backend__.
         * @summary Create a signed URL for the specified endpoint and target.
         * @param {string} endpoint CDN endpoint.
         * @param {string} encodedUri Base64 encoded target URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignedUrl(endpoint: string, encodedUri: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createSignedUrl(endpoint, encodedUri, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `delete.hard` - __required__.
         * @summary Delete model permanently.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eraseModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteModel> {
            return localVarFp.eraseModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Get system information about the Geometry Minions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMinionsInfo(options?: RawAxiosRequestConfig): AxiosPromise<ResGetMinionsInfo> {
            return localVarFp.getMinionsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Geometry Worker that is a candidate for scaling in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScaleInCandidate(options?: RawAxiosRequestConfig): AxiosPromise<ResGetScaleInCandidate> {
            return localVarFp.getScaleInCandidate(options).then((request) => request(axios, basePath));
        },
        /**
         * A __backend__ subject adds `system.plugins.inconsistent`.
         * @summary Get system information about the Geometry Workers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkersInfo(options?: RawAxiosRequestConfig): AxiosPromise<ResGetWorkersInfo> {
            return localVarFp.getWorkersInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 */
export class SystemApi extends BaseAPI {
    /**
     * Subject-Restriction: __backend__.
     * @summary Create a signed URL for the specified endpoint and target.
     * @param {string} endpoint CDN endpoint.
     * @param {string} encodedUri Base64 encoded target URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSignedUrl(endpoint: string, encodedUri: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).createSignedUrl(endpoint, encodedUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions: * `delete.hard` - __required__.
     * @summary Delete model permanently.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public eraseModel(modelId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).eraseModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary Get system information about the Geometry Minions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMinionsInfo(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getMinionsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Geometry Worker that is a candidate for scaling in.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getScaleInCandidate(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getScaleInCandidate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A __backend__ subject adds `system.plugins.inconsistent`.
     * @summary Get system information about the Geometry Workers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWorkersInfo(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getWorkersInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextureApi - axios parameter creator
 */
export const TextureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions: * `cache.texture.list.*` - __required__.
         * @summary List model textures.
         * @param {string} sessionId Session ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTextures: async (sessionId: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listTextures', 'sessionId', sessionId)
            const localVarPath = `/api/v2/session/{sessionId}/texture/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextureApi - functional programming interface
 */
export const TextureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextureApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions: * `cache.texture.list.*` - __required__.
         * @summary List model textures.
         * @param {string} sessionId Session ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTextures(sessionId: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListTextures>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTextures(sessionId, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextureApi.listTextures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextureApi - factory interface
 */
export const TextureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextureApiFp(configuration)
    return {
        /**
         * Permissions: * `cache.texture.list.*` - __required__.
         * @summary List model textures.
         * @param {string} sessionId Session ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTextures(sessionId: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListTextures> {
            return localVarFp.listTextures(sessionId, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextureApi - object-oriented interface
 */
export class TextureApi extends BaseAPI {
    /**
     * Permissions: * `cache.texture.list.*` - __required__.
     * @summary List model textures.
     * @param {string} sessionId Session ID.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listTextures(sessionId: string, offset?: string, options?: RawAxiosRequestConfig) {
        return TextureApiFp(this.configuration).listTextures(sessionId, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



