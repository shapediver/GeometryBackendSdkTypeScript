/* tslint:disable */
/* eslint-disable */
/**
 * Geometry Backend API v2
 * The ShapeDiver Geometry Backend system is used to: * host Grasshopper models in a secure, reliable, scalable, and performant way, * run computations of Grasshopper models, * and cache and output the results of computations and exports.
 *
 * The version of the OpenAPI document: 1.6.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequiredError, operationServerMap } from './base';
import { BaseAPI } from '../base';

/**
 * Reference to the s-type parameter asset to be used.
 * @export
 * @interface CommmonsParameterAsset
 */
export interface CommmonsParameterAsset {
    /**
     * String ID of the asset.
     * @type {string}
     * @memberof CommmonsParameterAsset
     */
    'id': string;
    /**
     * 
     * @type {CommonsParameterChunk}
     * @memberof CommmonsParameterAsset
     */
    'chunk'?: CommonsParameterChunk;
}
/**
 * @type CommonsBasicParameter
 * Definition of a basic ShapeDiver parameter.
 * @export
 */
export type CommonsBasicParameter = boolean | number | string;

/**
 * Status of a model computation.
 * @export
 * @enum {string}
 */

export const CommonsComputationStatus = {
    SUCCESS: 'success',
    TIMEOUT: 'timeout',
    CHECK_CONFIRMED: 'checkconfirmed',
    CHECK_DENIED: 'checkdenied',
    CHECK_PENDING: 'checkpending',
    MAX_COMBINED_ASSET_SIZE_EXCEEDED: 'maxcombinedassetsizeexceeded',
    MAX_DB_SIZE_PER_OUTPUT_EXCEEDED: 'maxdbsizeperoutputexceeded',
    MAX_PARTS_PER_OUTPUT_EXCEEDED: 'maxpartsperoutputexceeded',
    MAX_ASSET_PARTS_PER_OUTPUT_EXCEEDED: 'maxassetpartsperoutputexceeded',
    MAX_TRANSFORMATIONS_PER_OUTPUT_EXCEEDED: 'maxtransformationsperoutputexceeded',
    MAX_PARTS_EXCEEDED: 'maxpartsexceeded',
    MAX_ASSET_PARTS_EXCEEDED: 'maxassetpartsexceeded',
    RECOVERABLE_ERROR: 'recoverableerror',
    UNRECOVERABLE_ERROR: 'unrecoverableerror',
    NO_OUTPUT_DATA_FOR_DEFAULT_PARAMETER_VALUES: 'nooutputdatafordefaultparametervalues',
    MODEL_WITHOUT_GEOMETRY_OUTPUT: 'modelwithoutgeometryoutput',
    UNKNOWN: 'unknown'
} as const;

export type CommonsComputationStatus = typeof CommonsComputationStatus[keyof typeof CommonsComputationStatus];


/**
 * Group of a parameter, export or output.
 * @export
 * @interface CommonsGroup
 */
export interface CommonsGroup {
    /**
     * 
     * @type {string}
     * @memberof CommonsGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CommonsGroup
     */
    'name': string;
}
/**
 * Status of a model.
 * @export
 * @enum {string}
 */

export const CommonsModelStatus = {
    UNKNOWN: 'unknown',
    NOT_UPLOADED: 'not_uploaded',
    UPLOADED: 'uploaded',
    PENDING: 'pending',
    CONFIRMED: 'confirmed',
    DENIED: 'denied',
    DELETED: 'deleted'
} as const;

export type CommonsModelStatus = typeof CommonsModelStatus[keyof typeof CommonsModelStatus];


/**
 * Describing which chunk of the s-type asset to use. When not specified, the chunk of an asset gets chosen based on parameter ID and name.
 * @export
 * @interface CommonsParameterChunk
 */
export interface CommonsParameterChunk {
    /**
     * ID of the chunk to be used.
     * @type {string}
     * @memberof CommonsParameterChunk
     */
    'id'?: string;
    /**
     * Name attribute of the chunk to be used.
     * @type {string}
     * @memberof CommonsParameterChunk
     */
    'name'?: string;
}
/**
 * Definition of the value to use for s-type parameters.
 * @export
 * @interface CommonsStypeParameter
 */
export interface CommonsStypeParameter {
    /**
     * Optional embedded value. If this is set the asset is ignored.
     * @type {string}
     * @memberof CommonsStypeParameter
     */
    'value'?: string;
    /**
     * 
     * @type {CommmonsParameterAsset}
     * @memberof CommonsStypeParameter
     */
    'asset'?: CommmonsParameterAsset;
}
/**
 * Authorization ticket.
 * @export
 * @interface CommonsTicket
 */
export interface CommonsTicket {
    /**
     * List of domains (origins) this ticket should be limited to; may be empty.
     * @type {Array<string>}
     * @memberof CommonsTicket
     */
    'accessdomains'?: Array<string>;
    /**
     * Should this ticket provide access to model authoring (allows to change configuration)?
     * @type {boolean}
     * @memberof CommonsTicket
     */
    'author'?: boolean;
    /**
     * Should this ticket allow public access (ignore the model\'s `accessdomains` property)?
     * @type {boolean}
     * @memberof CommonsTicket
     */
    'pub': boolean;
    /**
     * The timestamp until which the ticket should be valid.
     * @type {string}
     * @memberof CommonsTicket
     */
    'until': string;
    /**
     * Does this ticket identify the model via its secondary ID (model property `id2`)?
     * @type {boolean}
     * @memberof CommonsTicket
     */
    'use_id2'?: boolean;
}
/**
 * Type of a ticket.
 * @export
 * @enum {string}
 */

export const CommonsTicketType = {
    BACKEND: 'backend',
    NONE: ''
} as const;

export type CommonsTicketType = typeof CommonsTicketType[keyof typeof CommonsTicketType];


/**
 * A substitution for the JSON-value `null`.
 * @export
 * @interface NullObj
 */
export interface NullObj {
    /**
     * The value of this property does not matter.
     * @type {boolean}
     * @memberof NullObj
     */
    'nullObj': boolean;
}
/**
 * Filter by model computation statistics status.
 * @export
 * @enum {string}
 */

export const QueryComputationStatisticsStatus = {
    SUCCESS: 'success',
    TIMEOUT: 'timeout',
    OTHER: 'other',
    ALL: '*'
} as const;

export type QueryComputationStatisticsStatus = typeof QueryComputationStatisticsStatus[keyof typeof QueryComputationStatisticsStatus];


/**
 * Filter by model computation status.
 * @export
 * @enum {string}
 */

export const QueryComputationStatus = {
    SUCCESS: 'success',
    TIMEOUT: 'timeout',
    CHECK_CONFIRMED: 'checkconfirmed',
    CHECK_DENIED: 'checkdenied',
    CHECK_PENDING: 'checkpending',
    MAX_COMBINED_ASSET_SIZE_EXCEEDED: 'maxcombinedassetsizeexceeded',
    MAX_DB_SIZE_PER_OUTPUT_EXCEEDED: 'maxdbsizeperoutputexceeded',
    MAX_PARTS_PER_OUTPUT_EXCEEDED: 'maxpartsperoutputexceeded',
    MAX_ASSET_PARTS_PER_OUTPUT_EXCEEDED: 'maxassetpartsperoutputexceeded',
    MAX_TRANSFORMATIONS_PER_OUTPUT_EXCEEDED: 'maxtransformationsperoutputexceeded',
    MAX_PARTS_EXCEEDED: 'maxpartsexceeded',
    MAX_ASSET_PARTS_EXCEEDED: 'maxassetpartsexceeded',
    RECOVERABLE_ERROR: 'recoverableerror',
    UNRECOVERABLE_ERROR: 'unrecoverableerror',
    NO_OUTPUT_DATA_FOR_DEFAULT_PARAMETER_VALUES: 'nooutputdatafordefaultparametervalues',
    MODEL_WITHOUT_GEOMETRY_OUTPUT: 'modelwithoutgeometryoutput',
    UNKNOWN: 'unknown'
} as const;

export type QueryComputationStatus = typeof QueryComputationStatus[keyof typeof QueryComputationStatus];


/**
 * Filter by computation type.
 * @export
 * @enum {string}
 */

export const QueryComputationType = {
    COMPUTATION: 'computation',
    EXPORT: 'export',
    LOAD: 'load',
    ALL: '*'
} as const;

export type QueryComputationType = typeof QueryComputationType[keyof typeof QueryComputationType];


/**
 * Conversion type of a glTF upoad: * `none`: no further processing of the file. * `usdz`: converts the glTF into the USDZ format. * `scene`: creates a temporary AR scene that holds both, a glTF and a USDZ file.
 * @export
 * @enum {string}
 */

export const QueryGltfConversion = {
    NONE: 'none',
    SCENE: 'scene',
    USDZ: 'usdz'
} as const;

export type QueryGltfConversion = typeof QueryGltfConversion[keyof typeof QueryGltfConversion];


/**
 * Filter by model status.
 * @export
 * @enum {string}
 */

export const QueryModelStatus = {
    UNKNOWN: 'unknown',
    NOT_UPLOADED: 'not_uploaded',
    UPLOADED: 'uploaded',
    PENDING: 'pending',
    CONFIRMED: 'confirmed',
    DENIED: 'denied',
    DELETED: 'deleted'
} as const;

export type QueryModelStatus = typeof QueryModelStatus[keyof typeof QueryModelStatus];


/**
 * Specifies the order of the results.
 * @export
 * @enum {string}
 */

export const QueryOrder = {
    ASC: 'asc',
    DESC: 'desc'
} as const;

export type QueryOrder = typeof QueryOrder[keyof typeof QueryOrder];


/**
 * @type ReqAnyCreditMetricId
 * Either a single or multiple IDs. Multiple IDs are aggregated and result in a single credit metrics object.
 * @export
 */
export type ReqAnyCreditMetricId = ReqModelCreditMetricId | ReqModelOrganizationCreditMetricId | ReqModelUserCreditMetricId | ReqOrganizationCreditMetricId | ReqSystemCreditMetricId | ReqUserCreditMetricId;

/**
 * Body of an authorization group request.
 * @export
 * @interface ReqAuthorizationGroup
 */
export interface ReqAuthorizationGroup {
    /**
     * The model IDs that should form the new authorization group.
     * @type {Array<string>}
     * @memberof ReqAuthorizationGroup
     */
    'models'?: Array<string>;
    /**
     * The user IDs that should form the new authorization group.
     * @type {Array<string>}
     * @memberof ReqAuthorizationGroup
     */
    'users'?: Array<string>;
    /**
     * The organization IDs that should form the new authorization group.
     * @type {Array<string>}
     * @memberof ReqAuthorizationGroup
     */
    'organizations'?: Array<string>;
}
/**
 * Body of an export or output cache request. A directory of export-/output-IDs and version-IDs.
 * @export
 * @interface ReqCache
 */
export interface ReqCache {
    [key: string]: string;

}
/**
 * Body of a configure request.  A dictionary of string keys and values of any type.
 * @export
 * @interface ReqConfigure
 */
export interface ReqConfigure {
    [key: string]: any;

}
/**
 * Parameters of a credit metrics request. When IDs or timestamps are requested, the resulting response-item represents an aggregation of the requested data.
 * @export
 * @interface ReqCreditMetric
 */
export interface ReqCreditMetric {
    /**
     * 
     * @type {ReqAnyCreditMetricId}
     * @memberof ReqCreditMetric
     */
    'id': ReqAnyCreditMetricId;
    /**
     * Either a single extended date or an array of extended dates. Multiple timestamps are aggregated and result in a single credit metrics object.
     * @type {Array<string>}
     * @memberof ReqCreditMetric
     */
    'timestamp'?: Array<string>;
    /**
     * Allows to define the beginning of a time range, instead of specifying individual timestamps.
     * @type {string}
     * @memberof ReqCreditMetric
     */
    'timestamp_from'?: string;
    /**
     * Allows to define the ending of a time range, instead of specifying individual timestamps.
     * @type {string}
     * @memberof ReqCreditMetric
     */
    'timestamp_to'?: string;
}
/**
 * Body of a credit metrics request. Every request-item results in exactly one response-item, whereby the order of response-items corresponds to the order of the request-items.
 * @export
 * @interface ReqCreditMetrics
 */
export interface ReqCreditMetrics {
    /**
     * 
     * @type {Array<ReqCreditMetric>}
     * @memberof ReqCreditMetrics
     */
    'parameters': Array<ReqCreditMetric>;
}
/**
 * A directory of parameter keys and values.  Supported parameter keys are as follows, whereby the parameter resolution is done in the same order as the keys are listed: * `id` * `name` * `displayname`  Supported parameter values are: * Basic parameter (`CommonsBasicParameter`) * S-type parameter (`CommonsStypeParameter`)
 * @export
 * @interface ReqCustomization
 */
export interface ReqCustomization {
    [key: string]: ReqParameterValue;

}
/**
 * @type ReqCustomizationOrCache
 * Either a cache or a customization request.
 * @export
 */
export type ReqCustomizationOrCache = ReqCache | ReqCustomization;

/**
 * @type ReqCustomizationOrExport
 * @export
 */
export type ReqCustomizationOrExport = ReqCustomization | ReqExport;

/**
 * Body of an export request.
 * @export
 * @interface ReqExport
 */
export interface ReqExport {
    /**
     * 
     * @type {ReqCustomization}
     * @memberof ReqExport
     */
    'parameters': ReqCustomization;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqExport
     */
    'exports': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqExport
     */
    'outputs'?: Array<string>;
    /**
     * Maximum amount of milliseconds to wait for completion of export request before responding.
     * @type {number}
     * @memberof ReqExport
     */
    'max_wait_time'?: number;
}
/**
 * Data for a single export definition.
 * @export
 * @interface ReqExportDefinition
 */
export interface ReqExportDefinition {
    /**
     * Parameter name to display instead of _name_.
     * @type {string}
     * @memberof ReqExportDefinition
     */
    'displayname'?: string;
    /**
     * 
     * @type {ReqExportDefinitionGroup}
     * @memberof ReqExportDefinition
     */
    'group'?: ReqExportDefinitionGroup;
    /**
     * Controls whether the export should be hidden in the UI.
     * @type {boolean}
     * @memberof ReqExportDefinition
     */
    'hidden'?: boolean;
    /**
     * Ordering of the export in client applications.
     * @type {number}
     * @memberof ReqExportDefinition
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ReqExportDefinition
     */
    'tooltip'?: string;
}
/**
 * @type ReqExportDefinitionGroup
 * Set to `null` or `NullObj` to remove the export from the currently assigned group.
 * @export
 */
export type ReqExportDefinitionGroup = NullObj | ReqGroup;

/**
 * Definition of a exports. A directory of export-IDs and export-definitions.
 * @export
 * @interface ReqExportDefinitions
 */
export interface ReqExportDefinitions {
    [key: string]: ReqExportDefinition;

}
/**
 * @type ReqExportOrCache
 * Either a cache or an export request.
 * @export
 */
export type ReqExportOrCache = ReqCache | ReqExport;

/**
 * Data for a single file parameter.
 * @export
 * @interface ReqFileDefinition
 */
export interface ReqFileDefinition {
    /**
     * Name of the file to be uploaded.  If this property is set, the file upload request must include a `Content-Disposition` HTTP header with the format `attachment; filename=\"{filename}\"`. Failure to do so will result in a signature mismatch. For convenience, the response will provide a preformatted HTTP header value that can be used directly.
     * @type {string}
     * @memberof ReqFileDefinition
     */
    'filename'?: string;
    /**
     * Content-Type (MIME type) of the file to be uploaded.
     * @type {string}
     * @memberof ReqFileDefinition
     */
    'format': string;
    /**
     * Size of the file to be uploaded, in bytes.
     * @type {number}
     * @memberof ReqFileDefinition
     */
    'size': number;
}
/**
 * Body of a file upload request. A directory of file-parameter-IDs and upload-definitions.
 * @export
 * @interface ReqFileUpload
 */
export interface ReqFileUpload {
    [key: string]: ReqFileDefinition;

}
/**
 * Group information.
 * @export
 * @interface ReqGroup
 */
export interface ReqGroup {
    /**
     * 
     * @type {string}
     * @memberof ReqGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReqGroup
     */
    'name': string;
}
/**
 * Log message level for log requests.
 * @export
 * @enum {string}
 */

export const ReqLogLevel = {
    INFO: '0',
    WARN: '1',
    ERROR: '2'
} as const;

export type ReqLogLevel = typeof ReqLogLevel[keyof typeof ReqLogLevel];


/**
 * Body of a log message request.
 * @export
 * @interface ReqLogMessage
 */
export interface ReqLogMessage {
    /**
     * 
     * @type {ReqLogLevel}
     * @memberof ReqLogMessage
     */
    'level': ReqLogLevel;
    /**
     * The message that should be logged.
     * @type {string}
     * @memberof ReqLogMessage
     */
    'message': string;
}


/**
 * Body of a template request.
 * @export
 * @interface ReqModel
 */
export interface ReqModel {
    /**
     * List of domains (origins) this model is limited to (is ignored in case `pub` is true).
     * @type {Array<string>}
     * @memberof ReqModel
     */
    'accessdomains'?: Array<string>;
    /**
     * List of allowed Grasshopper libraries.
     * @type {Array<string>}
     * @memberof ReqModel
     */
    'allowed_libraries'?: Array<string>;
    /**
     * List of allowed auth-groups.
     * @type {Array<string>}
     * @memberof ReqModel
     */
    'auth_groups'?: Array<string>;
    /**
     * Should backend access to the model be allowed.
     * @type {boolean}
     * @memberof ReqModel
     */
    'backendaccess'?: boolean;
    /**
     * Original name of the model\'s grasshopper file.
     * @type {string}
     * @memberof ReqModel
     */
    'filename'?: string;
    /**
     * File type of the model.
     * @type {ReqModelFileType}
     * @memberof ReqModel
     */
    'ftype'?: ReqModelFileType;
    /**
     * Allows to control whether the model should be warmed up immediately after loading by running a computation. This increases the likelihood of following computation requests to be faster.
     * @type {boolean}
     * @memberof ReqModel
     */
    'initial_warmup'?: boolean;
    /**
     * Optional second model ID.
     * @type {string}
     * @memberof ReqModel
     */
    'id2'?: string;
    /**
     * Maximum number of milliseconds allowed for computations of this model.
     * @type {number}
     * @memberof ReqModel
     */
    'max_comp_time'?: number;
    /**
     * Maximum number of bytes allowed to be exported from a model for a specific set of parameter values.
     * @type {number}
     * @memberof ReqModel
     */
    'max_export_size'?: number;
    /**
     * Maximum amount of minutes a loaded model may be unused before it gets unloaded.  Note: Models may get unloaded earlier than that.
     * @type {number}
     * @memberof ReqModel
     */
    'max_idle_minutes'?: number;
    /**
     * Maximum number of bytes allowed for the model\'s Grasshopper file size.
     * @type {number}
     * @memberof ReqModel
     */
    'max_model_size'?: number;
    /**
     * Maximum number of bytes allowed for an output of a model for a specific set of parameter values.
     * @type {number}
     * @memberof ReqModel
     */
    'max_output_size'?: number;
    /**
     * Allows to configure the maximum number of bytes allowed for a single texture.
     * @type {number}
     * @memberof ReqModel
     */
    'max_texture_size'?: number;
    /**
     * Maximum time a computation request may stay waiting before a further worker goes ahead regardless of whether it already has the model loaded, and regardless of `num_loaded_max`. This allows to configure a soft or a hard upper boundary for the number of loaded models.
     * @type {number}
     * @memberof ReqModel
     */
    'max_wait_time'?: number;
    /**
     * Name of the model.
     * @type {string}
     * @memberof ReqModel
     */
    'name'?: string;
    /**
     * Maximum number of workers that should have the model loaded at the same time.
     * @type {number}
     * @memberof ReqModel
     */
    'num_loaded_max'?: number;
    /**
     * Minimum number of workers which should have the model loaded once a session to the model gets opened.
     * @type {number}
     * @memberof ReqModel
     */
    'num_loaded_min'?: number;
    /**
     * Minimum number of workers that should always have the model loaded, regardless of session activity. This allows to minimise the likelihood of computation requests being slower due to model loading.
     * @type {number}
     * @memberof ReqModel
     */
    'num_preloaded_min'?: number;
    /**
     * Optional organization ID.
     * @type {string}
     * @memberof ReqModel
     */
    'org_id'?: string;
    /**
     * Model ID of this model\'s previous version.
     * @type {string}
     * @memberof ReqModel
     */
    'prev_id'?: string;
    /**
     * Allows public access (ignore `accessdomains`).
     * @type {boolean}
     * @memberof ReqModel
     */
    'pub': boolean;
    /**
     * Enforces iframe embedding instead of direct embedding.
     * @type {boolean}
     * @memberof ReqModel
     */
    'require_iframe'?: boolean;
    /**
     * Enforces token-based authentication for this model.
     * @type {boolean}
     * @memberof ReqModel
     */
    'require_token'?: boolean;
    /**
     * Limits the number of sessions that can be created by a specific IP address in one hour.
     * @type {number}
     * @memberof ReqModel
     */
    'session_rate_limit'?: number;
    /**
     * Can this model be trusted (controls whether failed computations will be retried).
     * @type {ReqTrustLevel}
     * @memberof ReqModel
     */
    'trust'?: ReqTrustLevel;
    /**
     * Allows the usage of the CDN for fast content distribution.
     * @type {boolean}
     * @memberof ReqModel
     */
    'use_cdn'?: boolean;
    /**
     * Optional user ID.
     * @type {string}
     * @memberof ReqModel
     */
    'user_id'?: string;
    /**
     * The webhook-url for updating the platform backend about model status changes.
     * @type {string}
     * @memberof ReqModel
     */
    'webhook_url'?: string;
    /**
     * The webhook-token for authentication used by the webhook-url.
     * @type {string}
     * @memberof ReqModel
     */
    'webhook_token'?: string;
    /**
     * Allows to control whether the model\'s Grasshopper file can contain scripts.
     * @type {boolean}
     * @memberof ReqModel
     */
    'deny_scripts'?: boolean;
}


/**
 * Model metrics
 * @export
 * @interface ReqModelCreditMetricId
 */
export interface ReqModelCreditMetricId {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqModelCreditMetricId
     */
    'modelIds': Array<string>;
}
/**
 * Supported Grasshopper file types for models.
 * @export
 * @enum {string}
 */

export const ReqModelFileType = {
    GRASSHOPPER_BINARY: 'gh',
    GRASSHOPPER_XML: 'ghx'
} as const;

export type ReqModelFileType = typeof ReqModelFileType[keyof typeof ReqModelFileType];


/**
 * Model-Organization metrics
 * @export
 * @interface ReqModelOrganizationCreditMetricId
 */
export interface ReqModelOrganizationCreditMetricId {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqModelOrganizationCreditMetricId
     */
    'modelIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqModelOrganizationCreditMetricId
     */
    'orgIds': Array<string>;
}
/**
 * Description of a Model-State.
 * @export
 * @interface ReqModelState
 */
export interface ReqModelState {
    /**
     * 
     * @type {ReqCustomization}
     * @memberof ReqModelState
     */
    'parameters': ReqCustomization;
    /**
     * Optional untyped data that can be used to store additional information.
     * @type {{ [key: string]: any; }}
     * @memberof ReqModelState
     */
    'data'?: { [key: string]: any; };
    /**
     * Details of the Model-State image file. If provided, the response will include a URL for uploading the file.
     * @type {ReqFileDefinition}
     * @memberof ReqModelState
     */
    'image'?: ReqFileDefinition;
    /**
     * The ID of an existing AR scene associated with this model. If provided, the scene\'s glTF and USDZ data will be duplicated into the newly created Model-State.
     * @type {string}
     * @memberof ReqModelState
     */
    'arSceneId'?: string;
}
/**
 * Parameters of a single model-session analytics request. When multiple model IDs or timestamps are requested, the resulting response-item represents an aggregation of the requested data.
 * @export
 * @interface ReqModelStatistic
 */
export interface ReqModelStatistic {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqModelStatistic
     */
    'modelid': Array<string>;
    /**
     * Either a single extended date or an array of extended dates. Multiple timestamps are aggregated and result in a single statistic object.
     * @type {Array<string>}
     * @memberof ReqModelStatistic
     */
    'timestamp'?: Array<string>;
    /**
     * Allows to define the beginning of a time range, instead of specifying individual timestamps.
     * @type {string}
     * @memberof ReqModelStatistic
     */
    'timestamp_from'?: string;
    /**
     * Allows to define the ending of a time range, instead of specifying individual timestamps.
     * @type {string}
     * @memberof ReqModelStatistic
     */
    'timestamp_to'?: string;
}
/**
 * Body of a model statistics request. Every request-item results in exactly one response-item, whereby the order of response-items corresponds to the order of the request-items.
 * @export
 * @interface ReqModelStatistics
 */
export interface ReqModelStatistics {
    /**
     * 
     * @type {Array<ReqModelStatistic>}
     * @memberof ReqModelStatistics
     */
    'parameters': Array<ReqModelStatistic>;
}
/**
 * Model-User metrics
 * @export
 * @interface ReqModelUserCreditMetricId
 */
export interface ReqModelUserCreditMetricId {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqModelUserCreditMetricId
     */
    'modelIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqModelUserCreditMetricId
     */
    'userIds': Array<string>;
}
/**
 * Organization metrics
 * @export
 * @interface ReqOrganizationCreditMetricId
 */
export interface ReqOrganizationCreditMetricId {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqOrganizationCreditMetricId
     */
    'orgIds': Array<string>;
}
/**
 * Data for a single output definition.
 * @export
 * @interface ReqOutputDefinition
 */
export interface ReqOutputDefinition {
    /**
     * Parameter name to display instead of `name`.
     * @type {string}
     * @memberof ReqOutputDefinition
     */
    'displayname'?: string;
    /**
     * 
     * @type {ReqOutputDefinitionGroup}
     * @memberof ReqOutputDefinition
     */
    'group'?: ReqOutputDefinitionGroup;
    /**
     * Controls whether the output should be hidden in the UI.
     * @type {boolean}
     * @memberof ReqOutputDefinition
     */
    'hidden'?: boolean;
    /**
     * Ordering of the output in client applications.
     * @type {number}
     * @memberof ReqOutputDefinition
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ReqOutputDefinition
     */
    'tooltip'?: string;
    /**
     * The chunk definitions of the sdTF file that is generated by the output. If specified, all existing sdTF chunks of the output must be given. The order of the given chunk items determines the order in that the chunks will be shown in the UI.
     * @type {Array<ReqOutputDefinitionChunk>}
     * @memberof ReqOutputDefinition
     */
    'chunks'?: Array<ReqOutputDefinitionChunk>;
}
/**
 * Definition of a single \"chunk\" of data in an sdTF file that is generated by the output component.
 * @export
 * @interface ReqOutputDefinitionChunk
 */
export interface ReqOutputDefinitionChunk {
    /**
     * ID of the chunk.
     * @type {string}
     * @memberof ReqOutputDefinitionChunk
     */
    'id': string;
    /**
     * Chunk name to display instead of the chunk `name`. This value can be unset by specifying an empty string.
     * @type {string}
     * @memberof ReqOutputDefinitionChunk
     */
    'displayname'?: string;
    /**
     * Controls whether the chunk should be hidden in the UI.
     * @type {boolean}
     * @memberof ReqOutputDefinitionChunk
     */
    'hidden'?: boolean;
}
/**
 * @type ReqOutputDefinitionGroup
 * Set to `null` or `NullObj` to remove the export from the currently assigned group.
 * @export
 */
export type ReqOutputDefinitionGroup = NullObj | ReqGroup;

/**
 * Definition of outputs. A directory of output-IDs and output-definitions.
 * @export
 * @interface ReqOutputDefinitions
 */
export interface ReqOutputDefinitions {
    [key: string]: ReqOutputDefinition;

}
/**
 * Data for a single parameter definition.
 * @export
 * @interface ReqParameterDefinition
 */
export interface ReqParameterDefinition {
    /**
     * Parameter name to display instead of `name`.
     * @type {string}
     * @memberof ReqParameterDefinition
     */
    'displayname'?: string;
    /**
     * 
     * @type {ReqParameterDefinitionGroup}
     * @memberof ReqParameterDefinition
     */
    'group'?: ReqParameterDefinitionGroup;
    /**
     * Controls whether the parameter should be hidden in the UI.
     * @type {boolean}
     * @memberof ReqParameterDefinition
     */
    'hidden'?: boolean;
    /**
     * Ordering of the parameter in client applications.
     * @type {number}
     * @memberof ReqParameterDefinition
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ReqParameterDefinition
     */
    'tooltip'?: string;
    /**
     * Holds parameter-type specific information.
     * @type {object}
     * @memberof ReqParameterDefinition
     */
    'settings'?: object;
}
/**
 * @type ReqParameterDefinitionGroup
 * Set to `null` or `NullObj` to remove the export from the currently assigned group.
 * @export
 */
export type ReqParameterDefinitionGroup = NullObj | ReqGroup;

/**
 * Definition of model parameters. A directory of parameter-IDs and parameter-definitions.
 * @export
 * @interface ReqParameterDefinitions
 */
export interface ReqParameterDefinitions {
    [key: string]: ReqParameterDefinition;

}
/**
 * @type ReqParameterValue
 * The value of a single model parameter.
 * @export
 */
export type ReqParameterValue = CommonsBasicParameter | CommonsStypeParameter;

/**
 * Data for a single sdTF parameter.
 * @export
 * @interface ReqSdtfDefinition
 */
export interface ReqSdtfDefinition {
    /**
     * Encoding of the sdTF to be uploaded.
     * @type {string}
     * @memberof ReqSdtfDefinition
     */
    'content_encoding'?: string;
    /**
     * Size of the sdTF to be uploaded, in bytes.
     * @type {number}
     * @memberof ReqSdtfDefinition
     */
    'content_length': number;
    /**
     * Content-type of the sdTF to be uploaded.
     * @type {ReqSdtfType}
     * @memberof ReqSdtfDefinition
     */
    'content_type': ReqSdtfType;
    /**
     * Namespace the asset shall be created in.
     * @type {string}
     * @memberof ReqSdtfDefinition
     */
    'namespace': string;
}


/**
 * Content-Type (MIME type) of the sdTF to be uploaded.
 * @export
 * @enum {string}
 */

export const ReqSdtfType = {
    MODEL_SDTF: 'model/vnd.sdtf'
} as const;

export type ReqSdtfType = typeof ReqSdtfType[keyof typeof ReqSdtfType];


/**
 * System-wide metrics
 * @export
 * @interface ReqSystemCreditMetricId
 */
export interface ReqSystemCreditMetricId {
    /**
     * 
     * @type {boolean}
     * @memberof ReqSystemCreditMetricId
     */
    'systems': boolean;
}
/**
 * Body of a ticket request.
 * @export
 * @interface ReqTicket
 */
export interface ReqTicket {
    /**
     * List of domains (origins) this ticket should be limited to; may be empty.
     * @type {Array<string>}
     * @memberof ReqTicket
     */
    'accessdomains'?: Array<string>;
    /**
     * Should this ticket provide access to model authoring (allows to change configuration)?
     * @type {boolean}
     * @memberof ReqTicket
     */
    'author'?: boolean;
    /**
     * Should this ticket allow public access (ignore the model\'s `accessdomains` property)?
     * @type {boolean}
     * @memberof ReqTicket
     */
    'pub': boolean;
    /**
     * The timestamp until which the ticket should be valid.
     * @type {string}
     * @memberof ReqTicket
     */
    'until': string;
    /**
     * Does this ticket identify the model via its secondary ID (model property `id2`)?
     * @type {boolean}
     * @memberof ReqTicket
     */
    'use_id2'?: boolean;
    /**
     * 
     * @type {ReqTicketType}
     * @memberof ReqTicket
     */
    'type': ReqTicketType;
}


/**
 * The type of the ticket.
 * @export
 * @enum {string}
 */

export const ReqTicketType = {
    BACKEND: 'backend',
    NONE: ''
} as const;

export type ReqTicketType = typeof ReqTicketType[keyof typeof ReqTicketType];


/**
 * Level of trust granted for a model.
 * @export
 * @enum {string}
 */

export const ReqTrustLevel = {
    UNDEFINED: '',
    NONE: 'none',
    FULL: 'full'
} as const;

export type ReqTrustLevel = typeof ReqTrustLevel[keyof typeof ReqTrustLevel];


/**
 * User metrics
 * @export
 * @interface ReqUserCreditMetricId
 */
export interface ReqUserCreditMetricId {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReqUserCreditMetricId
     */
    'userIds': Array<string>;
}
/**
 * Defines the actions to be taken on the response data.
 * @export
 * @interface ResAction
 */
export interface ResAction {
    /**
     * Name of the action, e.g. customize, close, default, etc.
     * @type {string}
     * @memberof ResAction
     */
    'name': string;
    /**
     * Title of the action, e.g. \'Customize model\', \'Close session\', etc.
     * @type {string}
     * @memberof ResAction
     */
    'title': string;
    /**
     * Hyperlink to make the request to.
     * @type {string}
     * @memberof ResAction
     */
    'href': string;
    /**
     * HTTP method to use.
     * @type {string}
     * @memberof ResAction
     */
    'method': string;
    /**
     * Template for the request body, references into the \'templates\' array of the response (e.g. \'customize-request\').
     * @type {string}
     * @memberof ResAction
     */
    'template'?: string;
}
/**
 * Contains the model checking configuration for the Grasshopper plugins.
 * @export
 * @interface ResAllowedWorkerPlugin
 */
export interface ResAllowedWorkerPlugin {
    /**
     * ID of the Grasshopper plugin.
     * @type {string}
     * @memberof ResAllowedWorkerPlugin
     */
    'id': string;
    /**
     * Name of the Grasshopper plugin.
     * @type {string}
     * @memberof ResAllowedWorkerPlugin
     */
    'name': string;
    /**
     * Minimum supported version of the plugin.
     * @type {string}
     * @memberof ResAllowedWorkerPlugin
     */
    'minVersion': string;
    /**
     * Maximum supported version of the plugin.
     * @type {string}
     * @memberof ResAllowedWorkerPlugin
     */
    'maxVersion': string;
    /**
     * Name of the plugin author.
     * @type {string}
     * @memberof ResAllowedWorkerPlugin
     */
    'authorName'?: string;
    /**
     * Link to a website related to the plugin.
     * @type {string}
     * @memberof ResAllowedWorkerPlugin
     */
    'description'?: string;
    /**
     * Link to a website related to the plugin.
     * @type {string}
     * @memberof ResAllowedWorkerPlugin
     */
    'href'?: string;
    /**
     * When `true` then `GH_AssemblyInfo.AssemblyVersion` may be used instead of `GH_AssemblyInfo.Version` for version checking.  Defaults to `false`.
     * @type {boolean}
     * @memberof ResAllowedWorkerPlugin
     */
    'allowFallbackToAssemblyVersion': boolean;
    /**
     * When `true` then only the major and minor version numbers recorded in Grasshopper models will be checked.  Defaults to `false`.
     * @type {boolean}
     * @memberof ResAllowedWorkerPlugin
     */
    'checkMajorMinorVersionOnly': boolean;
    /**
     * When `false` then the installation check of the plugin will be skipped.  Defaults to `true`.
     * @type {boolean}
     * @memberof ResAllowedWorkerPlugin
     */
    'checkIfInstalled': boolean;
    /**
     * List of previous plugin IDs supported by this plugin version. This is used for the obscure case of the plugin developer changing the plugin ID.
     * @type {Array<string>}
     * @memberof ResAllowedWorkerPlugin
     */
    'previousIds': Array<string>;
    /**
     * List of plugin components that are explicitly allowed. When this property is set, only the listed components are allowed, overruling the list in `disallowedComponents`.
     * @type {Array<ResWorkerPluginComponent>}
     * @memberof ResAllowedWorkerPlugin
     */
    'allowedComponents': Array<ResWorkerPluginComponent>;
    /**
     * List of plugin components which may not be used. This list might be overruled by `allowedComponents`.
     * @type {Array<ResWorkerPluginComponent>}
     * @memberof ResAllowedWorkerPlugin
     */
    'disallowedComponents': Array<ResWorkerPluginComponent>;
}
/**
 * Analytics components.
 * @export
 * @interface ResAnalytics
 */
export interface ResAnalytics {
    /**
     * 
     * @type {Array<ResModelStatistic>}
     * @memberof ResAnalytics
     */
    'models': Array<ResModelStatistic>;
    /**
     * 
     * @type {Array<ResAnyCreditMetric>}
     * @memberof ResAnalytics
     */
    'creditMetrics': Array<ResAnyCreditMetric>;
}
/**
 * @type ResAnyCreditMetric
 * The ID of any type of credit metric.
 * @export
 */
export type ResAnyCreditMetric = ResModelCreditMetric | ResModelOrganizationCreditMetric | ResModelUserCreditMetric | ResOrganizationCreditMetric | ResSystemCreditMetric | ResUserCreditMetric;

/**
 * Downloads of AR scenes.
 * @export
 * @interface ResArCreditMetric
 */
export interface ResArCreditMetric {
    /**
     * Number of AR downloads charged.
     * @type {number}
     * @memberof ResArCreditMetric
     */
    'credits': number;
}
/**
 * ShapeDiver API response for asset upload requests.
 * @export
 * @interface ResAsset
 */
export interface ResAsset {
    /**
     * A directory of parameter-IDs and asset-definitions.
     * @type {{ [key: string]: ResAssetDefinition; }}
     * @memberof ResAsset
     */
    'file'?: { [key: string]: ResAssetDefinition; };
    /**
     * 
     * @type {Array<ResAssetDefinition>}
     * @memberof ResAsset
     */
    'sdtf'?: Array<ResAssetDefinition>;
    /**
     * The asset-definition of a Model-State image.
     * @type {ResAssetDefinition}
     * @memberof ResAsset
     */
    'modelState'?: ResAssetDefinition;
}
/**
 * Result part for the response to an asset upload request.
 * @export
 * @interface ResAssetDefinition
 */
export interface ResAssetDefinition {
    /**
     * ID of the file to be uploaded.
     * @type {string}
     * @memberof ResAssetDefinition
     */
    'id': string;
    /**
     * href the file should be uploaded to (typically a time-limited pre-signed url).
     * @type {string}
     * @memberof ResAssetDefinition
     */
    'href': string;
    /**
     * 
     * @type {ResAssetUploadHeaders}
     * @memberof ResAssetDefinition
     */
    'headers': ResAssetUploadHeaders;
}
/**
 * HTTP headers to use when uploading an asset to ShapeDiver.
 * @export
 * @interface ResAssetUploadHeaders
 */
export interface ResAssetUploadHeaders {
    /**
     * The value of the Content-Disposition HTTP header.
     * @type {string}
     * @memberof ResAssetUploadHeaders
     */
    'contentDisposition'?: string;
    /**
     * The value of the Content-Type HTTP header.
     * @type {string}
     * @memberof ResAssetUploadHeaders
     */
    'contentType': string;
}
/**
 * 
 * @export
 * @interface ResAuthorizationSettings
 */
export interface ResAuthorizationSettings {
    /**
     * 
     * @type {ResTicketAuthorization}
     * @memberof ResAuthorizationSettings
     */
    'ticket'?: ResTicketAuthorization;
    /**
     * 
     * @type {ResTokenAuthorization}
     * @memberof ResAuthorizationSettings
     */
    'token'?: ResTokenAuthorization;
}
/**
 * 
 * @export
 * @interface ResBase
 */
export interface ResBase {
    /**
     * 
     * @type {ResAsset}
     * @memberof ResBase
     */
    'asset'?: ResAsset;
    /**
     * 
     * @type {ResList}
     * @memberof ResBase
     */
    'list'?: ResList;
    /**
     * 
     * @type {ResModelStateOrData}
     * @memberof ResBase
     */
    'modelState'?: ResModelStateOrData;
    /**
     * 
     * @type {ResSystem}
     * @memberof ResBase
     */
    'system'?: ResSystem;
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResBase
     */
    'actions'?: Array<ResAction>;
    /**
     * Statistics of the model for the given timespan.
     * @type {ResAnalytics}
     * @memberof ResBase
     */
    'analytics'?: ResAnalytics;
    /**
     * The auth-group to use for ticked-based authentication.
     * @type {string}
     * @memberof ResBase
     */
    'auth_group'?: string;
    /**
     * Model cleanup information.
     * @type {Array<ResModelCleanupProcess>}
     * @memberof ResBase
     */
    'cleanup'?: Array<ResModelCleanupProcess>;
    /**
     * Decrypted ticket details.
     * @type {ResTicket}
     * @memberof ResBase
     */
    'decryptedTicket'?: ResTicket;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     * @type {{ [key: string]: ResExportOrDefinition; }}
     * @memberof ResBase
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Links regarding the model file.
     * @type {ResFile}
     * @memberof ResBase
     */
    'file'?: ResFile;
    /**
     * glTF information.
     * @type {ResGltfUpload}
     * @memberof ResBase
     */
    'gltf'?: ResGltfUpload;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResBase
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResBase
     */
    'model'?: ResModel;
    /**
     * Statistics about model computations.
     * @type {Array<ResModelComputation>}
     * @memberof ResBase
     */
    'computations'?: Array<ResModelComputation>;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResBase
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResBase
     */
    'pagination'?: ResPagination;
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     * @type {{ [key: string]: ResParameter; }}
     * @memberof ResBase
     */
    'parameters'?: { [key: string]: ResParameter; };
    /**
     * 
     * @type {ResPlugins}
     * @memberof ResBase
     */
    'plugins'?: ResPlugins;
    /**
     * The ID of the created session.
     * @type {string}
     * @memberof ResBase
     */
    'sessionId'?: string;
    /**
     * Various settings.
     * @type {ResSettings}
     * @memberof ResBase
     */
    'setting'?: ResSettings;
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResBase
     */
    'statistic'?: ResStatistic;
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResBase
     */
    'templates'?: Array<ResTemplate>;
    /**
     * The ticket to create a model session.
     * @type {string}
     * @memberof ResBase
     */
    'ticket'?: string;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResBase
     */
    'version': string;
    /**
     * Viewer specific data.
     * @type {ResViewer}
     * @memberof ResBase
     */
    'viewer'?: ResViewer;
    /**
     * The current version of the viewer settings.
     * @type {string}
     * @memberof ResBase
     */
    'viewerSettingsVersion'?: string;
    /**
     * An array of warnings encountered during request processing. These warnings indicate potential issues or non-critical conditions but did not prevent the request from being successfully processed.
     * @type {Array<string>}
     * @memberof ResBase
     */
    'warnings'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ResBaseAsset
 */
export interface ResBaseAsset {
    /**
     * 
     * @type {ResAsset}
     * @memberof ResBaseAsset
     */
    'asset'?: ResAsset;
}
/**
 * 
 * @export
 * @interface ResBaseCreditMetric
 */
export interface ResBaseCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     * @type {string}
     * @memberof ResBaseCreditMetric
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     * @type {boolean}
     * @memberof ResBaseCreditMetric
     */
    'isCompilationDone': boolean;
    /**
     * 
     * @type {ResArCreditMetric}
     * @memberof ResBaseCreditMetric
     */
    'ar': ResArCreditMetric;
    /**
     * 
     * @type {ResLoadingCreditMetric}
     * @memberof ResBaseCreditMetric
     */
    'loading': ResLoadingCreditMetric;
    /**
     * 
     * @type {ResLimitedCreditMetric}
     * @memberof ResBaseCreditMetric
     */
    'limited': ResLimitedCreditMetric;
    /**
     * 
     * @type {ResDefaultCreditMetric}
     * @memberof ResBaseCreditMetric
     */
    'default': ResDefaultCreditMetric;
}
/**
 * 
 * @export
 * @interface ResBaseList
 */
export interface ResBaseList {
    /**
     * 
     * @type {ResList}
     * @memberof ResBaseList
     */
    'list'?: ResList;
}
/**
 * 
 * @export
 * @interface ResBaseModelState
 */
export interface ResBaseModelState {
    /**
     * 
     * @type {ResModelStateOrData}
     * @memberof ResBaseModelState
     */
    'modelState'?: ResModelStateOrData;
}
/**
 * 
 * @export
 * @interface ResBaseSystem
 */
export interface ResBaseSystem {
    /**
     * 
     * @type {ResSystem}
     * @memberof ResBaseSystem
     */
    'system'?: ResSystem;
}
/**
 * 
 * @export
 * @interface ResCleanupExports
 */
export interface ResCleanupExports {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCleanupExports
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResCleanupOutputs
 */
export interface ResCleanupOutputs {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCleanupOutputs
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResCleanupTextures
 */
export interface ResCleanupTextures {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCleanupTextures
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResCloseSession
 */
export interface ResCloseSession {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCloseSession
     */
    'version': string;
}
/**
 * Information about the components taking most computation time in the model computations log.
 * @export
 * @interface ResComputationComponent
 */
export interface ResComputationComponent {
    /**
     * Components which were computed, ordered by descending processor time.
     * @type {Array<ResComputedComponent>}
     * @memberof ResComputationComponent
     */
    'computed': Array<ResComputedComponent>;
    /**
     * Components which were currently computing at the time the computation was stopped.
     * @type {Array<ResComputingComponent>}
     * @memberof ResComputationComponent
     */
    'computing': Array<ResComputingComponent>;
    /**
     * Component Errors.
     * @type {Array<ResErrorComponent>}
     * @memberof ResComputationComponent
     */
    'errors': Array<ResErrorComponent>;
    /**
     * Component Warnings.
     * @type {Array<ResWarningComponent>}
     * @memberof ResComputationComponent
     */
    'warnings': Array<ResWarningComponent>;
}
/**
 * Information about model computations.
 * @export
 * @interface ResComputationComponents
 */
export interface ResComputationComponents {
    /**
     * 
     * @type {ResComputationComponent}
     * @memberof ResComputationComponents
     */
    'components': ResComputationComponent;
    /**
     * Count of successful computations for the given loaded instance of the model.
     * @type {number}
     * @memberof ResComputationComponents
     */
    'count_success'?: number;
    /**
     * Count of timed-out computations for the given loaded instance of the model.
     * @type {number}
     * @memberof ResComputationComponents
     */
    'count_timeout'?: number;
    /**
     * Lists the ids of the parameters whose values were changed before the computation.
     * @type {Array<string>}
     * @memberof ResComputationComponents
     */
    'changes'?: Array<string>;
}
/**
 * Limits of a model computation process.
 * @export
 * @interface ResComputationLimits
 */
export interface ResComputationLimits {
    /**
     * Maximum computation time in milliseconds allowed for the model.
     * @type {number}
     * @memberof ResComputationLimits
     */
    'max_comp_time': number;
    /**
     * Maximum output size in bytes allowed for the model.
     * @type {number}
     * @memberof ResComputationLimits
     */
    'max_output_size': number;
    /**
     * Maximum export size in bytes allowed for the model.
     * @type {number}
     * @memberof ResComputationLimits
     */
    'max_export_size': number;
}
/**
 * Status of a model computation.
 * @export
 * @enum {string}
 */

export const ResComputationStatus = {
    SUCCESS: 'success',
    TIMEOUT: 'timeout',
    CHECK_CONFIRMED: 'checkconfirmed',
    CHECK_DENIED: 'checkdenied',
    CHECK_PENDING: 'checkpending',
    MAX_COMBINED_ASSET_SIZE_EXCEEDED: 'maxcombinedassetsizeexceeded',
    MAX_DB_SIZE_PER_OUTPUT_EXCEEDED: 'maxdbsizeperoutputexceeded',
    MAX_PARTS_PER_OUTPUT_EXCEEDED: 'maxpartsperoutputexceeded',
    MAX_ASSET_PARTS_PER_OUTPUT_EXCEEDED: 'maxassetpartsperoutputexceeded',
    MAX_TRANSFORMATIONS_PER_OUTPUT_EXCEEDED: 'maxtransformationsperoutputexceeded',
    MAX_PARTS_EXCEEDED: 'maxpartsexceeded',
    MAX_ASSET_PARTS_EXCEEDED: 'maxassetpartsexceeded',
    RECOVERABLE_ERROR: 'recoverableerror',
    UNRECOVERABLE_ERROR: 'unrecoverableerror',
    NO_OUTPUT_DATA_FOR_DEFAULT_PARAMETER_VALUES: 'nooutputdatafordefaultparametervalues',
    MODEL_WITHOUT_GEOMETRY_OUTPUT: 'modelwithoutgeometryoutput',
    UNKNOWN: 'unknown'
} as const;

export type ResComputationStatus = typeof ResComputationStatus[keyof typeof ResComputationStatus];


/**
 * 
 * @export
 * @interface ResComputeExports
 */
export interface ResComputeExports {
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResComputeExports
     */
    'actions'?: Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     * @type {{ [key: string]: ResExportOrDefinition; }}
     * @memberof ResComputeExports
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResComputeExports
     */
    'message'?: string;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResComputeExports
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResComputeExports
     */
    'templates'?: Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResComputeExports
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResComputeOutputs
 */
export interface ResComputeOutputs {
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResComputeOutputs
     */
    'actions'?: Array<ResAction>;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResComputeOutputs
     */
    'message'?: string;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResComputeOutputs
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResComputeOutputs
     */
    'templates'?: Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResComputeOutputs
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResComputeSettings
 */
export interface ResComputeSettings {
    /**
     * Allows to control whether the model\'s Grasshopper file can contain scripts.
     * @type {boolean}
     * @memberof ResComputeSettings
     */
    'deny_scripts': boolean;
    /**
     * File type of the model.
     * @type {string}
     * @memberof ResComputeSettings
     */
    'ftype': string;
    /**
     * Allows to control whether the model should be warmed up immediately after loading by running a computation. This increases the likelihood of following computation requests to be faster.
     * @type {boolean}
     * @memberof ResComputeSettings
     */
    'initial_warmup': boolean;
    /**
     * Maximum number of milliseconds allowed for computations of this model.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'max_comp_time': number;
    /**
     * Maximum number of bytes allowed to be exported from a model for a specific set of parameter values.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'max_export_size': number;
    /**
     * Maximum amount of minutes a loaded model may be unused before it gets unloaded.  Note: Models may get unloaded earlier than that.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'max_idle_minutes': number;
    /**
     * Maximum number of bytes allowed for the model\'s Grasshopper file size.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'max_model_size'?: number;
    /**
     * Maximum number of bytes allowed for an output of a model for a specific set of parameter values.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'max_output_size': number;
    /**
     * Maximum number of bytes allowed for a single texture.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'max_texture_size'?: number;
    /**
     * Maximum time a computation request may stay waiting before a further worker goes ahead regardless of whether it already has the model loaded, and regardless of `num_loaded_max`. This allows to configure a soft or a hard upper boundary for the number of loaded models.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'max_wait_time': number;
    /**
     * Maximum number of workers that should have the model loaded at the same time.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'num_loaded_max': number;
    /**
     * Minimum number of workers that should load the model and keep it open while there is session activity.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'num_loaded_min': number;
    /**
     * Minimum number of workers that should always have the model loaded, regardless of session activity. This allows to minimise the likelihood of computation requests being slower due to model loading.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'num_preloaded_min': number;
    /**
     * Limits the number of sessions that can be created by a specific IP address in one hour.
     * @type {number}
     * @memberof ResComputeSettings
     */
    'session_rate_limit'?: number;
    /**
     * Controls whether failed computations will be retried.
     * @type {string}
     * @memberof ResComputeSettings
     */
    'trust': string;
}
/**
 * 
 * @export
 * @interface ResComputedComponent
 */
export interface ResComputedComponent {
    /**
     * Instance ID of component.
     * @type {string}
     * @memberof ResComputedComponent
     */
    'instance': string;
    /**
     * ID of the component.
     * @type {string}
     * @memberof ResComputedComponent
     */
    'component': string;
    /**
     * Name of component.
     * @type {string}
     * @memberof ResComputedComponent
     */
    'name': string;
    /**
     * Nickname of component.
     * @type {string}
     * @memberof ResComputedComponent
     */
    'nick_name': string;
    /**
     * Computation time used.
     * @type {number}
     * @memberof ResComputedComponent
     */
    'time': number;
}
/**
 * 
 * @export
 * @interface ResComputingComponent
 */
export interface ResComputingComponent {
    /**
     * Instance ID of component.
     * @type {string}
     * @memberof ResComputingComponent
     */
    'instance': string;
    /**
     * ID of component.
     * @type {string}
     * @memberof ResComputingComponent
     */
    'component': string;
    /**
     * Name of component.
     * @type {string}
     * @memberof ResComputingComponent
     */
    'name': string;
    /**
     * Nickname of component.
     * @type {string}
     * @memberof ResComputingComponent
     */
    'nick_name': string;
}
/**
 * 
 * @export
 * @interface ResCreateAuthorizationGroup
 */
export interface ResCreateAuthorizationGroup {
    /**
     * The auth-group to use for ticked-based authentication.
     * @type {string}
     * @memberof ResCreateAuthorizationGroup
     */
    'auth_group': string;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResCreateAuthorizationGroup
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCreateAuthorizationGroup
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResCreateModel
 */
export interface ResCreateModel {
    /**
     * Links regarding the model file.
     * @type {ResFile}
     * @memberof ResCreateModel
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResCreateModel
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResCreateModel
     */
    'model': ResModel;
    /**
     * Various settings.
     * @type {ResSettings}
     * @memberof ResCreateModel
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResCreateModel
     */
    'statistic': ResStatistic;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCreateModel
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResCreateModelConfig
 */
export interface ResCreateModelConfig {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCreateModelConfig
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResCreateModelState
 */
export interface ResCreateModelState {
    /**
     * Model-State information.
     * @type {ResModelState}
     * @memberof ResCreateModelState
     */
    'modelState': ResModelState;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCreateModelState
     */
    'version': string;
    /**
     * 
     * @type {ResModelStateAsset}
     * @memberof ResCreateModelState
     */
    'asset'?: ResModelStateAsset;
}
/**
 * 
 * @export
 * @interface ResCreateSessionByModel
 */
export interface ResCreateSessionByModel {
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResCreateSessionByModel
     */
    'actions': Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     * @type {{ [key: string]: ResExportOrDefinition; }}
     * @memberof ResCreateSessionByModel
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Links regarding the model file.
     * @type {ResFile}
     * @memberof ResCreateSessionByModel
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResCreateSessionByModel
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResCreateSessionByModel
     */
    'model': ResModel;
    /**
     * Model-State information.
     * @type {ResModelStateData}
     * @memberof ResCreateSessionByModel
     */
    'modelState'?: ResModelStateData;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResCreateSessionByModel
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     * @type {{ [key: string]: ResParameter; }}
     * @memberof ResCreateSessionByModel
     */
    'parameters'?: { [key: string]: ResParameter; };
    /**
     * The ID of the created session.
     * @type {string}
     * @memberof ResCreateSessionByModel
     */
    'sessionId': string;
    /**
     * Various settings.
     * @type {ResSettings}
     * @memberof ResCreateSessionByModel
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResCreateSessionByModel
     */
    'statistic': ResStatistic;
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResCreateSessionByModel
     */
    'templates': Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCreateSessionByModel
     */
    'version': string;
    /**
     * Viewer specific data.
     * @type {ResViewer}
     * @memberof ResCreateSessionByModel
     */
    'viewer': ResViewer;
    /**
     * The current version of the viewer settings.
     * @type {string}
     * @memberof ResCreateSessionByModel
     */
    'viewerSettingsVersion': string;
    /**
     * An array of warnings encountered during request processing. These warnings indicate potential issues or non-critical conditions but did not prevent the request from being successfully processed.
     * @type {Array<string>}
     * @memberof ResCreateSessionByModel
     */
    'warnings'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ResCreateSessionByTicket
 */
export interface ResCreateSessionByTicket {
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResCreateSessionByTicket
     */
    'actions': Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     * @type {{ [key: string]: ResExportOrDefinition; }}
     * @memberof ResCreateSessionByTicket
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Links regarding the model file.
     * @type {ResFile}
     * @memberof ResCreateSessionByTicket
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResCreateSessionByTicket
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResCreateSessionByTicket
     */
    'model': ResModel;
    /**
     * Model-State information.
     * @type {ResModelStateData}
     * @memberof ResCreateSessionByTicket
     */
    'modelState'?: ResModelStateData;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResCreateSessionByTicket
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     * @type {{ [key: string]: ResParameter; }}
     * @memberof ResCreateSessionByTicket
     */
    'parameters'?: { [key: string]: ResParameter; };
    /**
     * The ID of the created session.
     * @type {string}
     * @memberof ResCreateSessionByTicket
     */
    'sessionId': string;
    /**
     * Various settings.
     * @type {ResSettings}
     * @memberof ResCreateSessionByTicket
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResCreateSessionByTicket
     */
    'statistic': ResStatistic;
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResCreateSessionByTicket
     */
    'templates': Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCreateSessionByTicket
     */
    'version': string;
    /**
     * Viewer specific data.
     * @type {ResViewer}
     * @memberof ResCreateSessionByTicket
     */
    'viewer': ResViewer;
    /**
     * The current version of the viewer settings.
     * @type {string}
     * @memberof ResCreateSessionByTicket
     */
    'viewerSettingsVersion': string;
    /**
     * An array of warnings encountered during request processing. These warnings indicate potential issues or non-critical conditions but did not prevent the request from being successfully processed.
     * @type {Array<string>}
     * @memberof ResCreateSessionByTicket
     */
    'warnings'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ResCreateTicket
 */
export interface ResCreateTicket {
    /**
     * Links regarding the model file.
     * @type {ResFile}
     * @memberof ResCreateTicket
     */
    'file': ResFile;
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResCreateTicket
     */
    'model': ResModel;
    /**
     * Various settings.
     * @type {ResSettings}
     * @memberof ResCreateTicket
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResCreateTicket
     */
    'statistic': ResStatistic;
    /**
     * The ticket to create a model session.
     * @type {string}
     * @memberof ResCreateTicket
     */
    'ticket': string;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResCreateTicket
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResDecryptTicket
 */
export interface ResDecryptTicket {
    /**
     * Decrypted ticket details.
     * @type {ResTicket}
     * @memberof ResDecryptTicket
     */
    'decryptedTicket': ResTicket;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResDecryptTicket
     */
    'version': string;
}
/**
 * Combined output and export requests.
 * @export
 * @interface ResDefaultCombinedMetric
 */
export interface ResDefaultCombinedMetric {
    /**
     * Number of combined output and export requests charged.
     * @type {number}
     * @memberof ResDefaultCombinedMetric
     */
    'credits': number;
}
/**
 * Computations information.
 * @export
 * @interface ResDefaultComputationMetric
 */
export interface ResDefaultComputationMetric {
    /**
     * Number of computations.
     * @type {number}
     * @memberof ResDefaultComputationMetric
     */
    'count': number;
    /**
     * Number of finished 10-second chunks charged.
     * @type {number}
     * @memberof ResDefaultComputationMetric
     */
    'credits': number;
    /**
     * Total duration of computation time, in milliseconds.
     * @type {number}
     * @memberof ResDefaultComputationMetric
     */
    'duration': number;
    /**
     * Count of computations per computation time expressed in started 10-second chunks.
     * @type {{ [key: string]: number; }}
     * @memberof ResDefaultComputationMetric
     */
    'countPerChunks': { [key: string]: number; };
}
/**
 * Aggregated metrics for \'default\' sessions.
 * @export
 * @interface ResDefaultCreditMetric
 */
export interface ResDefaultCreditMetric {
    /**
     * 
     * @type {ResDefaultOutputMetric}
     * @memberof ResDefaultCreditMetric
     */
    'outputs': ResDefaultOutputMetric;
    /**
     * 
     * @type {ResDefaultExportMetric}
     * @memberof ResDefaultCreditMetric
     */
    'exports': ResDefaultExportMetric;
    /**
     * 
     * @type {ResDefaultCombinedMetric}
     * @memberof ResDefaultCreditMetric
     */
    'combined': ResDefaultCombinedMetric;
    /**
     * 
     * @type {ResDefaultSessionMetric}
     * @memberof ResDefaultCreditMetric
     */
    'sessions': ResDefaultSessionMetric;
    /**
     * 
     * @type {ResDefaultComputationMetric}
     * @memberof ResDefaultCreditMetric
     */
    'computations': ResDefaultComputationMetric;
}
/**
 * Pure export requests.
 * @export
 * @interface ResDefaultExportMetric
 */
export interface ResDefaultExportMetric {
    /**
     * Number of pure export requests charged.
     * @type {number}
     * @memberof ResDefaultExportMetric
     */
    'credits': number;
}
/**
 * Pure output requests.
 * @export
 * @interface ResDefaultOutputMetric
 */
export interface ResDefaultOutputMetric {
    /**
     * Number of pure output requests charged.
     * @type {number}
     * @memberof ResDefaultOutputMetric
     */
    'credits': number;
}
/**
 * Session information.
 * @export
 * @interface ResDefaultSessionMetric
 */
export interface ResDefaultSessionMetric {
    /**
     * Number of sessions.
     * @type {number}
     * @memberof ResDefaultSessionMetric
     */
    'count': number;
    /**
     * The total duration of all sessions, in milliseconds.
     * @type {number}
     * @memberof ResDefaultSessionMetric
     */
    'duration': number;
}
/**
 * 
 * @export
 * @interface ResDeleteFile
 */
export interface ResDeleteFile {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResDeleteFile
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResDeleteModel
 */
export interface ResDeleteModel {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResDeleteModel
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResDeleteModelState
 */
export interface ResDeleteModelState {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResDeleteModelState
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResDeleteSdtf
 */
export interface ResDeleteSdtf {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResDeleteSdtf
     */
    'version': string;
}
/**
 * Body of an error object.
 * @export
 * @interface ResError
 */
export interface ResError {
    /**
     * The type of the error.
     * @type {ResErrorType}
     * @memberof ResError
     */
    'error': ResErrorType;
    /**
     * General description of the error type.
     * @type {string}
     * @memberof ResError
     */
    'desc': string;
    /**
     * Detailed error description.
     * @type {string}
     * @memberof ResError
     */
    'message'?: string;
}


/**
 * 
 * @export
 * @interface ResErrorComponent
 */
export interface ResErrorComponent {
    /**
     * ID of component.
     * @type {string}
     * @memberof ResErrorComponent
     */
    'component': string;
    /**
     * Component Error descriptions.
     * @type {Array<string>}
     * @memberof ResErrorComponent
     */
    'errors': Array<string>;
    /**
     * Instance ID of component.
     * @type {string}
     * @memberof ResErrorComponent
     */
    'instance': string;
    /**
     * Name of component.
     * @type {string}
     * @memberof ResErrorComponent
     */
    'name': string;
    /**
     * Nickname of component.
     * @type {string}
     * @memberof ResErrorComponent
     */
    'nick_name': string;
    /**
     * Component Warnings descriptions.
     * @type {Array<string>}
     * @memberof ResErrorComponent
     */
    'warnings': Array<string>;
}
/**
 * Possible error types.
 * @export
 * @enum {string}
 */

export const ResErrorType = {
    ASSERTION_ERROR: 'SdAssertionError',
    CACHE_ERROR_GENERIC: 'SdCacheErrorGeneric',
    CONNECTOR_ERROR: 'SdConnectorError',
    DATABASE_ERROR_GENERIC: 'SdDatabaseErrorGeneric',
    EMAILING_ERROR: 'SdEmailingError',
    ERROR_ENTITY_NOT_FOUND: 'SdErrorEntityNotFound',
    ERROR_FORBIDDEN: 'SdErrorForbidden',
    ERROR_GENERIC_CLIENT: 'SdErrorGenericClient',
    ERROR_GENERIC_INTERNAL: 'SdErrorGenericInternal',
    ERROR_UNAUTHORIZED: 'SdErrorUnauthorized',
    ILLEGAL_ARGUMENT_ERROR: 'SdIllegalArgumentError',
    JWT_VALIDATION_ERROR: 'SdJwtValidationError',
    METHOD_NOT_ALLOWED_ERROR: 'SdMethodNotAllowedError',
    MODEL_VALIDATION_ERROR: 'SdModelValidationError',
    NOT_ACCEPTABLE: 'SdNotAcceptable',
    NOT_FOUND_ERROR: 'SdNotFoundError',
    PARAMETER_VALIDATION_ERROR: 'SdParameterValidationError',
    RATE_LIMIT_ERROR_GENERIC: 'SdRateLimitErrorGeneric',
    REQUEST_TIMEOUT: 'SdRequestTimeout',
    REQUEST_VALIDATION_ERROR: 'SdRequestValidationError',
    RESOURCE_GONE_ERROR: 'SdResourceGoneError',
    SESSION_GONE_ERROR: 'SdSessionGoneError',
    SESSION_VALIDATION_ERROR: 'SdSessionValidationError',
    STORAGE_ERROR_GENERIC: 'SdStorageErrorGeneric',
    TEXTURE_URL_ERROR: 'SdTextureUrlError',
    TICKET_VALIDATION_ERROR: 'SdTicketValidationError',
    TOKEN_MISSING_ERROR: 'SdTokenMissingError',
    TRANSFORM_CONTENT_ARRAY_ERROR: 'SdTransformContentArrayError',
    UNCONFIRMED_MODEL_ERROR: 'SdUnconfirmedModelError',
    UNKNOWN: ''
} as const;

export type ResErrorType = typeof ResErrorType[keyof typeof ResErrorType];


/**
 * Export definition WITH results as exposed on the API.
 * @export
 * @interface ResExport
 */
export interface ResExport {
    /**
     * ID of the export, dependent on model ID, and therefore changing each time a model gets uploaded.
     * @type {string}
     * @memberof ResExport
     */
    'id': string;
    /**
     * Constant ID of the export, not dependent on model ID, and therefore NOT changing each time a model gets uploaded. Might be undefined because this property was introduced in summer 2020 and does not exist for exports of older models.
     * @type {string}
     * @memberof ResExport
     */
    'uid'?: string;
    /**
     * Name of the export.
     * @type {string}
     * @memberof ResExport
     */
    'name': string;
    /**
     * Type of export.
     * @type {ResExportDefinitionType}
     * @memberof ResExport
     */
    'type': ResExportDefinitionType;
    /**
     * List of IDs of parameters influencing this export.
     * @type {Array<string>}
     * @memberof ResExport
     */
    'dependency': Array<string>;
    /**
     * 
     * @type {ResExportDefinitionGroup}
     * @memberof ResExport
     */
    'group'?: ResExportDefinitionGroup;
    /**
     * Ordering of the export in client applications.
     * @type {number}
     * @memberof ResExport
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ResExport
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     * @type {string}
     * @memberof ResExport
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     * @type {boolean}
     * @memberof ResExport
     */
    'hidden': boolean;
    /**
     * Requested version of the export.
     * @type {string}
     * @memberof ResExport
     */
    'version': string;
    /**
     * The delay in milliseconds after which an export cache request shall be sent to check again for this export version. This property is used ONLY if the export version has not been computed yet.  Note that the existence of this property does not necessarily imply the presence of an active or queued computation for the respective export version.
     * @type {number}
     * @memberof ResExport
     */
    'delay'?: number;
    /**
     * Result parts. In case this array does not exist, this means that the workers have not finished computation for this output version.
     * @type {Array<ResExportContent>}
     * @memberof ResExport
     */
    'content'?: Array<ResExportContent>;
    /**
     * In case computation of the export version (temporarily) failed. Contains a message explaining what went wrong.
     * @type {string}
     * @memberof ResExport
     */
    'msg'?: string;
    /**
     * Optional suggested filename for the files to be downloaded.
     * @type {string}
     * @memberof ResExport
     */
    'filename'?: string;
    /**
     * 
     * @type {ResExportResult}
     * @memberof ResExport
     */
    'result'?: ResExportResult;
    /**
     * Status of the computation which resulted in the export version.
     * @type {ResComputationStatus}
     * @memberof ResExport
     */
    'status_computation'?: ResComputationStatus;
    /**
     * Status of collecting results for the export version.
     * @type {ResComputationStatus}
     * @memberof ResExport
     */
    'status_collect'?: ResComputationStatus;
}


/**
 * An item of the `content` array for exports.
 * @export
 * @interface ResExportContent
 */
export interface ResExportContent {
    /**
     * Format of export result (file extension).
     * @type {string}
     * @memberof ResExportContent
     */
    'format': string;
    /**
     * Link for download of exported asset.
     * @type {string}
     * @memberof ResExportContent
     */
    'href': string;
    /**
     * Optional size of exported asset, in bytes.
     * @type {number}
     * @memberof ResExportContent
     */
    'size'?: number;
    /**
     * Optional Content-Type for parts of type `asset`.
     * @type {string}
     * @memberof ResExportContent
     */
    'contentType'?: string;
}
/**
 * Export definition WITHOUT results as exposed on the API.
 * @export
 * @interface ResExportDefinition
 */
export interface ResExportDefinition {
    /**
     * ID of the export, dependent on model ID, and therefore changing each time a model gets uploaded.
     * @type {string}
     * @memberof ResExportDefinition
     */
    'id': string;
    /**
     * Constant ID of the export, not dependent on model ID, and therefore NOT changing each time a model gets uploaded. Might be undefined because this property was introduced in summer 2020 and does not exist for exports of older models.
     * @type {string}
     * @memberof ResExportDefinition
     */
    'uid'?: string;
    /**
     * Name of the export.
     * @type {string}
     * @memberof ResExportDefinition
     */
    'name': string;
    /**
     * Type of export.
     * @type {ResExportDefinitionType}
     * @memberof ResExportDefinition
     */
    'type': ResExportDefinitionType;
    /**
     * List of IDs of parameters influencing this export.
     * @type {Array<string>}
     * @memberof ResExportDefinition
     */
    'dependency': Array<string>;
    /**
     * 
     * @type {ResExportDefinitionGroup}
     * @memberof ResExportDefinition
     */
    'group'?: ResExportDefinitionGroup;
    /**
     * Ordering of the export in client applications.
     * @type {number}
     * @memberof ResExportDefinition
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ResExportDefinition
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     * @type {string}
     * @memberof ResExportDefinition
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     * @type {boolean}
     * @memberof ResExportDefinition
     */
    'hidden': boolean;
    /**
     * This property is never set.
     * @type {boolean}
     * @memberof ResExportDefinition
     * @deprecated
     */
    'version'?: boolean | null;
}


/**
 * 
 * @export
 * @interface ResExportDefinitionGroup
 */
export interface ResExportDefinitionGroup {
    /**
     * 
     * @type {string}
     * @memberof ResExportDefinitionGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResExportDefinitionGroup
     */
    'name': string;
}
/**
 * Types of exports.
 * @export
 * @enum {string}
 */

export const ResExportDefinitionType = {
    UNKNOWN: 'unknown',
    DOWNLOAD: 'download',
    EMAIL: 'email',
    SHAPEWAYS: 'shapeways'
} as const;

export type ResExportDefinitionType = typeof ResExportDefinitionType[keyof typeof ResExportDefinitionType];


/**
 * 
 * @export
 * @interface ResExportList
 */
export interface ResExportList {
    /**
     * A directory of file objects.
     * @type {Array<ResFileInfo>}
     * @memberof ResExportList
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     * @type {Array<ResSdtfInfo>}
     * @memberof ResExportList
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     * @type {Array<ResModel>}
     * @memberof ResExportList
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     * @type {Array<ResModelStateInfo>}
     * @memberof ResExportList
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     * @type {Array<ResOutput>}
     * @memberof ResExportList
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     * @type {Array<ResExport>}
     * @memberof ResExportList
     */
    'export': Array<ResExport>;
    /**
     * A directory of model textures.
     * @type {Array<ResTexture>}
     * @memberof ResExportList
     */
    'texture'?: Array<ResTexture>;
}
/**
 * @type ResExportOrDefinition
 * Either a full export or it\'s definition.
 * @export
 */
export type ResExportOrDefinition = ResExport | ResExportDefinition;

/**
 * Optional result object for exports of type `email` and `shapeways`.
 * @export
 * @interface ResExportResult
 */
export interface ResExportResult {
    /**
     * Optional success message for user.
     * @type {string}
     * @memberof ResExportResult
     */
    'msg'?: string;
    /**
     * Optional error message for user.
     * @type {string}
     * @memberof ResExportResult
     */
    'err'?: string;
    /**
     * Optional href to redirect user to for download.
     * @type {string}
     * @memberof ResExportResult
     */
    'href'?: string;
    /**
     * Optional shapeways model ID.
     * @type {string}
     * @memberof ResExportResult
     */
    'modelId'?: string;
}
/**
 * Definitions of a model file.
 * @export
 * @interface ResFile
 */
export interface ResFile {
    /**
     * URL to upload a model file.
     * @type {string}
     * @memberof ResFile
     */
    'upload'?: string;
    /**
     * URL to download a model file.
     * @type {string}
     * @memberof ResFile
     */
    'download'?: string;
}
/**
 * File assets.
 * @export
 * @interface ResFileAsset
 */
export interface ResFileAsset {
    /**
     * A directory of parameter-IDs and asset-definitions.
     * @type {{ [key: string]: ResAssetDefinition; }}
     * @memberof ResFileAsset
     */
    'file': { [key: string]: ResAssetDefinition; };
    /**
     * 
     * @type {Array<ResAssetDefinition>}
     * @memberof ResFileAsset
     */
    'sdtf'?: Array<ResAssetDefinition>;
    /**
     * The asset-definition of a Model-State image.
     * @type {ResAssetDefinition}
     * @memberof ResFileAsset
     */
    'modelState'?: ResAssetDefinition;
}
/**
 * Result part for the response to a list request for file objects.
 * @export
 * @interface ResFileInfo
 */
export interface ResFileInfo {
    /**
     * ID of the file.
     * @type {string}
     * @memberof ResFileInfo
     */
    'id': string;
    /**
     * ID of the parameter that the file is assigned to.
     * @type {string}
     * @memberof ResFileInfo
     */
    'parameterId': string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof ResFileInfo
     */
    'size': number;
    /**
     * The name of the file, when specified during the upload.
     * @type {string}
     * @memberof ResFileInfo
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface ResFileList
 */
export interface ResFileList {
    /**
     * A directory of file objects.
     * @type {Array<ResFileInfo>}
     * @memberof ResFileList
     */
    'file': Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     * @type {Array<ResSdtfInfo>}
     * @memberof ResFileList
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     * @type {Array<ResModel>}
     * @memberof ResFileList
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     * @type {Array<ResModelStateInfo>}
     * @memberof ResFileList
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     * @type {Array<ResOutput>}
     * @memberof ResFileList
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     * @type {Array<ResExport>}
     * @memberof ResFileList
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     * @type {Array<ResTexture>}
     * @memberof ResFileList
     */
    'texture'?: Array<ResTexture>;
}
/**
 * 
 * @export
 * @interface ResGetCachedExports
 */
export interface ResGetCachedExports {
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResGetCachedExports
     */
    'actions'?: Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     * @type {{ [key: string]: ResExportOrDefinition; }}
     * @memberof ResGetCachedExports
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResGetCachedExports
     */
    'message'?: string;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResGetCachedExports
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResGetCachedExports
     */
    'templates'?: Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetCachedExports
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetCachedOutputs
 */
export interface ResGetCachedOutputs {
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResGetCachedOutputs
     */
    'actions'?: Array<ResAction>;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResGetCachedOutputs
     */
    'message'?: string;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResGetCachedOutputs
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResGetCachedOutputs
     */
    'templates'?: Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetCachedOutputs
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetCleanupStatus
 */
export interface ResGetCleanupStatus {
    /**
     * Model cleanup information.
     * @type {Array<ResModelCleanupProcess>}
     * @memberof ResGetCleanupStatus
     */
    'cleanup': Array<ResModelCleanupProcess>;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetCleanupStatus
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetCreditMetrics
 */
export interface ResGetCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     * @type {ResAnalytics}
     * @memberof ResGetCreditMetrics
     */
    'analytics': ResAnalytics;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResGetCreditMetrics
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetCreditMetrics
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetMinionsInfo
 */
export interface ResGetMinionsInfo {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetMinionsInfo
     */
    'version': string;
    /**
     * 
     * @type {ResMinionSystem}
     * @memberof ResGetMinionsInfo
     */
    'system': ResMinionSystem;
}
/**
 * 
 * @export
 * @interface ResGetModel
 */
export interface ResGetModel {
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     * @type {{ [key: string]: ResExportOrDefinition; }}
     * @memberof ResGetModel
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Links regarding the model file.
     * @type {ResFile}
     * @memberof ResGetModel
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResGetModel
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResGetModel
     */
    'model': ResModel;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResGetModel
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     * @type {{ [key: string]: ResParameter; }}
     * @memberof ResGetModel
     */
    'parameters'?: { [key: string]: ResParameter; };
    /**
     * 
     * @type {ResPlugins}
     * @memberof ResGetModel
     */
    'plugins'?: ResPlugins;
    /**
     * Various settings.
     * @type {ResSettings}
     * @memberof ResGetModel
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResGetModel
     */
    'statistic': ResStatistic;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetModel
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetModelComputations
 */
export interface ResGetModelComputations {
    /**
     * Statistics about model computations.
     * @type {Array<ResModelComputation>}
     * @memberof ResGetModelComputations
     */
    'computations': Array<ResModelComputation>;
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResGetModelComputations
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetModelComputations
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetModelConfig
 */
export interface ResGetModelConfig {
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResGetModelConfig
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetModelConfig
     */
    'version': string;
    /**
     * Viewer specific data.
     * @type {ResViewer}
     * @memberof ResGetModelConfig
     */
    'viewer': ResViewer;
}
/**
 * 
 * @export
 * @interface ResGetModelOrganizationCreditMetrics
 */
export interface ResGetModelOrganizationCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     * @type {ResAnalytics}
     * @memberof ResGetModelOrganizationCreditMetrics
     */
    'analytics': ResAnalytics;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetModelOrganizationCreditMetrics
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetModelState
 */
export interface ResGetModelState {
    /**
     * Model-State information.
     * @type {ResModelState}
     * @memberof ResGetModelState
     */
    'modelState': ResModelState;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetModelState
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetModelStateData
 */
export interface ResGetModelStateData {
    /**
     * Model-State information.
     * @type {ResModelStateData}
     * @memberof ResGetModelStateData
     */
    'modelState': ResModelStateData;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetModelStateData
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetModelStatistics
 */
export interface ResGetModelStatistics {
    /**
     * Statistics of the model for the given timespan.
     * @type {ResAnalytics}
     * @memberof ResGetModelStatistics
     */
    'analytics': ResAnalytics;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResGetModelStatistics
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetModelStatistics
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetModelUserCreditMetrics
 */
export interface ResGetModelUserCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     * @type {ResAnalytics}
     * @memberof ResGetModelUserCreditMetrics
     */
    'analytics': ResAnalytics;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetModelUserCreditMetrics
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetOrganizationCreditMetrics
 */
export interface ResGetOrganizationCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     * @type {ResAnalytics}
     * @memberof ResGetOrganizationCreditMetrics
     */
    'analytics': ResAnalytics;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetOrganizationCreditMetrics
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetSessionDefaults
 */
export interface ResGetSessionDefaults {
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResGetSessionDefaults
     */
    'actions': Array<ResAction>;
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     * @type {{ [key: string]: ResExportOrDefinition; }}
     * @memberof ResGetSessionDefaults
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResGetSessionDefaults
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResGetSessionDefaults
     */
    'model': ResModel;
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResGetSessionDefaults
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     * @type {{ [key: string]: ResParameter; }}
     * @memberof ResGetSessionDefaults
     */
    'parameters'?: { [key: string]: ResParameter; };
    /**
     * The ID of the created session.
     * @type {string}
     * @memberof ResGetSessionDefaults
     */
    'sessionId': string;
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResGetSessionDefaults
     */
    'statistic': ResStatistic;
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResGetSessionDefaults
     */
    'templates': Array<ResTemplate>;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetSessionDefaults
     */
    'version': string;
    /**
     * Viewer specific data.
     * @type {ResViewer}
     * @memberof ResGetSessionDefaults
     */
    'viewer': ResViewer;
    /**
     * The current version of the viewer settings.
     * @type {string}
     * @memberof ResGetSessionDefaults
     */
    'viewerSettingsVersion': string;
}
/**
 * 
 * @export
 * @interface ResGetUserCreditMetrics
 */
export interface ResGetUserCreditMetrics {
    /**
     * Statistics of the model for the given timespan.
     * @type {ResAnalytics}
     * @memberof ResGetUserCreditMetrics
     */
    'analytics': ResAnalytics;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetUserCreditMetrics
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResGetWorkersInfo
 */
export interface ResGetWorkersInfo {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResGetWorkersInfo
     */
    'version': string;
    /**
     * 
     * @type {ResWorkerSystem}
     * @memberof ResGetWorkersInfo
     */
    'system': ResWorkerSystem;
}
/**
 * Information about uploaded glTF object.
 * @export
 * @interface ResGltfUpload
 */
export interface ResGltfUpload {
    /**
     * The URL to download the glTF file.
     * @type {string}
     * @memberof ResGltfUpload
     */
    'href': string;
    /**
     * Contains the unique ID of the uploaded scene. Only present for uploads with the conversion type `scene`.
     * @type {string}
     * @memberof ResGltfUpload
     */
    'sceneId'?: string;
}
/**
 * Contains information about all installed Grasshopper plugins.
 * @export
 * @interface ResInstalledWorkerPlugin
 */
export interface ResInstalledWorkerPlugin {
    /**
     * ID of the Grasshopper plugin.
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'id': string;
    /**
     * Name of the Grasshopper plugin.
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'name': string;
    /**
     * Version of the Grasshopper plugin.
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'version': string;
    /**
     * Name of the plugin author.
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'authorName': string;
    /**
     * Contact information of the plugin author (homepage URL, email address, etc.).
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'authorContact': string;
    /**
     * General description of the Grasshopper plugin.
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'description': string;
    /**
     * Assembly version of the Grasshopper plugin DLL.  See the [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assemblyname.version?view=net-8.0) for more information.
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'assemblyVersion': string;
    /**
     * Full assembly name of the Grasshopper plugin DLL.  See the [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assembly.fullname?view=net-8.0) for more information.
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'assemblyFullName': string;
    /**
     * Gets whether this library is a Grasshopper core library. Core libraries are installed along with Grasshopper and thus should always be available anywhere.
     * @type {boolean}
     * @memberof ResInstalledWorkerPlugin
     */
    'isCoreLibrary': boolean;
    /**
     * The license type of the plugin.  See the [documentation](https://developer.rhino3d.com/api/grasshopper/html/T_Grasshopper_Kernel_GH_LibraryLicense.htm) for more information.
     * @type {number}
     * @memberof ResInstalledWorkerPlugin
     */
    'license': number;
    /**
     * The mechanism used to load the plugin.  See the [documentation](https://developer.rhino3d.com/api/grasshopper/html/T_Grasshopper_Kernel_GH_LoadingMechanism.htm) for more information.
     * @type {number}
     * @memberof ResInstalledWorkerPlugin
     */
    'loadingMechanism': number;
    /**
     * Installation path of the Grasshopper plugin.
     * @type {string}
     * @memberof ResInstalledWorkerPlugin
     */
    'location': string;
}
/**
 * Aggregated metrics for \'rate-limited timeslot\' sessions.
 * @export
 * @interface ResLimitedCreditMetric
 */
export interface ResLimitedCreditMetric {
    /**
     * 
     * @type {ResRateLimitedOutputMetric}
     * @memberof ResLimitedCreditMetric
     */
    'outputs': ResRateLimitedOutputMetric;
    /**
     * 
     * @type {ResRateLimitedExportMetric}
     * @memberof ResLimitedCreditMetric
     */
    'exports': ResRateLimitedExportMetric;
    /**
     * 
     * @type {ResRateLimitedCombinedMetric}
     * @memberof ResLimitedCreditMetric
     */
    'combined': ResRateLimitedCombinedMetric;
    /**
     * 
     * @type {ResRateLimitedSessionMetric}
     * @memberof ResLimitedCreditMetric
     */
    'sessions': ResRateLimitedSessionMetric;
    /**
     * 
     * @type {ResRateLimitedComputationMetric}
     * @memberof ResLimitedCreditMetric
     */
    'computations': ResRateLimitedComputationMetric;
}
/**
 * ShapeDiver API response of a list-request.
 * @export
 * @interface ResList
 */
export interface ResList {
    /**
     * A directory of file objects.
     * @type {Array<ResFileInfo>}
     * @memberof ResList
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     * @type {Array<ResSdtfInfo>}
     * @memberof ResList
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     * @type {Array<ResModel>}
     * @memberof ResList
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     * @type {Array<ResModelStateInfo>}
     * @memberof ResList
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     * @type {Array<ResOutput>}
     * @memberof ResList
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     * @type {Array<ResExport>}
     * @memberof ResList
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     * @type {Array<ResTexture>}
     * @memberof ResList
     */
    'texture'?: Array<ResTexture>;
}
/**
 * 
 * @export
 * @interface ResListExportVersions
 */
export interface ResListExportVersions {
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResListExportVersions
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResListExportVersions
     */
    'version': string;
    /**
     * 
     * @type {ResExportList}
     * @memberof ResListExportVersions
     */
    'list': ResExportList;
}
/**
 * 
 * @export
 * @interface ResListFiles
 */
export interface ResListFiles {
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResListFiles
     */
    'message'?: string;
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResListFiles
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResListFiles
     */
    'version': string;
    /**
     * 
     * @type {ResFileList}
     * @memberof ResListFiles
     */
    'list': ResFileList;
}
/**
 * 
 * @export
 * @interface ResListModelStates
 */
export interface ResListModelStates {
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResListModelStates
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResListModelStates
     */
    'version': string;
    /**
     * 
     * @type {ResModelStateList}
     * @memberof ResListModelStates
     */
    'list': ResModelStateList;
}
/**
 * 
 * @export
 * @interface ResListModels
 */
export interface ResListModels {
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResListModels
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResListModels
     */
    'version': string;
    /**
     * 
     * @type {ResModelList}
     * @memberof ResListModels
     */
    'list': ResModelList;
}
/**
 * 
 * @export
 * @interface ResListOutputVersions
 */
export interface ResListOutputVersions {
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResListOutputVersions
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResListOutputVersions
     */
    'version': string;
    /**
     * 
     * @type {ResOutputList}
     * @memberof ResListOutputVersions
     */
    'list': ResOutputList;
}
/**
 * 
 * @export
 * @interface ResListSdtfs
 */
export interface ResListSdtfs {
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResListSdtfs
     */
    'message'?: string;
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResListSdtfs
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResListSdtfs
     */
    'version': string;
    /**
     * 
     * @type {ResSdtfList}
     * @memberof ResListSdtfs
     */
    'list': ResSdtfList;
}
/**
 * 
 * @export
 * @interface ResListTextures
 */
export interface ResListTextures {
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResListTextures
     */
    'pagination': ResPagination;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResListTextures
     */
    'version': string;
    /**
     * 
     * @type {ResTextureList}
     * @memberof ResListTextures
     */
    'list': ResTextureList;
}
/**
 * Information about loading times on the Geometry Workers.
 * @export
 * @interface ResLoadingCreditMetric
 */
export interface ResLoadingCreditMetric {
    /**
     * Number of started 10-second chunks charged.
     * @type {number}
     * @memberof ResLoadingCreditMetric
     */
    'credits': number;
    /**
     * Number of load requests.
     * @type {number}
     * @memberof ResLoadingCreditMetric
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ResLogMessage
 */
export interface ResLogMessage {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResLogMessage
     */
    'version': string;
}
/**
 * Holds system information of all currently running Geometry Minion services.
 * @export
 * @interface ResMinionInfo
 */
export interface ResMinionInfo {
    /**
     * Information per instance. A directory of process-IDs and process data.
     * @type {{ [key: string]: ResMinionProcess; }}
     * @memberof ResMinionInfo
     */
    'instances': { [key: string]: ResMinionProcess; };
    /**
     * Aggregated task information. A directory of task types and task data.
     * @type {{ [key: string]: ResMinionTask; }}
     * @memberof ResMinionInfo
     */
    'tasks': { [key: string]: ResMinionTask; };
}
/**
 * System information a single Geometry Minions process.
 * @export
 * @interface ResMinionProcess
 */
export interface ResMinionProcess {
    /**
     * Information about completed tasks, listed per task type.
     * @type {{ [key: string]: ResMinionTask; }}
     * @memberof ResMinionProcess
     */
    'tasks': { [key: string]: ResMinionTask; };
}
/**
 * Minion system information.
 * @export
 * @interface ResMinionSystem
 */
export interface ResMinionSystem {
    /**
     * System information about the Geometry Minions.
     * @type {ResMinionInfo}
     * @memberof ResMinionSystem
     */
    'minions': ResMinionInfo;
    /**
     * System information about the Geometry Workers.
     * @type {ResWorkerInfo}
     * @memberof ResMinionSystem
     */
    'workers'?: ResWorkerInfo;
}
/**
 * Statistics of a single Minion task.
 * @export
 * @interface ResMinionTask
 */
export interface ResMinionTask {
    /**
     * Average duration of the task in milliseconds.
     * @type {number}
     * @memberof ResMinionTask
     */
    'avgDuration': number;
    /**
     * Maximum duration of the task in milliseconds.
     * @type {number}
     * @memberof ResMinionTask
     */
    'maxDuration': number;
    /**
     * Average difference between the configured task interval and the last global task execution in milliseconds.
     * @type {number}
     * @memberof ResMinionTask
     */
    'avgIntervalDiff': number;
    /**
     * Maximum difference between the configured task interval and the last global task execution in milliseconds.
     * @type {number}
     * @memberof ResMinionTask
     */
    'maxIntervalDiff': number;
    /**
     * Execution interval of this task type in milliseconds.
     * @type {number}
     * @memberof ResMinionTask
     */
    'interval': number;
    /**
     * Timestamp of the latest task completion.
     * @type {string}
     * @memberof ResMinionTask
     */
    'latest': string;
    /**
     * The number of aggregated items.
     * @type {number}
     * @memberof ResMinionTask
     */
    'count': number;
}
/**
 * Definition of a ShapeDiver model.
 * @export
 * @interface ResModel
 */
export interface ResModel {
    /**
     * List of allowed Grasshopper libraries.
     * @type {Array<string>}
     * @memberof ResModel
     */
    'allowed_libraries'?: Array<string>;
    /**
     * Link to view the model on the ShapeDiver Platform.
     * @type {string}
     * @memberof ResModel
     */
    'backlinkurl'?: string;
    /**
     * Link to continue the checking process of the model on the ShapeDiver Platform.
     * @type {string}
     * @memberof ResModel
     */
    'checkurl'?: string;
    /**
     * Timestamp of creation of the model.
     * @type {string}
     * @memberof ResModel
     */
    'createdate'?: string;
    /**
     * ID of the Grasshopper document.
     * @type {string}
     * @memberof ResModel
     */
    'documentid'?: string;
    /**
     * Original name of the model\'s grasshopper file.
     * @type {string}
     * @memberof ResModel
     */
    'filename'?: string;
    /**
     * ID of the model.
     * @type {string}
     * @memberof ResModel
     */
    'id': string;
    /**
     * Optional second ID of the model. This value can be unset via an empty string.
     * @type {string}
     * @memberof ResModel
     */
    'id2'?: string;
    /**
     * Optional message, used in case the model was denied.
     * @type {string}
     * @memberof ResModel
     */
    'msg'?: string;
    /**
     * Model name.
     * @type {string}
     * @memberof ResModel
     */
    'name'?: string;
    /**
     * Organization ID of the user that owns the model.
     * @type {string}
     * @memberof ResModel
     */
    'org_id'?: string;
    /**
     * 
     * @type {ResModelStatus}
     * @memberof ResModel
     */
    'stat': ResModelStatus;
    /**
     * ShapeDiver User ID of the model owner.
     * @type {string}
     * @memberof ResModel
     */
    'user_id'?: string;
    /**
     * The webhook-url for updating the platform backend about model status changes.
     * @type {string}
     * @memberof ResModel
     */
    'webhook_url'?: string;
    /**
     * The webhook-token for authentication used by the webhook-url.
     * @type {string}
     * @memberof ResModel
     */
    'webhook_token'?: string;
}


/**
 * Information about a model cleanup process.
 * @export
 * @interface ResModelCleanupProcess
 */
export interface ResModelCleanupProcess {
    /**
     * Type of the model cleanup process.
     * @type {ResModelCleanupProcessType}
     * @memberof ResModelCleanupProcess
     */
    'type': ResModelCleanupProcessType;
    /**
     * The timestamp when the deletion job has been enqueued.
     * @type {string}
     * @memberof ResModelCleanupProcess
     */
    'timestamp_enqueued': string;
    /**
     * The total number of items of this type that are going to be deleted.
     * @type {number}
     * @memberof ResModelCleanupProcess
     */
    'total'?: number;
    /**
     * The number of already deleted items of this type.
     * @type {number}
     * @memberof ResModelCleanupProcess
     */
    'deleted'?: number;
}


/**
 * Model cleanup process types.
 * @export
 * @enum {string}
 */

export const ResModelCleanupProcessType = {
    DELETE_EXPORT_VERSION: 'delete_export_version',
    DELETE_MODEL_TEXTURE: 'delete_model_texture',
    DELETE_OUTPUT_VERSION: 'delete_output_version'
} as const;

export type ResModelCleanupProcessType = typeof ResModelCleanupProcessType[keyof typeof ResModelCleanupProcessType];


/**
 * Components of a model computation request.
 * @export
 * @interface ResModelComputation
 */
export interface ResModelComputation {
    /**
     * ID of the model.
     * @type {string}
     * @memberof ResModelComputation
     */
    'id': string;
    /**
     * Numeric timestamp in format `YYYYMMDDHHMMSSMMM`.  Deprecated: Use `timestamp_str` instead.
     * @type {number}
     * @memberof ResModelComputation
     * @deprecated
     */
    'timestamp': number;
    /**
     * Timestamp.
     * @type {string}
     * @memberof ResModelComputation
     */
    'timestamp_str': string;
    /**
     * The ID of the compute request that was processed.
     * @type {string}
     * @memberof ResModelComputation
     */
    'compute_request_id': string;
    /**
     * Requested export versions.
     * @type {{ [key: string]: string; }}
     * @memberof ResModelComputation
     */
    'exports': { [key: string]: string; };
    /**
     * Requested output versions.
     * @type {{ [key: string]: string; }}
     * @memberof ResModelComputation
     */
    'outputs': { [key: string]: string; };
    /**
     * Parameter values.
     * @type {object}
     * @memberof ResModelComputation
     */
    'params': object;
    /**
     * The stats of the computation request.
     * @type {ResModelComputationStats}
     * @memberof ResModelComputation
     */
    'stats': ResModelComputationStats;
    /**
     * Result of processing request.
     * @type {ResComputationStatus}
     * @memberof ResModelComputation
     */
    'status': ResComputationStatus;
    /**
     * Timestamp when the computation request was finished.
     * @type {string}
     * @memberof ResModelComputation
     */
    'timestamp_fin': string;
    /**
     * Timestamp when the work request was filed.
     * @type {string}
     * @memberof ResModelComputation
     */
    'timestamp_req': string;
    /**
     * Timestamp when the computation request was filed.
     * @type {string}
     * @memberof ResModelComputation
     */
    'timestamp_req_iso': string;
    /**
     * Timestamp when the computation request was picked up.
     * @type {string}
     * @memberof ResModelComputation
     */
    'timestamp_resp': string;
    /**
     * Message containing information about the computation process.
     * @type {string}
     * @memberof ResModelComputation
     */
    'msg'?: string;
    /**
     * Model\'s limits at the time of the computation process.
     * @type {ResComputationLimits}
     * @memberof ResModelComputation
     */
    'limit'?: ResComputationLimits;
}


/**
 * Stats of a computation request.
 * @export
 * @interface ResModelComputationStats
 */
export interface ResModelComputationStats {
    /**
     * Total size in bytes of the uncompressed resulting assets.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'size_assets'?: number;
    /**
     * Total size in bytes of the (potentially compressed) assets uploaded to storage.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'size_assets_storage'?: number;
    /**
     * The number of milliseconds it took to answer the request.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_completion': number;
    /**
     * The number of milliseconds it took to download the model from storage. `0` in case model was already downloaded to the instance.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_model_download': number;
    /**
     * The number of milliseconds it took to  load (open) the model. `0` in case model was already loaded.  Note: Does not include time for script compilation and first computation.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_model_open': number;
    /**
     * The number of milliseconds it took to process the request.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_processing': number;
    /**
     * The number of milliseconds it took to carry out checks that are done before loading the model.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_check_stored': number;
    /**
     * The number of milliseconds it took to carry out check that are done after loading the model.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_check_loaded': number;
    /**
     * The number of milliseconds it took to upload assets to storage.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_storage'?: number;
    /**
     * The number of milliseconds for Grasshopper solver.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_solver': number;
    /**
     * The number of milliseconds it took to collect output and export data after computation.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_solver_collect'?: number;
    /**
     * The number of milliseconds it took to download and load the model and setting parameters, and to compute the solution.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_solver_ext': number;
    /**
     * The number of milliseconds the request was waiting before being processed.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_wait': number;
    /**
     * The number of milliseconds it took to store the results of the request in the cache.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_cache_outputs'?: number;
    /**
     * Information about model computations.
     * @type {ResComputationComponents}
     * @memberof ResModelComputationStats
     */
    'model'?: ResComputationComponents;
    /**
     * The number of milliseconds the CPU was used to carry out checks which are done before loading the model.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_check_stored'?: number;
    /**
     * The number of milliseconds the CPU was used to carry out checks which are done after loading the model.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_check_loaded'?: number;
    /**
     * The number of milliseconds the CPU was used to upload assets to storage.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_storage'?: number;
    /**
     * The number of milliseconds the CPU was used to download the model from storage.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_model_download'?: number;
    /**
     * The number of milliseconds the CPU was used to  load (open) the model. `0` in case model was already loaded.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_model_open'?: number;
    /**
     * The number of milliseconds the CPU was used for Grasshopper solver.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_solver'?: number;
    /**
     * The number of milliseconds the CPU was used to collect output and export data after computation.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_solver_collect'?: number;
    /**
     * The number of milliseconds the CPU was used to download and load the model and setting parameters, and to compute the solution.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_solver_ext'?: number;
    /**
     * The number of milliseconds the CPU was used to store the results of the request in the cache.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_cache_outputs'?: number;
    /**
     * The number of milliseconds it took to prepare the model after loading it. As an example, preparation includes compilation of scripts.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'time_model_prepare'?: number;
    /**
     * The number of milliseconds the CPU was used to prepare the model after loading it. As an example, preparation includes compilation of scripts.
     * @type {number}
     * @memberof ResModelComputationStats
     */
    'cpu_time_model_prepare'?: number;
}
/**
 * Aggregated credit metrics for a model.
 * @export
 * @interface ResModelCreditMetric
 */
export interface ResModelCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     * @type {string}
     * @memberof ResModelCreditMetric
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     * @type {boolean}
     * @memberof ResModelCreditMetric
     */
    'isCompilationDone': boolean;
    /**
     * 
     * @type {ResArCreditMetric}
     * @memberof ResModelCreditMetric
     */
    'ar': ResArCreditMetric;
    /**
     * 
     * @type {ResLoadingCreditMetric}
     * @memberof ResModelCreditMetric
     */
    'loading': ResLoadingCreditMetric;
    /**
     * 
     * @type {ResLimitedCreditMetric}
     * @memberof ResModelCreditMetric
     */
    'limited': ResLimitedCreditMetric;
    /**
     * 
     * @type {ResDefaultCreditMetric}
     * @memberof ResModelCreditMetric
     */
    'default': ResDefaultCreditMetric;
    /**
     * Requested model ID.
     * @type {string}
     * @memberof ResModelCreditMetric
     */
    'modelId': string;
    /**
     * This property is never set.
     * @type {boolean}
     * @memberof ResModelCreditMetric
     * @deprecated
     */
    'userId'?: boolean | null;
    /**
     * This property is never set.
     * @type {boolean}
     * @memberof ResModelCreditMetric
     * @deprecated
     */
    'orgId'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ResModelList
 */
export interface ResModelList {
    /**
     * A directory of file objects.
     * @type {Array<ResFileInfo>}
     * @memberof ResModelList
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     * @type {Array<ResSdtfInfo>}
     * @memberof ResModelList
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     * @type {Array<ResModel>}
     * @memberof ResModelList
     */
    'model': Array<ResModel>;
    /**
     * A directory of Model-States.
     * @type {Array<ResModelStateInfo>}
     * @memberof ResModelList
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     * @type {Array<ResOutput>}
     * @memberof ResModelList
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     * @type {Array<ResExport>}
     * @memberof ResModelList
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     * @type {Array<ResTexture>}
     * @memberof ResModelList
     */
    'texture'?: Array<ResTexture>;
}
/**
 * Aggregated credit metrics for a model-organization.
 * @export
 * @interface ResModelOrganizationCreditMetric
 */
export interface ResModelOrganizationCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     * @type {string}
     * @memberof ResModelOrganizationCreditMetric
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     * @type {boolean}
     * @memberof ResModelOrganizationCreditMetric
     */
    'isCompilationDone': boolean;
    /**
     * 
     * @type {ResArCreditMetric}
     * @memberof ResModelOrganizationCreditMetric
     */
    'ar': ResArCreditMetric;
    /**
     * 
     * @type {ResLoadingCreditMetric}
     * @memberof ResModelOrganizationCreditMetric
     */
    'loading': ResLoadingCreditMetric;
    /**
     * 
     * @type {ResLimitedCreditMetric}
     * @memberof ResModelOrganizationCreditMetric
     */
    'limited': ResLimitedCreditMetric;
    /**
     * 
     * @type {ResDefaultCreditMetric}
     * @memberof ResModelOrganizationCreditMetric
     */
    'default': ResDefaultCreditMetric;
    /**
     * Requested model ID.
     * @type {string}
     * @memberof ResModelOrganizationCreditMetric
     */
    'modelId': string;
    /**
     * Requested organization ID.
     * @type {string}
     * @memberof ResModelOrganizationCreditMetric
     */
    'orgId': string;
}
/**
 * 
 * @export
 * @interface ResModelSettings
 */
export interface ResModelSettings {
    /**
     * Allows the usage of the CDN for fast content distribution.
     * @type {boolean}
     * @memberof ResModelSettings
     */
    'use_cdn'?: boolean;
    /**
     * Indicates if the model supports CDN-based asset URLs.
     * @type {boolean}
     * @memberof ResModelSettings
     */
    'cdn_supported'?: boolean;
}
/**
 * Definition of a Model-State.
 * @export
 * @interface ResModelState
 */
export interface ResModelState {
    /**
     * A directory of parameter IDs and values.
     * @type {{ [key: string]: ResParameterValue; }}
     * @memberof ResModelState
     */
    'parameters': { [key: string]: ResParameterValue; };
    /**
     * Optional untyped data that holds additional information.
     * @type {{ [key: string]: any; }}
     * @memberof ResModelState
     */
    'data'?: { [key: string]: any; };
    /**
     * ID of the Model-State.
     * @type {string}
     * @memberof ResModelState
     */
    'id': string;
    /**
     * ID of the ShapeDiver model.
     * @type {string}
     * @memberof ResModelState
     */
    'modelId': string;
    /**
     * Timestamp of creation of the Model-State.
     * @type {string}
     * @memberof ResModelState
     */
    'createdate': string;
    /**
     * The URL of the Model-State image.
     * @type {string}
     * @memberof ResModelState
     */
    'imageUrl'?: string;
}
/**
 * Model-State image asset.
 * @export
 * @interface ResModelStateAsset
 */
export interface ResModelStateAsset {
    /**
     * A directory of parameter-IDs and asset-definitions.
     * @type {{ [key: string]: ResAssetDefinition; }}
     * @memberof ResModelStateAsset
     */
    'file'?: { [key: string]: ResAssetDefinition; };
    /**
     * 
     * @type {Array<ResAssetDefinition>}
     * @memberof ResModelStateAsset
     */
    'sdtf'?: Array<ResAssetDefinition>;
    /**
     * The asset-definition of a Model-State image.
     * @type {ResAssetDefinition}
     * @memberof ResModelStateAsset
     */
    'modelState': ResAssetDefinition;
}
/**
 * Parameter and additional data of a Model-State.
 * @export
 * @interface ResModelStateData
 */
export interface ResModelStateData {
    /**
     * A directory of parameter IDs and values.
     * @type {{ [key: string]: ResParameterValue; }}
     * @memberof ResModelStateData
     */
    'parameters': { [key: string]: ResParameterValue; };
    /**
     * Optional untyped data that holds additional information.
     * @type {{ [key: string]: any; }}
     * @memberof ResModelStateData
     */
    'data'?: { [key: string]: any; };
}
/**
 * Basic information about a Model-State.
 * @export
 * @interface ResModelStateInfo
 */
export interface ResModelStateInfo {
    /**
     * ID of the Model-State.
     * @type {string}
     * @memberof ResModelStateInfo
     */
    'id': string;
    /**
     * A directory of parameter IDs and values.
     * @type {{ [key: string]: ResParameterValue; }}
     * @memberof ResModelStateInfo
     */
    'parameters': { [key: string]: ResParameterValue; };
    /**
     * Indicates whether the Model-State includes an image.
     * @type {boolean}
     * @memberof ResModelStateInfo
     */
    'hasImage': boolean;
    /**
     * Indicates whether the Model-State includes a glTF asset.
     * @type {boolean}
     * @memberof ResModelStateInfo
     */
    'hasGltf': boolean;
    /**
     * Indicates whether the Model-State includes a USDZ asset.
     * @type {boolean}
     * @memberof ResModelStateInfo
     */
    'hasUsdz': boolean;
}
/**
 * 
 * @export
 * @interface ResModelStateList
 */
export interface ResModelStateList {
    /**
     * A directory of file objects.
     * @type {Array<ResFileInfo>}
     * @memberof ResModelStateList
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     * @type {Array<ResSdtfInfo>}
     * @memberof ResModelStateList
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     * @type {Array<ResModel>}
     * @memberof ResModelStateList
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     * @type {Array<ResModelStateInfo>}
     * @memberof ResModelStateList
     */
    'modelState': Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     * @type {Array<ResOutput>}
     * @memberof ResModelStateList
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     * @type {Array<ResExport>}
     * @memberof ResModelStateList
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     * @type {Array<ResTexture>}
     * @memberof ResModelStateList
     */
    'texture'?: Array<ResTexture>;
}
/**
 * @type ResModelStateOrData
 * @export
 */
export type ResModelStateOrData = ResModelState | ResModelStateData;

/**
 * Aggregated model session statistics.
 * @export
 * @interface ResModelStatistic
 */
export interface ResModelStatistic {
    /**
     * Requested model ID.
     * @type {string}
     * @memberof ResModelStatistic
     */
    'modelid': string;
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     * @type {string}
     * @memberof ResModelStatistic
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     * @type {boolean}
     * @memberof ResModelStatistic
     */
    'isCompilationDone': boolean;
    /**
     * Number of (technical) sessions for the given model and timestamp. A technical session may last up to two hours, after which it will get cancelled by the backend.  CAUTION: Not to be confused with credits!
     * @type {number}
     * @memberof ResModelStatistic
     */
    'count': number;
    /**
     * Billable duration-based credit count, based on maximum duration of 10 minutes per credit.
     * @type {number}
     * @memberof ResModelStatistic
     */
    'billableCount': number;
    /**
     * Statistics on the duration of all sessions.
     * @type {ResOnDurationStatistic}
     * @memberof ResModelStatistic
     */
    'duration': ResOnDurationStatistic;
    /**
     * Statistics on the duration of app sessions.
     * @type {ResOnDurationStatistic}
     * @memberof ResModelStatistic
     */
    'app': ResOnDurationStatistic;
    /**
     * Statistics on the duration of backend sessions.
     * @type {ResOnDurationStatistic}
     * @memberof ResModelStatistic
     */
    'backend': ResOnDurationStatistic;
    /**
     * Statistics on the duration of embedded sessions.
     * @type {ResOnDurationStatistic}
     * @memberof ResModelStatistic
     */
    'embedded': ResOnDurationStatistic;
    /**
     * Statistics on the duration of desktop sessions.
     * @type {ResOnDurationStatistic}
     * @memberof ResModelStatistic
     */
    'desktop': ResOnDurationStatistic;
    /**
     * Statistics on customization requests per session.
     * @type {ResOnActionStatistic}
     * @memberof ResModelStatistic
     */
    'customize': ResOnActionStatistic;
    /**
     * Statistics on export requests per session.
     * @type {ResOnActionStatistic}
     * @memberof ResModelStatistic
     */
    'export': ResOnActionStatistic;
}
/**
 * Status of the model.
 * @export
 * @enum {string}
 */

export const ResModelStatus = {
    UNKNOWN: 'unknown',
    NOT_UPLOADED: 'not_uploaded',
    UPLOADED: 'uploaded',
    PENDING: 'pending',
    CONFIRMED: 'confirmed',
    DENIED: 'denied',
    DELETED: 'deleted'
} as const;

export type ResModelStatus = typeof ResModelStatus[keyof typeof ResModelStatus];


/**
 * Aggregated credit metrics for a model-user.
 * @export
 * @interface ResModelUserCreditMetric
 */
export interface ResModelUserCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     * @type {string}
     * @memberof ResModelUserCreditMetric
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     * @type {boolean}
     * @memberof ResModelUserCreditMetric
     */
    'isCompilationDone': boolean;
    /**
     * 
     * @type {ResArCreditMetric}
     * @memberof ResModelUserCreditMetric
     */
    'ar': ResArCreditMetric;
    /**
     * 
     * @type {ResLoadingCreditMetric}
     * @memberof ResModelUserCreditMetric
     */
    'loading': ResLoadingCreditMetric;
    /**
     * 
     * @type {ResLimitedCreditMetric}
     * @memberof ResModelUserCreditMetric
     */
    'limited': ResLimitedCreditMetric;
    /**
     * 
     * @type {ResDefaultCreditMetric}
     * @memberof ResModelUserCreditMetric
     */
    'default': ResDefaultCreditMetric;
    /**
     * Requested model ID.
     * @type {string}
     * @memberof ResModelUserCreditMetric
     */
    'modelId': string;
    /**
     * Requested user ID.
     * @type {string}
     * @memberof ResModelUserCreditMetric
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface ResOnActionStatistic
 */
export interface ResOnActionStatistic {
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Number of (technical) sessions   from all sources (duration) or from one specific source (app, embedded, backend,   desktop), for the given model and timestamp. * `export`, `customize`: Number of sessions which have export requests.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'count': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Billable duration-based credit   count for all sessions, based on maximum duration of 10 minutes per credit. * `export`, `customize`: Billable duration-based credit count for sessions which have   export requests, based on maximum duration of 10 minutes per credit.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'billableCount': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Cumulative distribution function   of the duration, for all sessions for the given model and timestamp. * `export`, `customize`: Cumulative distribution function of the number of export   requests per session, for sessions which have export requests.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'min': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Cumulative distribution function   of the duration, for all sessions for the given model and timestamp. * `export`, `customize`: Cumulative distribution function of the number of export   requests per session, for sessions which have export requests.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'max': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Average duration of all sessions   for the given model and timestamp. * `export`, `customize`: Average number of export requests per session, for sessions   which have export requests.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'avg': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Total duration of all sessions   for the given model and timestamp. * `export`, `customize`: Total number of export requests for all sessions which have   export requests.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'sum': number;
    /**
     * `customize`: Total number of actions, for ShapeDiver Platform sessions for which the type of action happened.  Note: New property - will contain `0` for entries before November 2019.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'sumApp': number;
    /**
     * `customize`: Total number of customization requests for backend sessions which have customization requests.  `export`: Total number of export requests for backend sessions which have export requests.  Note: New property - will contain `0` for entries before November 2019.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'sumBackend': number;
    /**
     * `customize`: Total number of customization requests for embedded sessions which have customization requests.  `export`: Total number of export requests for embedded sessions which have export requests.  Note: New property - will contain `0` for entries before November 2019.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'sumEmbedded': number;
    /**
     * `customize`: Total number of actions, for desktop client sessions for which the type of action happened.  Note: New property - will contain `0` for entries before January 2021.
     * @type {number}
     * @memberof ResOnActionStatistic
     */
    'sumDesktop': number;
}
/**
 * 
 * @export
 * @interface ResOnDurationStatistic
 */
export interface ResOnDurationStatistic {
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Number of (technical) sessions   from all sources (duration) or from one specific source (app, embedded, backend,   desktop), for the given model and timestamp. * `export`, `customize`: Number of sessions which have export requests.
     * @type {number}
     * @memberof ResOnDurationStatistic
     */
    'count': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Billable duration-based credit   count for all sessions, based on maximum duration of 10 minutes per credit. * `export`, `customize`: Billable duration-based credit count for sessions which have   export requests, based on maximum duration of 10 minutes per credit.
     * @type {number}
     * @memberof ResOnDurationStatistic
     */
    'billableCount': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Cumulative distribution function   of the duration, for all sessions for the given model and timestamp. * `export`, `customize`: Cumulative distribution function of the number of export   requests per session, for sessions which have export requests.
     * @type {number}
     * @memberof ResOnDurationStatistic
     */
    'min': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Cumulative distribution function   of the duration, for all sessions for the given model and timestamp. * `export`, `customize`: Cumulative distribution function of the number of export   requests per session, for sessions which have export requests.
     * @type {number}
     * @memberof ResOnDurationStatistic
     */
    'max': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Average duration of all sessions   for the given model and timestamp. * `export`, `customize`: Average number of export requests per session, for sessions   which have export requests.
     * @type {number}
     * @memberof ResOnDurationStatistic
     */
    'avg': number;
    /**
     * * `duration`, `app`, `embedded`, `backend`, `desktop`: Total duration of all sessions   for the given model and timestamp. * `export`, `customize`: Total number of export requests for all sessions which have   export requests.
     * @type {number}
     * @memberof ResOnDurationStatistic
     */
    'sum': number;
}
/**
 * Aggregated credit metrics for a organization.
 * @export
 * @interface ResOrganizationCreditMetric
 */
export interface ResOrganizationCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     * @type {string}
     * @memberof ResOrganizationCreditMetric
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     * @type {boolean}
     * @memberof ResOrganizationCreditMetric
     */
    'isCompilationDone': boolean;
    /**
     * 
     * @type {ResArCreditMetric}
     * @memberof ResOrganizationCreditMetric
     */
    'ar': ResArCreditMetric;
    /**
     * 
     * @type {ResLoadingCreditMetric}
     * @memberof ResOrganizationCreditMetric
     */
    'loading': ResLoadingCreditMetric;
    /**
     * 
     * @type {ResLimitedCreditMetric}
     * @memberof ResOrganizationCreditMetric
     */
    'limited': ResLimitedCreditMetric;
    /**
     * 
     * @type {ResDefaultCreditMetric}
     * @memberof ResOrganizationCreditMetric
     */
    'default': ResDefaultCreditMetric;
    /**
     * This property is never set.
     * @type {boolean}
     * @memberof ResOrganizationCreditMetric
     * @deprecated
     */
    'modelId'?: boolean | null;
    /**
     * Requested organization ID.
     * @type {string}
     * @memberof ResOrganizationCreditMetric
     */
    'orgId': string;
}
/**
 * Output definition WITH results as exposed on the API.
 * @export
 * @interface ResOutput
 */
export interface ResOutput {
    /**
     * ID of the output, dependent on model ID, and therefore changing each time a model gets uploaded.
     * @type {string}
     * @memberof ResOutput
     */
    'id': string;
    /**
     * Constant ID of the output, not dependent on model ID, and therefore NOT changing each time a model gets uploaded. Might be undefined because this property was introduced in summer 2020 and does not exist for outputs of older models.
     * @type {string}
     * @memberof ResOutput
     */
    'uid'?: string;
    /**
     * Name of the output.
     * @type {string}
     * @memberof ResOutput
     */
    'name': string;
    /**
     * Optional ID of the output holding material information for this output.
     * @type {string}
     * @memberof ResOutput
     */
    'material'?: string;
    /**
     * Information about which chunks exist in the asset/sdTF.
     * @type {Array<ResOutputChunk>}
     * @memberof ResOutput
     */
    'chunks'?: Array<ResOutputChunk>;
    /**
     * List of IDs of parameters influencing this output.
     * @type {Array<string>}
     * @memberof ResOutput
     */
    'dependency': Array<string>;
    /**
     * 
     * @type {ResOutputDefinitionGroup}
     * @memberof ResOutput
     */
    'group'?: ResOutputDefinitionGroup;
    /**
     * Ordering of the output in client applications.
     * @type {number}
     * @memberof ResOutput
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ResOutput
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     * @type {string}
     * @memberof ResOutput
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     * @type {boolean}
     * @memberof ResOutput
     */
    'hidden': boolean;
    /**
     * A unique identifier for the particular version of the output. This is a hash code which is based on the parameter values that were used to compute the resulting data. The hash code only depends on the values of the parameters which may theoretically influence the results of the output. As an example, parameters which are in no way connected to the output component in Grasshopper are not considered.
     * @type {string}
     * @memberof ResOutput
     */
    'version': string;
    /**
     * The delay in milliseconds after which a cache request shall be sent to check again for this output version. This property is used ONLY if the output version has not been computed yet.  Note that the existence of this property does not necessarily imply the presence of an active or queued computation for the respective output version.
     * @type {number}
     * @memberof ResOutput
     */
    'delay'?: number;
    /**
     * Result parts. In case this array does not exist, this means that the workers have not finished computation for this output version.
     * @type {Array<ResOutputContent>}
     * @memberof ResOutput
     */
    'content'?: Array<ResOutputContent>;
    /**
     * Optional bounding box, minimum corner.
     * @type {Array<number>}
     * @memberof ResOutput
     */
    'bbmin'?: Array<number>;
    /**
     * Optional bounding box, maximum corner.
     * @type {Array<number>}
     * @memberof ResOutput
     */
    'bbmax'?: Array<number>;
    /**
     * In case computation of the export version (temporarily) failed. Contains a message explaining what went wrong.
     * @type {string}
     * @memberof ResOutput
     */
    'msg'?: string;
    /**
     * Status of the computation which resulted in the output version.
     * @type {ResComputationStatus}
     * @memberof ResOutput
     */
    'status_computation'?: ResComputationStatus;
    /**
     * Status of collecting results for the output version.
     * @type {ResComputationStatus}
     * @memberof ResOutput
     */
    'status_collect'?: ResComputationStatus;
}


/**
 * Represents a collection of nodes where to start enumerating the content of the sdTF file (entry points).
 * @export
 * @interface ResOutputChunk
 */
export interface ResOutputChunk {
    /**
     * ID of the chunk.
     * @type {string}
     * @memberof ResOutputChunk
     */
    'id': string;
    /**
     * Name of the chunk.
     * @type {string}
     * @memberof ResOutputChunk
     */
    'name': string;
    /**
     * Indicates what type of data the data item holds.
     * @type {string}
     * @memberof ResOutputChunk
     */
    'typeHint': string;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ResOutputChunk
     */
    'tooltip'?: string;
    /**
     * Custom name to display instead of `name`. Empty string if not set.
     * @type {string}
     * @memberof ResOutputChunk
     */
    'displayname': string;
    /**
     * Controls whether the chunk should be hidden in the UI.
     * @type {boolean}
     * @memberof ResOutputChunk
     */
    'hidden': boolean;
}
/**
 * An item of the `content` array for outputs.
 * @export
 * @interface ResOutputContent
 */
export interface ResOutputContent {
    /**
     * Optional link to asset.
     * @type {string}
     * @memberof ResOutputContent
     */
    'href'?: string;
    /**
     * Size in bytes for parts of type `asset`.
     * @type {number}
     * @memberof ResOutputContent
     */
    'size'?: number;
    /**
     * Optionally used for type `data`.
     * @type {string}
     * @memberof ResOutputContent
     */
    'name'?: string;
    /**
     * Transformations to be applied in case of type `external` or `asset`.
     * @type {Array<Array<number>>}
     * @memberof ResOutputContent
     */
    'transformations'?: Array<Array<number>>;
    /**
     * Format of part, used by all types of parts. * File ending for parts of type `asset`. * `material` (data contains a material definition). * `data` (data contains arbitrary data). * `external` (href or storage information that refer to an external asset).
     * @type {string}
     * @memberof ResOutputContent
     */
    'format': string;
    /**
     * This was used by legacy `transform_content_array` in case of an error in getting texture URLs.
     * @type {string}
     * @memberof ResOutputContent
     */
    'msg'?: string;
    /**
     * Used for types `material` and `data`.
     * @type {any}
     * @memberof ResOutputContent
     */
    'data'?: any;
    /**
     * Optional Content-Type for parts of type `asset`.
     * @type {string}
     * @memberof ResOutputContent
     */
    'contentType'?: string;
}
/**
 * Output definition WITHOUT results as exposed on the API.
 * @export
 * @interface ResOutputDefinition
 */
export interface ResOutputDefinition {
    /**
     * ID of the output, dependent on model ID, and therefore changing each time a model gets uploaded.
     * @type {string}
     * @memberof ResOutputDefinition
     */
    'id': string;
    /**
     * Constant ID of the output, not dependent on model ID, and therefore NOT changing each time a model gets uploaded. Might be undefined because this property was introduced in summer 2020 and does not exist for outputs of older models.
     * @type {string}
     * @memberof ResOutputDefinition
     */
    'uid'?: string;
    /**
     * Name of the output.
     * @type {string}
     * @memberof ResOutputDefinition
     */
    'name': string;
    /**
     * Optional ID of the output holding material information for this output.
     * @type {string}
     * @memberof ResOutputDefinition
     */
    'material'?: string;
    /**
     * Information about which chunks exist in the asset/sdTF.
     * @type {Array<ResOutputChunk>}
     * @memberof ResOutputDefinition
     */
    'chunks'?: Array<ResOutputChunk>;
    /**
     * List of IDs of parameters influencing this output.
     * @type {Array<string>}
     * @memberof ResOutputDefinition
     */
    'dependency': Array<string>;
    /**
     * 
     * @type {ResOutputDefinitionGroup}
     * @memberof ResOutputDefinition
     */
    'group'?: ResOutputDefinitionGroup;
    /**
     * Ordering of the output in client applications.
     * @type {number}
     * @memberof ResOutputDefinition
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ResOutputDefinition
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     * @type {string}
     * @memberof ResOutputDefinition
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     * @type {boolean}
     * @memberof ResOutputDefinition
     */
    'hidden': boolean;
    /**
     * This property is never set.
     * @type {boolean}
     * @memberof ResOutputDefinition
     * @deprecated
     */
    'version'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ResOutputDefinitionGroup
 */
export interface ResOutputDefinitionGroup {
    /**
     * 
     * @type {string}
     * @memberof ResOutputDefinitionGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResOutputDefinitionGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ResOutputList
 */
export interface ResOutputList {
    /**
     * A directory of file objects.
     * @type {Array<ResFileInfo>}
     * @memberof ResOutputList
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     * @type {Array<ResSdtfInfo>}
     * @memberof ResOutputList
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     * @type {Array<ResModel>}
     * @memberof ResOutputList
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     * @type {Array<ResModelStateInfo>}
     * @memberof ResOutputList
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     * @type {Array<ResOutput>}
     * @memberof ResOutputList
     */
    'output': Array<ResOutput>;
    /**
     * A directory of export versions.
     * @type {Array<ResExport>}
     * @memberof ResOutputList
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     * @type {Array<ResTexture>}
     * @memberof ResOutputList
     */
    'texture'?: Array<ResTexture>;
}
/**
 * @type ResOutputOrDefinition
 * Either a full output or it\'s definition.
 * @export
 */
export type ResOutputOrDefinition = ResOutput | ResOutputDefinition;

/**
 * Pagination component.
 * @export
 * @interface ResPagination
 */
export interface ResPagination {
    /**
     * The query limit that has been used in the request.
     * @type {number}
     * @memberof ResPagination
     */
    'limit': number;
    /**
     * The offset that can be used in the next request to query the remaining items. This property is missing when all items have been processed.
     * @type {string}
     * @memberof ResPagination
     */
    'next_offset'?: string;
}
/**
 * Definition of a parameter of a ShapeDiver Model.
 * @export
 * @interface ResParameter
 */
export interface ResParameter {
    /**
     * Unique ID of parameter, stays constant each time a model gets uploaded.
     * @type {string}
     * @memberof ResParameter
     */
    'id': string;
    /**
     * Choice of parameter values for types `STRINGLIST`.
     * @type {Array<string>}
     * @memberof ResParameter
     */
    'choices'?: Array<string>;
    /**
     * Number of decimal places for numeric types.
     * @type {number}
     * @memberof ResParameter
     */
    'decimalplaces'?: number;
    /**
     * Default value of parameter, stringified.
     * @type {string}
     * @memberof ResParameter
     */
    'defval'?: string;
    /**
     * Optional expression to be applied to value for visualisation.
     * @type {string}
     * @memberof ResParameter
     */
    'expression'?: string;
    /**
     * List of file formats (content types) supported, used for type `FILE`.
     * @type {Array<string>}
     * @memberof ResParameter
     */
    'format'?: Array<string>;
    /**
     * Minimum value (stringified) for numeric types.
     * @type {number}
     * @memberof ResParameter
     */
    'min'?: number;
    /**
     * Maximum: * value (stringified) for numeric types. * string length for type `STRING`. * file size allowed (stringified) for type FILE.
     * @type {number}
     * @memberof ResParameter
     */
    'max'?: number;
    /**
     * Minimum `u` value for two dimensional domain parameters.
     * @type {number}
     * @memberof ResParameter
     */
    'umin'?: number;
    /**
     * Maximum `u` value for two dimensional domain parameters.
     * @type {number}
     * @memberof ResParameter
     */
    'umax'?: number;
    /**
     * Minimum `v` value for two dimensional domain parameters.
     * @type {number}
     * @memberof ResParameter
     */
    'vmin'?: number;
    /**
     * Maximum `v` value for two dimensional domain parameters.
     * @type {number}
     * @memberof ResParameter
     */
    'vmax'?: number;
    /**
     * Step size used for domain parameters.
     * @type {number}
     * @memberof ResParameter
     */
    'interval'?: number;
    /**
     * Name of the parameter.
     * @type {string}
     * @memberof ResParameter
     */
    'name': string;
    /**
     * Type of parameter.
     * @type {ResParameterType}
     * @memberof ResParameter
     */
    'type': ResParameterType;
    /**
     * Optional preferred visualization for parameters of type `FILE` and `STRINGLIST`.
     * @type {ResVisualizationType}
     * @memberof ResParameter
     */
    'visualization'?: ResVisualizationType;
    /**
     * Structure of a parameter.
     * @type {ResStructureType}
     * @memberof ResParameter
     */
    'structure'?: ResStructureType;
    /**
     * 
     * @type {ResParameterGroup}
     * @memberof ResParameter
     */
    'group'?: ResParameterGroup;
    /**
     * Technical hint for the UI implementation.
     * @type {string}
     * @memberof ResParameter
     */
    'hint'?: string;
    /**
     * Ordering of the parameter in client applications.
     * @type {number}
     * @memberof ResParameter
     */
    'order'?: number;
    /**
     * Description that is shown as a tooltip in the clients.
     * @type {string}
     * @memberof ResParameter
     */
    'tooltip'?: string;
    /**
     * Parameter name to display instead of `name`.
     * @type {string}
     * @memberof ResParameter
     */
    'displayname'?: string;
    /**
     * Controls whether the parameter should be hidden in the UI.
     * @type {boolean}
     * @memberof ResParameter
     */
    'hidden': boolean;
    /**
     * Holds parameter-type specific information.
     * @type {object}
     * @memberof ResParameter
     */
    'settings'?: object;
}


/**
 * 
 * @export
 * @interface ResParameterGroup
 */
export interface ResParameterGroup {
    /**
     * 
     * @type {string}
     * @memberof ResParameterGroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResParameterGroup
     */
    'name': string;
}
/**
 * Type of parameter.  All types starting with \'s\' are s-type parameters while the others are basic parameter types.
 * @export
 * @enum {string}
 */

export const ResParameterType = {
    S_BITMAP: 'sBitmap',
    S_BOOL: 'sBool',
    S_BOX: 'sBox',
    S_BREP: 'sBrep',
    S_CIRCLE: 'sCircle',
    S_COLOR: 'sColor',
    S_CURVE: 'sCurve',
    S_DOMAIN: 'sDomain',
    S_DOMAIN_2D: 'sDomain2D',
    S_INTEGER: 'sInteger',
    S_LINE: 'sLine',
    S_MESH: 'sMesh',
    S_NUMBER: 'sNumber',
    S_PLANE: 'sPlane',
    S_POINT: 'sPoint',
    S_RECTANGLE: 'sRectangle',
    S_STRING: 'sString',
    S_SUBDIV: 'sSubdiv',
    S_SURFACE: 'sSurface',
    S_TIME: 'sTime',
    S_VECTOR: 'sVector',
    BOOL: 'Bool',
    COLOR: 'Color',
    DRAWING: 'Drawing',
    EVEN: 'Even',
    FILE: 'File',
    FLOAT: 'Float',
    INT: 'Int',
    INTERACTION: 'Interaction',
    ODD: 'Odd',
    STRING: 'String',
    STRINGLIST: 'StringList',
    TIME: 'Time',
    UNKNOWN: 'unknown'
} as const;

export type ResParameterType = typeof ResParameterType[keyof typeof ResParameterType];


/**
 * @type ResParameterValue
 * The value of a single model parameter. Supported parameter values are: * Basic parameter (`CommonsBasicParameter`) * S-type parameter (`CommonsStypeParameter`)
 * @export
 */
export type ResParameterValue = CommonsBasicParameter | CommonsStypeParameter;

/**
 * 
 * @export
 * @interface ResPartActions
 */
export interface ResPartActions {
    /**
     * Actions the client may take.
     * @type {Array<ResAction>}
     * @memberof ResPartActions
     */
    'actions'?: Array<ResAction>;
}
/**
 * 
 * @export
 * @interface ResPartAnalytics
 */
export interface ResPartAnalytics {
    /**
     * Statistics of the model for the given timespan.
     * @type {ResAnalytics}
     * @memberof ResPartAnalytics
     */
    'analytics'?: ResAnalytics;
}
/**
 * 
 * @export
 * @interface ResPartAuthorizationGroup
 */
export interface ResPartAuthorizationGroup {
    /**
     * The auth-group to use for ticked-based authentication.
     * @type {string}
     * @memberof ResPartAuthorizationGroup
     */
    'auth_group'?: string;
}
/**
 * 
 * @export
 * @interface ResPartCleanup
 */
export interface ResPartCleanup {
    /**
     * Model cleanup information.
     * @type {Array<ResModelCleanupProcess>}
     * @memberof ResPartCleanup
     */
    'cleanup'?: Array<ResModelCleanupProcess>;
}
/**
 * 
 * @export
 * @interface ResPartDecryptedTicket
 */
export interface ResPartDecryptedTicket {
    /**
     * Decrypted ticket details.
     * @type {ResTicket}
     * @memberof ResPartDecryptedTicket
     */
    'decryptedTicket'?: ResTicket;
}
/**
 * 
 * @export
 * @interface ResPartExports
 */
export interface ResPartExports {
    /**
     * Exports of the model for the given parameter values. A directory of export-IDs and exports.
     * @type {{ [key: string]: ResExportOrDefinition; }}
     * @memberof ResPartExports
     */
    'exports'?: { [key: string]: ResExportOrDefinition; };
}
/**
 * 
 * @export
 * @interface ResPartFile
 */
export interface ResPartFile {
    /**
     * Links regarding the model file.
     * @type {ResFile}
     * @memberof ResPartFile
     */
    'file'?: ResFile;
}
/**
 * 
 * @export
 * @interface ResPartGltfUpload
 */
export interface ResPartGltfUpload {
    /**
     * glTF information.
     * @type {ResGltfUpload}
     * @memberof ResPartGltfUpload
     */
    'gltf'?: ResGltfUpload;
}
/**
 * 
 * @export
 * @interface ResPartMessage
 */
export interface ResPartMessage {
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResPartMessage
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ResPartModel
 */
export interface ResPartModel {
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResPartModel
     */
    'model'?: ResModel;
}
/**
 * 
 * @export
 * @interface ResPartModelComputation
 */
export interface ResPartModelComputation {
    /**
     * Statistics about model computations.
     * @type {Array<ResModelComputation>}
     * @memberof ResPartModelComputation
     */
    'computations'?: Array<ResModelComputation>;
}
/**
 * 
 * @export
 * @interface ResPartModelState
 */
export interface ResPartModelState {
    /**
     * Model-State information.
     * @type {ResModelState}
     * @memberof ResPartModelState
     */
    'modelState'?: ResModelState;
}
/**
 * 
 * @export
 * @interface ResPartModelStateData
 */
export interface ResPartModelStateData {
    /**
     * Model-State information.
     * @type {ResModelStateData}
     * @memberof ResPartModelStateData
     */
    'modelState'?: ResModelStateData;
}
/**
 * 
 * @export
 * @interface ResPartOutputs
 */
export interface ResPartOutputs {
    /**
     * Outputs of the model for the given parameter values. A directory of output-IDs and outputs.
     * @type {{ [key: string]: ResOutputOrDefinition; }}
     * @memberof ResPartOutputs
     */
    'outputs'?: { [key: string]: ResOutputOrDefinition; };
}
/**
 * 
 * @export
 * @interface ResPartPagination
 */
export interface ResPartPagination {
    /**
     * Pagination information.
     * @type {ResPagination}
     * @memberof ResPartPagination
     */
    'pagination'?: ResPagination;
}
/**
 * 
 * @export
 * @interface ResPartParameters
 */
export interface ResPartParameters {
    /**
     * Parameter definitions, not contained with every response. A directory of parameter-IDs and parameters.
     * @type {{ [key: string]: ResParameter; }}
     * @memberof ResPartParameters
     */
    'parameters'?: { [key: string]: ResParameter; };
}
/**
 * 
 * @export
 * @interface ResPartPlugins
 */
export interface ResPartPlugins {
    /**
     * 
     * @type {ResPlugins}
     * @memberof ResPartPlugins
     */
    'plugins'?: ResPlugins;
}
/**
 * 
 * @export
 * @interface ResPartSessionId
 */
export interface ResPartSessionId {
    /**
     * The ID of the created session.
     * @type {string}
     * @memberof ResPartSessionId
     */
    'sessionId'?: string;
}
/**
 * 
 * @export
 * @interface ResPartSetting
 */
export interface ResPartSetting {
    /**
     * Various settings.
     * @type {ResSettings}
     * @memberof ResPartSetting
     */
    'setting'?: ResSettings;
}
/**
 * 
 * @export
 * @interface ResPartStatistic
 */
export interface ResPartStatistic {
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResPartStatistic
     */
    'statistic'?: ResStatistic;
}
/**
 * 
 * @export
 * @interface ResPartTemplates
 */
export interface ResPartTemplates {
    /**
     * Request templates for actions.
     * @type {Array<ResTemplate>}
     * @memberof ResPartTemplates
     */
    'templates'?: Array<ResTemplate>;
}
/**
 * 
 * @export
 * @interface ResPartTicket
 */
export interface ResPartTicket {
    /**
     * The ticket to create a model session.
     * @type {string}
     * @memberof ResPartTicket
     */
    'ticket'?: string;
}
/**
 * 
 * @export
 * @interface ResPartVersion
 */
export interface ResPartVersion {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResPartVersion
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ResPartViewer
 */
export interface ResPartViewer {
    /**
     * Viewer specific data.
     * @type {ResViewer}
     * @memberof ResPartViewer
     */
    'viewer'?: ResViewer;
}
/**
 * 
 * @export
 * @interface ResPartViewerSettingsVersion
 */
export interface ResPartViewerSettingsVersion {
    /**
     * The current version of the viewer settings.
     * @type {string}
     * @memberof ResPartViewerSettingsVersion
     */
    'viewerSettingsVersion'?: string;
}
/**
 * 
 * @export
 * @interface ResPartWarnings
 */
export interface ResPartWarnings {
    /**
     * An array of warnings encountered during request processing. These warnings indicate potential issues or non-critical conditions but did not prevent the request from being successfully processed.
     * @type {Array<string>}
     * @memberof ResPartWarnings
     */
    'warnings'?: Array<string>;
}
/**
 * Information about Grasshopper plugins.
 * @export
 * @interface ResPlugins
 */
export interface ResPlugins {
    /**
     * Libraries used by the model.
     * @type {Array<ResPluginsLibrary>}
     * @memberof ResPlugins
     */
    'libraries'?: Array<ResPluginsLibrary>;
}
/**
 * Definition of a model library.
 * @export
 * @interface ResPluginsLibrary
 */
export interface ResPluginsLibrary {
    /**
     * Library ID.
     * @type {string}
     * @memberof ResPluginsLibrary
     */
    'id': string;
    /**
     * Library version.
     * @type {string}
     * @memberof ResPluginsLibrary
     */
    'version': string;
    /**
     * Library name.
     * @type {string}
     * @memberof ResPluginsLibrary
     */
    'name': string;
    /**
     * Library author.
     * @type {string}
     * @memberof ResPluginsLibrary
     */
    'author': string;
    /**
     * Assembly name (not present in Rhino 5).
     * @type {string}
     * @memberof ResPluginsLibrary
     */
    'assemblyFullName'?: string;
    /**
     * Assembly version (not present in Rhino 5).
     * @type {string}
     * @memberof ResPluginsLibrary
     */
    'assemblyVersion'?: string;
}
/**
 * Combined output and export requests.
 * @export
 * @interface ResRateLimitedCombinedMetric
 */
export interface ResRateLimitedCombinedMetric {
    /**
     * Number of combined output and export requests charged.
     * @type {number}
     * @memberof ResRateLimitedCombinedMetric
     */
    'credits': number;
}
/**
 * Computations information.
 * @export
 * @interface ResRateLimitedComputationMetric
 */
export interface ResRateLimitedComputationMetric {
    /**
     * Number of computations.
     * @type {number}
     * @memberof ResRateLimitedComputationMetric
     */
    'count': number;
    /**
     * Number of finished 10-second chunks charged.
     * @type {number}
     * @memberof ResRateLimitedComputationMetric
     */
    'credits': number;
    /**
     * Total duration of computation time, in milliseconds.
     * @type {number}
     * @memberof ResRateLimitedComputationMetric
     */
    'duration': number;
    /**
     * Count of computations per computation time expressed in started 10-second chunks.
     * @type {{ [key: string]: number; }}
     * @memberof ResRateLimitedComputationMetric
     */
    'countPerChunks': { [key: string]: number; };
}
/**
 * Pure export requests.
 * @export
 * @interface ResRateLimitedExportMetric
 */
export interface ResRateLimitedExportMetric {
    /**
     * Number of pure export requests charged.
     * @type {number}
     * @memberof ResRateLimitedExportMetric
     */
    'credits': number;
}
/**
 * Pure output requests.
 * @export
 * @interface ResRateLimitedOutputMetric
 */
export interface ResRateLimitedOutputMetric {
    /**
     * Number of pure output requests.
     * @type {number}
     * @memberof ResRateLimitedOutputMetric
     */
    'count': number;
}
/**
 * Session information.
 * @export
 * @interface ResRateLimitedSessionMetric
 */
export interface ResRateLimitedSessionMetric {
    /**
     * Number of sessions.
     * @type {number}
     * @memberof ResRateLimitedSessionMetric
     */
    'count': number;
    /**
     * Number of started 10-minute periods of sessions charged.
     * @type {number}
     * @memberof ResRateLimitedSessionMetric
     */
    'credits': number;
    /**
     * The total duration of all sessions, in milliseconds.
     * @type {number}
     * @memberof ResRateLimitedSessionMetric
     */
    'duration': number;
}
/**
 * sdTF assets.
 * @export
 * @interface ResSdtfAsset
 */
export interface ResSdtfAsset {
    /**
     * A directory of parameter-IDs and asset-definitions.
     * @type {{ [key: string]: ResAssetDefinition; }}
     * @memberof ResSdtfAsset
     */
    'file'?: { [key: string]: ResAssetDefinition; };
    /**
     * 
     * @type {Array<ResAssetDefinition>}
     * @memberof ResSdtfAsset
     */
    'sdtf': Array<ResAssetDefinition>;
    /**
     * The asset-definition of a Model-State image.
     * @type {ResAssetDefinition}
     * @memberof ResSdtfAsset
     */
    'modelState'?: ResAssetDefinition;
}
/**
 * Result part for the response to a list request for sdTF objects.
 * @export
 * @interface ResSdtfInfo
 */
export interface ResSdtfInfo {
    /**
     * ID of the sdTF.
     * @type {string}
     * @memberof ResSdtfInfo
     */
    'id': string;
    /**
     * The namespace of the sdTF.
     * @type {string}
     * @memberof ResSdtfInfo
     */
    'namespace': string;
    /**
     * The size of the sdTF in bytes.
     * @type {number}
     * @memberof ResSdtfInfo
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface ResSdtfList
 */
export interface ResSdtfList {
    /**
     * A directory of file objects.
     * @type {Array<ResFileInfo>}
     * @memberof ResSdtfList
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     * @type {Array<ResSdtfInfo>}
     * @memberof ResSdtfList
     */
    'sdtf': Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     * @type {Array<ResModel>}
     * @memberof ResSdtfList
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     * @type {Array<ResModelStateInfo>}
     * @memberof ResSdtfList
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     * @type {Array<ResOutput>}
     * @memberof ResSdtfList
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     * @type {Array<ResExport>}
     * @memberof ResSdtfList
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     * @type {Array<ResTexture>}
     * @memberof ResSdtfList
     */
    'texture'?: Array<ResTexture>;
}
/**
 * Definition of settings.
 * @export
 * @interface ResSettings
 */
export interface ResSettings {
    /**
     * 
     * @type {ResAuthorizationSettings}
     * @memberof ResSettings
     */
    'auth'?: ResAuthorizationSettings;
    /**
     * 
     * @type {ResComputeSettings}
     * @memberof ResSettings
     */
    'compute'?: ResComputeSettings;
    /**
     * 
     * @type {ResModelSettings}
     * @memberof ResSettings
     */
    'model'?: ResModelSettings;
}
/**
 * Model statistic object.
 * @export
 * @interface ResStatistic
 */
export interface ResStatistic {
    /**
     * Cumulative time (msec) which has been spent for processing computation requests by the workers (pure computation time).
     * @type {number}
     * @memberof ResStatistic
     */
    'comptime'?: number;
    /**
     * Timestamp of last session created for the model.
     * @type {string}
     * @memberof ResStatistic
     */
    'lastsession'?: string;
    /**
     * Timestamp of last view of the model.
     * @type {string}
     * @memberof ResStatistic
     */
    'lastview'?: string;
    /**
     * Approximate memory usage of model on workers, in bytes.
     * @type {number}
     * @memberof ResStatistic
     */
    'memUsage'?: number;
    /**
     * Number of computations which have been carried out for the model by the workers so far.
     * @type {number}
     * @memberof ResStatistic
     */
    'numcomp'?: number;
    /**
     * Number of sessions which have been opened for the model so far.
     * @type {number}
     * @memberof ResStatistic
     */
    'numsessions'?: number;
    /**
     * Cumulative time (msec) which has been spent for processing computation requests by the workers (computation time plus overheads).
     * @type {number}
     * @memberof ResStatistic
     */
    'requesttime'?: number;
    /**
     * File size of the model file in bytes.
     * @type {number}
     * @memberof ResStatistic
     */
    'size'?: number;
}
/**
 * Structural information of a parameter.
 * @export
 * @enum {string}
 */

export const ResStructureType = {
    ITEM: 'item',
    LIST: 'list',
    TREE: 'tree'
} as const;

export type ResStructureType = typeof ResStructureType[keyof typeof ResStructureType];


/**
 * ShapeDiver API response of system-request.
 * @export
 * @interface ResSystem
 */
export interface ResSystem {
    /**
     * System information about the Geometry Minions.
     * @type {ResMinionInfo}
     * @memberof ResSystem
     */
    'minions'?: ResMinionInfo;
    /**
     * System information about the Geometry Workers.
     * @type {ResWorkerInfo}
     * @memberof ResSystem
     */
    'workers'?: ResWorkerInfo;
}
/**
 * Aggregated credit metrics for a system.
 * @export
 * @interface ResSystemCreditMetric
 */
export interface ResSystemCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     * @type {string}
     * @memberof ResSystemCreditMetric
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     * @type {boolean}
     * @memberof ResSystemCreditMetric
     */
    'isCompilationDone': boolean;
    /**
     * 
     * @type {ResArCreditMetric}
     * @memberof ResSystemCreditMetric
     */
    'ar': ResArCreditMetric;
    /**
     * 
     * @type {ResLoadingCreditMetric}
     * @memberof ResSystemCreditMetric
     */
    'loading': ResLoadingCreditMetric;
    /**
     * 
     * @type {ResLimitedCreditMetric}
     * @memberof ResSystemCreditMetric
     */
    'limited': ResLimitedCreditMetric;
    /**
     * 
     * @type {ResDefaultCreditMetric}
     * @memberof ResSystemCreditMetric
     */
    'default': ResDefaultCreditMetric;
    /**
     * Requested system.
     * @type {boolean}
     * @memberof ResSystemCreditMetric
     */
    'system': boolean;
}
/**
 * Provides templates for actions.
 * @export
 * @interface ResTemplate
 */
export interface ResTemplate {
    /**
     * Name of the template, e.g. \'customize-request\'.
     * @type {string}
     * @memberof ResTemplate
     */
    'name': string;
    /**
     * Title of the template, e.g. \'Template for model customization request\'.
     * @type {string}
     * @memberof ResTemplate
     */
    'title': string;
    /**
     * Template for the request body.
     * @type {object}
     * @memberof ResTemplate
     */
    'data': object;
}
/**
 * Information about a model texture.
 * @export
 * @interface ResTexture
 */
export interface ResTexture {
    /**
     * The ID of the ShapeDiver model.
     * @type {string}
     * @memberof ResTexture
     */
    'modelId': string;
    /**
     * The texture ID.
     * @type {string}
     * @memberof ResTexture
     */
    'textureId': string;
    /**
     * The original URL of the texture asset.
     * @type {string}
     * @memberof ResTexture
     */
    'url'?: string;
    /**
     * The width of the texture.
     * @type {number}
     * @memberof ResTexture
     */
    'width'?: number;
    /**
     * The height of the texture.
     * @type {number}
     * @memberof ResTexture
     */
    'height'?: number;
    /**
     * Is `true` when the texture has been cached, otherwise `false`.
     * @type {boolean}
     * @memberof ResTexture
     */
    'isAssetAvailable': boolean;
}
/**
 * 
 * @export
 * @interface ResTextureList
 */
export interface ResTextureList {
    /**
     * A directory of file objects.
     * @type {Array<ResFileInfo>}
     * @memberof ResTextureList
     */
    'file'?: Array<ResFileInfo>;
    /**
     * A directory of sdTF objects.
     * @type {Array<ResSdtfInfo>}
     * @memberof ResTextureList
     */
    'sdtf'?: Array<ResSdtfInfo>;
    /**
     * A directory of ShapeDiver models.
     * @type {Array<ResModel>}
     * @memberof ResTextureList
     */
    'model'?: Array<ResModel>;
    /**
     * A directory of Model-States.
     * @type {Array<ResModelStateInfo>}
     * @memberof ResTextureList
     */
    'modelState'?: Array<ResModelStateInfo>;
    /**
     * A directory of output versions.
     * @type {Array<ResOutput>}
     * @memberof ResTextureList
     */
    'output'?: Array<ResOutput>;
    /**
     * A directory of export versions.
     * @type {Array<ResExport>}
     * @memberof ResTextureList
     */
    'export'?: Array<ResExport>;
    /**
     * A directory of model textures.
     * @type {Array<ResTexture>}
     * @memberof ResTextureList
     */
    'texture': Array<ResTexture>;
}
/**
 * 
 * @export
 * @interface ResTicket
 */
export interface ResTicket {
    /**
     * List of domains (origins) this ticket should be limited to; may be empty.
     * @type {Array<string>}
     * @memberof ResTicket
     */
    'accessdomains': Array<string>;
    /**
     * Should this ticket provide access to model authoring (allows to change configuration)?
     * @type {boolean}
     * @memberof ResTicket
     */
    'author': boolean;
    /**
     * Should this ticket allow public access (ignore the model\'s `accessdomains` property)?
     * @type {boolean}
     * @memberof ResTicket
     */
    'pub': boolean;
    /**
     * The timestamp until which the ticket should be valid.
     * @type {string}
     * @memberof ResTicket
     */
    'until': string;
    /**
     * Does this ticket identify the model via its secondary ID (model property `id2`)?
     * @type {boolean}
     * @memberof ResTicket
     */
    'use_id2': boolean;
    /**
     * 
     * @type {ResTicketType}
     * @memberof ResTicket
     */
    'type': ResTicketType;
    /**
     * Either the model\'s `id` or `id2` property, depending on the ticket property `use_id2`.
     * @type {string}
     * @memberof ResTicket
     */
    'model_id': string;
}


/**
 * 
 * @export
 * @interface ResTicketAuthorization
 */
export interface ResTicketAuthorization {
    /**
     * List of domains (origins) this model is limited to (is ignored in case `model.pub` is true).
     * @type {Array<string>}
     * @memberof ResTicketAuthorization
     */
    'accessdomains': Array<string>;
    /**
     * Should backend access to the model be allowed.
     * @type {boolean}
     * @memberof ResTicketAuthorization
     */
    'backendaccess': boolean;
    /**
     * If this model allows public access (ignore `model.accessdomains`)?
     * @type {boolean}
     * @memberof ResTicketAuthorization
     */
    'pub': boolean;
}
/**
 * The type of the ticket.
 * @export
 * @enum {string}
 */

export const ResTicketType = {
    BACKEND: 'backend',
    NONE: ''
} as const;

export type ResTicketType = typeof ResTicketType[keyof typeof ResTicketType];


/**
 * 
 * @export
 * @interface ResTokenAuthorization
 */
export interface ResTokenAuthorization {
    /**
     * List of allowed auth-groups.
     * @type {Array<string>}
     * @memberof ResTokenAuthorization
     */
    'auth_groups'?: Array<string>;
    /**
     * Enforces iframe embedding instead of direct embedding.
     * @type {boolean}
     * @memberof ResTokenAuthorization
     */
    'require_iframe'?: boolean;
    /**
     * Enforces token-based authentication for this model.
     * @type {boolean}
     * @memberof ResTokenAuthorization
     */
    'require_token'?: boolean;
}
/**
 * 
 * @export
 * @interface ResUpdateExportDefinitions
 */
export interface ResUpdateExportDefinitions {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUpdateExportDefinitions
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResUpdateModel
 */
export interface ResUpdateModel {
    /**
     * Links regarding the model file.
     * @type {ResFile}
     * @memberof ResUpdateModel
     */
    'file': ResFile;
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResUpdateModel
     */
    'message'?: string;
    /**
     * The definitions of a ShapeDiver model.
     * @type {ResModel}
     * @memberof ResUpdateModel
     */
    'model': ResModel;
    /**
     * Various settings.
     * @type {ResSettings}
     * @memberof ResUpdateModel
     */
    'setting': ResSettings;
    /**
     * Statistics of a model.
     * @type {ResStatistic}
     * @memberof ResUpdateModel
     */
    'statistic': ResStatistic;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUpdateModel
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResUpdateModelConfig
 */
export interface ResUpdateModelConfig {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUpdateModelConfig
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResUpdateOutputDefinitions
 */
export interface ResUpdateOutputDefinitions {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUpdateOutputDefinitions
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResUpdateParameterDefaultValues
 */
export interface ResUpdateParameterDefaultValues {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUpdateParameterDefaultValues
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResUpdateParameterDefinitions
 */
export interface ResUpdateParameterDefinitions {
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUpdateParameterDefinitions
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResUploadFile
 */
export interface ResUploadFile {
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResUploadFile
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUploadFile
     */
    'version': string;
    /**
     * 
     * @type {ResFileAsset}
     * @memberof ResUploadFile
     */
    'asset': ResFileAsset;
}
/**
 * 
 * @export
 * @interface ResUploadGltf
 */
export interface ResUploadGltf {
    /**
     * glTF information.
     * @type {ResGltfUpload}
     * @memberof ResUploadGltf
     */
    'gltf': ResGltfUpload;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUploadGltf
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResUploadSdtf
 */
export interface ResUploadSdtf {
    /**
     * Contains urgent information about the system.
     * @type {string}
     * @memberof ResUploadSdtf
     */
    'message'?: string;
    /**
     * Version of the Geometry Backend API.
     * @type {string}
     * @memberof ResUploadSdtf
     */
    'version': string;
    /**
     * 
     * @type {ResSdtfAsset}
     * @memberof ResUploadSdtf
     */
    'asset': ResSdtfAsset;
}
/**
 * Aggregated credit metrics for a user.
 * @export
 * @interface ResUserCreditMetric
 */
export interface ResUserCreditMetric {
    /**
     * Either an extended date-time or a \'merged\'-specifier.
     * @type {string}
     * @memberof ResUserCreditMetric
     */
    'timestamp': string;
    /**
     * Aggregation for this timestamp has finished.
     * @type {boolean}
     * @memberof ResUserCreditMetric
     */
    'isCompilationDone': boolean;
    /**
     * 
     * @type {ResArCreditMetric}
     * @memberof ResUserCreditMetric
     */
    'ar': ResArCreditMetric;
    /**
     * 
     * @type {ResLoadingCreditMetric}
     * @memberof ResUserCreditMetric
     */
    'loading': ResLoadingCreditMetric;
    /**
     * 
     * @type {ResLimitedCreditMetric}
     * @memberof ResUserCreditMetric
     */
    'limited': ResLimitedCreditMetric;
    /**
     * 
     * @type {ResDefaultCreditMetric}
     * @memberof ResUserCreditMetric
     */
    'default': ResDefaultCreditMetric;
    /**
     * This property is never set.
     * @type {boolean}
     * @memberof ResUserCreditMetric
     * @deprecated
     */
    'modelId'?: boolean | null;
    /**
     * Requested user ID.
     * @type {string}
     * @memberof ResUserCreditMetric
     */
    'userId': string;
}
/**
 * Viewer config object.
 * @export
 * @interface ResViewer
 */
export interface ResViewer {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ResViewer
     */
    'config': { [key: string]: any; };
}
/**
 * Optional preferred visualization for parameters of type `FILE` and `STRINGLIST`.
 * @export
 * @enum {string}
 */

export const ResVisualizationType = {
    UNKNOWN: 'unknown',
    BUTTON: 'button',
    CALENDAR: 'calendar',
    CHECKLIST: 'checklist',
    CLOCK: 'clock',
    CYCLE: 'cycle',
    DIAL: 'dial',
    DROPDOWN: 'dropdown',
    GEOMETRY: 'geometry',
    IMAGE: 'image',
    SEQUENCE: 'sequence',
    SLIDER: 'slider',
    SWATCH: 'swatch',
    TEXT: 'text',
    TOGGLE: 'toggle'
} as const;

export type ResVisualizationType = typeof ResVisualizationType[keyof typeof ResVisualizationType];


/**
 * 
 * @export
 * @interface ResWarningComponent
 */
export interface ResWarningComponent {
    /**
     * ID of component.
     * @type {string}
     * @memberof ResWarningComponent
     */
    'component'?: string;
    /**
     * Instance ID of component.
     * @type {string}
     * @memberof ResWarningComponent
     */
    'instance': string;
    /**
     * Name of component.
     * @type {string}
     * @memberof ResWarningComponent
     */
    'name': string;
    /**
     * Nickname of component.
     * @type {string}
     * @memberof ResWarningComponent
     */
    'nick_name': string;
    /**
     * Component Warnings descriptions.
     * @type {Array<string>}
     * @memberof ResWarningComponent
     */
    'warnings': Array<string>;
}
/**
 * System information about the Geometry Workers.
 * @export
 * @interface ResWorkerInfo
 */
export interface ResWorkerInfo {
    /**
     * Version of the Grasshopper application.
     * @type {string}
     * @memberof ResWorkerInfo
     */
    'grasshopperVersion': string;
    /**
     * Holds information of all installed and allowed Grasshopper plugins.
     * @type {ResWorkerPlugins}
     * @memberof ResWorkerInfo
     */
    'plugins': ResWorkerPlugins;
    /**
     * Version of the Rhino application.
     * @type {string}
     * @memberof ResWorkerInfo
     */
    'rhinoVersion': string;
    /**
     * Version of the ShapeDiver worker plugin.
     * @type {string}
     * @memberof ResWorkerInfo
     */
    'shapeDiverVersion': string;
}
/**
 * A Grasshopper plugin component that may not be used.
 * @export
 * @interface ResWorkerPluginComponent
 */
export interface ResWorkerPluginComponent {
    /**
     * ID of the plugin component.
     * @type {string}
     * @memberof ResWorkerPluginComponent
     */
    'id': string;
    /**
     * Name of the plugin component.
     * @type {string}
     * @memberof ResWorkerPluginComponent
     */
    'name': string;
}
/**
 * Holds information of all installed and allowed Grasshopper plugins.
 * @export
 * @interface ResWorkerPlugins
 */
export interface ResWorkerPlugins {
    /**
     * Contains information about all installed Grasshopper plugins.
     * @type {Array<ResInstalledWorkerPlugin>}
     * @memberof ResWorkerPlugins
     */
    'installed': Array<ResInstalledWorkerPlugin>;
    /**
     * Contains the model checking configuration for the Grasshopper plugins.
     * @type {Array<ResAllowedWorkerPlugin>}
     * @memberof ResWorkerPlugins
     */
    'allowed': Array<ResAllowedWorkerPlugin>;
    /**
     * Contains information about plugin inconsistencies.
     * @type {Array<string>}
     * @memberof ResWorkerPlugins
     */
    'inconsistent': Array<string>;
}
/**
 * Worker system information.
 * @export
 * @interface ResWorkerSystem
 */
export interface ResWorkerSystem {
    /**
     * System information about the Geometry Minions.
     * @type {ResMinionInfo}
     * @memberof ResWorkerSystem
     */
    'minions'?: ResMinionInfo;
    /**
     * System information about the Geometry Workers.
     * @type {ResWorkerInfo}
     * @memberof ResWorkerSystem
     */
    'workers': ResWorkerInfo;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Subject-Restriction: __backend__ - ONLY for _system-metrics_.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics.
         * @param {ReqCreditMetrics} reqCreditMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditMetrics: async (reqCreditMetrics: ReqCreditMetrics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqCreditMetrics' is not null or undefined
            assertParamExists('getCreditMetrics', 'reqCreditMetrics', reqCreditMetrics)
            const localVarPath = `/api/v2/analytics/credit-metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCreditMetrics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the organization at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} orgId ID of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelOrganizationCreditMetrics: async (timestamp: string, orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getModelOrganizationCreditMetrics', 'timestamp', timestamp)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getModelOrganizationCreditMetrics', 'orgId', orgId)
            const localVarPath = `/api/v2/analytics/credit-metrics/timestamp/{timestamp}/org/{orgId}`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)))
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model session analytics.
         * @param {ReqModelStatistics} reqModelStatistics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStatistics: async (reqModelStatistics: ReqModelStatistics, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqModelStatistics' is not null or undefined
            assertParamExists('getModelStatistics', 'reqModelStatistics', reqModelStatistics)
            const localVarPath = `/api/v2/analytics/session/model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqModelStatistics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the user at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} userId ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelUserCreditMetrics: async (timestamp: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getModelUserCreditMetrics', 'timestamp', timestamp)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getModelUserCreditMetrics', 'userId', userId)
            const localVarPath = `/api/v2/analytics/credit-metrics/timestamp/{timestamp}/user/{userId}`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all organizations with users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCreditMetrics: async (timestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getOrganizationCreditMetrics', 'timestamp', timestamp)
            const localVarPath = `/api/v2/analytics/credit-metrics/timestamp/{timestamp}/org`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditMetrics: async (timestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getUserCreditMetrics', 'timestamp', timestamp)
            const localVarPath = `/api/v2/analytics/credit-metrics/timestamp/{timestamp}/user`
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Subject-Restriction: __backend__ - ONLY for _system-metrics_.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics.
         * @param {ReqCreditMetrics} reqCreditMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditMetrics(reqCreditMetrics: ReqCreditMetrics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditMetrics(reqCreditMetrics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the organization at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} orgId ID of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelOrganizationCreditMetrics(timestamp: string, orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelOrganizationCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelOrganizationCreditMetrics(timestamp, orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getModelOrganizationCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model session analytics.
         * @param {ReqModelStatistics} reqModelStatistics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelStatistics(reqModelStatistics: ReqModelStatistics, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelStatistics(reqModelStatistics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getModelStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the user at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} userId ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelUserCreditMetrics(timestamp: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelUserCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelUserCreditMetrics(timestamp, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getModelUserCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all organizations with users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetOrganizationCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCreditMetrics(timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getOrganizationCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetUserCreditMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCreditMetrics(timestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getUserCreditMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Subject-Restriction: __backend__ - ONLY for _system-metrics_.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics.
         * @param {ReqCreditMetrics} reqCreditMetrics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditMetrics(reqCreditMetrics: ReqCreditMetrics, options?: RawAxiosRequestConfig): AxiosPromise<ResGetCreditMetrics> {
            return localVarFp.getCreditMetrics(reqCreditMetrics, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the organization at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} orgId ID of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelOrganizationCreditMetrics(timestamp: string, orgId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelOrganizationCreditMetrics> {
            return localVarFp.getModelOrganizationCreditMetrics(timestamp, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model session analytics.
         * @param {ReqModelStatistics} reqModelStatistics 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStatistics(reqModelStatistics: ReqModelStatistics, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelStatistics> {
            return localVarFp.getModelStatistics(reqModelStatistics, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get model credit metrics of the user at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {string} userId ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelUserCreditMetrics(timestamp: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelUserCreditMetrics> {
            return localVarFp.getModelUserCreditMetrics(timestamp, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all organizations with users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetOrganizationCreditMetrics> {
            return localVarFp.getOrganizationCreditMetrics(timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `analytics.model.get.*` - __required__.
         * @summary Get credit metrics of all users active at timestamp.
         * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetUserCreditMetrics> {
            return localVarFp.getUserCreditMetrics(timestamp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Subject-Restriction: __backend__ - ONLY for _system-metrics_.  Permissions:  * `analytics.model.get.*` - __required__.
     * @summary Get credit metrics.
     * @param {ReqCreditMetrics} reqCreditMetrics 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getCreditMetrics(reqCreditMetrics: ReqCreditMetrics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getCreditMetrics(reqCreditMetrics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `analytics.model.get.*` - __required__.
     * @summary Get model credit metrics of the organization at timestamp.
     * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
     * @param {string} orgId ID of the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getModelOrganizationCreditMetrics(timestamp: string, orgId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getModelOrganizationCreditMetrics(timestamp, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `analytics.model.get.*` - __required__.
     * @summary Get model session analytics.
     * @param {ReqModelStatistics} reqModelStatistics 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getModelStatistics(reqModelStatistics: ReqModelStatistics, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getModelStatistics(reqModelStatistics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `analytics.model.get.*` - __required__.
     * @summary Get model credit metrics of the user at timestamp.
     * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
     * @param {string} userId ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getModelUserCreditMetrics(timestamp: string, userId: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getModelUserCreditMetrics(timestamp, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions:  * `analytics.model.get.*` - __required__.
     * @summary Get credit metrics of all organizations with users active at timestamp.
     * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getOrganizationCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getOrganizationCreditMetrics(timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions:  * `analytics.model.get.*` - __required__.
     * @summary Get credit metrics of all users active at timestamp.
     * @param {string} timestamp Timestamp of activity in format YYYY, YYYYMM, YYYYMMDD, or YYYYMMDDHH.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getUserCreditMetrics(timestamp: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getUserCreditMetrics(timestamp, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ArSceneApi - axios parameter creator
 * @export
 */
export const ArSceneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads the glTF asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArSceneGltf: async (sceneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sceneId' is not null or undefined
            assertParamExists('downloadArSceneGltf', 'sceneId', sceneId)
            const localVarPath = `/api/v2/ar-scene/{sceneId}/gltf`
                .replace(`{${"sceneId"}}`, encodeURIComponent(String(sceneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads the USDZ asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArSceneUsdz: async (sceneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sceneId' is not null or undefined
            assertParamExists('downloadArSceneUsdz', 'sceneId', sceneId)
            const localVarPath = `/api/v2/ar-scene/{sceneId}/usdz`
                .replace(`{${"sceneId"}}`, encodeURIComponent(String(sceneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies whether an AR scene exists or if a Model-State is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArSceneMetadata: async (sceneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sceneId' is not null or undefined
            assertParamExists('getArSceneMetadata', 'sceneId', sceneId)
            const localVarPath = `/api/v2/ar-scene/{sceneId}`
                .replace(`{${"sceneId"}}`, encodeURIComponent(String(sceneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArSceneApi - functional programming interface
 * @export
 */
export const ArSceneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArSceneApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Downloads the glTF asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArSceneGltf(sceneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArSceneGltf(sceneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArSceneApi.downloadArSceneGltf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Downloads the USDZ asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadArSceneUsdz(sceneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadArSceneUsdz(sceneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArSceneApi.downloadArSceneUsdz']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verifies whether an AR scene exists or if a Model-State is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArSceneMetadata(sceneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArSceneMetadata(sceneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArSceneApi.getArSceneMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArSceneApi - factory interface
 * @export
 */
export const ArSceneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArSceneApiFp(configuration)
    return {
        /**
         * 
         * @summary Downloads the glTF asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArSceneGltf(sceneId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadArSceneGltf(sceneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads the USDZ asset of an AR scene or a Model-State that is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadArSceneUsdz(sceneId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadArSceneUsdz(sceneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verifies whether an AR scene exists or if a Model-State is linked to an AR scene.
         * @param {string} sceneId ID of the AR scene or Model-State.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArSceneMetadata(sceneId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getArSceneMetadata(sceneId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArSceneApi - object-oriented interface
 * @export
 * @class ArSceneApi
 * @extends {BaseAPI}
 */
export class ArSceneApi extends BaseAPI {
    /**
     * 
     * @summary Downloads the glTF asset of an AR scene or a Model-State that is linked to an AR scene.
     * @param {string} sceneId ID of the AR scene or Model-State.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArSceneApi
     */
    public downloadArSceneGltf(sceneId: string, options?: RawAxiosRequestConfig) {
        return ArSceneApiFp(this.configuration).downloadArSceneGltf(sceneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads the USDZ asset of an AR scene or a Model-State that is linked to an AR scene.
     * @param {string} sceneId ID of the AR scene or Model-State.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArSceneApi
     */
    public downloadArSceneUsdz(sceneId: string, options?: RawAxiosRequestConfig) {
        return ArSceneApiFp(this.configuration).downloadArSceneUsdz(sceneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verifies whether an AR scene exists or if a Model-State is linked to an AR scene.
     * @param {string} sceneId ID of the AR scene or Model-State.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArSceneApi
     */
    public getArSceneMetadata(sceneId: string, options?: RawAxiosRequestConfig) {
        return ArSceneApiFp(this.configuration).getArSceneMetadata(sceneId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Download an asset without a session (can be used via an URL in an email).
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAsset: async (assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadAsset', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/download/{assetDataEncrypted}`
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a single export.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExport: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadExport', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadExport', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/export/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a glTF file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadGltf: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadGltf', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadGltf', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/gltf/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download an image.
         * @param {string} sessionId Session ID.
         * @param {string} url Specify the Base64-encoded image URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadImage: async (sessionId: string, url: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadImage', 'sessionId', sessionId)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('downloadImage', 'url', url)
            const localVarPath = `/api/v2/session/{sessionId}/image`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a single output.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOutput: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadOutput', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadOutput', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/output/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a single texture.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTexture: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadTexture', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadTexture', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/texture/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a USDZ file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUsdz: async (sessionId: string, assetDataEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadUsdz', 'sessionId', sessionId)
            // verify required parameter 'assetDataEncrypted' is not null or undefined
            assertParamExists('downloadUsdz', 'assetDataEncrypted', assetDataEncrypted)
            const localVarPath = `/api/v2/session/{sessionId}/usdz/{assetDataEncrypted}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"assetDataEncrypted"}}`, encodeURIComponent(String(assetDataEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Download an asset without a session (can be used via an URL in an email).
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAsset(assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAsset(assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a single export.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadExport(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadExport(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a glTF file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadGltf(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadGltf(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadGltf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download an image.
         * @param {string} sessionId Session ID.
         * @param {string} url Specify the Base64-encoded image URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadImage(sessionId: string, url: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadImage(sessionId, url, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a single output.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadOutput(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadOutput(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadOutput']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a single texture.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTexture(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTexture(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadTexture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a USDZ file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadUsdz(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadUsdz(sessionId, assetDataEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.downloadUsdz']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Download an asset without a session (can be used via an URL in an email).
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAsset(assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadAsset(assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a single export.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadExport(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadExport(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a glTF file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadGltf(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadGltf(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download an image.
         * @param {string} sessionId Session ID.
         * @param {string} url Specify the Base64-encoded image URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadImage(sessionId: string, url: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadImage(sessionId, url, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a single output.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOutput(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadOutput(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a single texture.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTexture(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadTexture(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a USDZ file.
         * @param {string} sessionId Session ID.
         * @param {string} assetDataEncrypted Encrypted asset data information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUsdz(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<ResError> {
            return localVarFp.downloadUsdz(sessionId, assetDataEncrypted, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * 
     * @summary Download an asset without a session (can be used via an URL in an email).
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public downloadAsset(assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadAsset(assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a single export.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public downloadExport(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadExport(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a glTF file.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public downloadGltf(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadGltf(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download an image.
     * @param {string} sessionId Session ID.
     * @param {string} url Specify the Base64-encoded image URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public downloadImage(sessionId: string, url: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadImage(sessionId, url, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a single output.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public downloadOutput(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadOutput(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a single texture.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public downloadTexture(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadTexture(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a USDZ file.
     * @param {string} sessionId Session ID.
     * @param {string} assetDataEncrypted Encrypted asset data information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public downloadUsdz(sessionId: string, assetDataEncrypted: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).downloadUsdz(sessionId, assetDataEncrypted, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the public keys of the JSON Web Key Set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKeySets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/jwks.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the public keys of the JSON Web Key Set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonWebKeySets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonWebKeySets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getJsonWebKeySets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the public keys of the JSON Web Key Set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKeySets(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getJsonWebKeySets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Get the public keys of the JSON Web Key Set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getJsonWebKeySets(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getJsonWebKeySets(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthGroupApi - axios parameter creator
 * @export
 */
export const AuthGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `auth_group.create` - __required__.
         * @summary Create new authorization group.
         * @param {ReqAuthorizationGroup} reqAuthorizationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorizationGroup: async (reqAuthorizationGroup: ReqAuthorizationGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqAuthorizationGroup' is not null or undefined
            assertParamExists('createAuthorizationGroup', 'reqAuthorizationGroup', reqAuthorizationGroup)
            const localVarPath = `/api/v2/auth_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqAuthorizationGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthGroupApi - functional programming interface
 * @export
 */
export const AuthGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `auth_group.create` - __required__.
         * @summary Create new authorization group.
         * @param {ReqAuthorizationGroup} reqAuthorizationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthorizationGroup(reqAuthorizationGroup: ReqAuthorizationGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateAuthorizationGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthorizationGroup(reqAuthorizationGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthGroupApi.createAuthorizationGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthGroupApi - factory interface
 * @export
 */
export const AuthGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthGroupApiFp(configuration)
    return {
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `auth_group.create` - __required__.
         * @summary Create new authorization group.
         * @param {ReqAuthorizationGroup} reqAuthorizationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorizationGroup(reqAuthorizationGroup: ReqAuthorizationGroup, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateAuthorizationGroup> {
            return localVarFp.createAuthorizationGroup(reqAuthorizationGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthGroupApi - object-oriented interface
 * @export
 * @class AuthGroupApi
 * @extends {BaseAPI}
 */
export class AuthGroupApi extends BaseAPI {
    /**
     * Subject-Restriction: __backend__.  Permissions:  * `auth_group.create` - __required__.
     * @summary Create new authorization group.
     * @param {ReqAuthorizationGroup} reqAuthorizationGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthGroupApi
     */
    public createAuthorizationGroup(reqAuthorizationGroup: ReqAuthorizationGroup, options?: RawAxiosRequestConfig) {
        return AuthGroupApiFp(this.configuration).createAuthorizationGroup(reqAuthorizationGroup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions:  * `compute.export.*` - __required__. * `compute.output.*` - __required__ when _outputs_ are requested.
         * @summary Compute a Grasshopper exports for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqExport} reqExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeExports: async (sessionId: string, reqExport: ReqExport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('computeExports', 'sessionId', sessionId)
            // verify required parameter 'reqExport' is not null or undefined
            assertParamExists('computeExports', 'reqExport', reqExport)
            const localVarPath = `/api/v2/session/{sessionId}/export`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `cache.export.get.*` - __required__. * `cache.output.get.*` - __required__ when _outputs_ are requested.
         * @summary Get Export from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqExportOrCache} reqExportOrCache 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedExports: async (sessionId: string, reqExportOrCache: ReqExportOrCache, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getCachedExports', 'sessionId', sessionId)
            // verify required parameter 'reqExportOrCache' is not null or undefined
            assertParamExists('getCachedExports', 'reqExportOrCache', reqExportOrCache)
            const localVarPath = `/api/v2/session/{sessionId}/export/cache`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqExportOrCache, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `cache.export.list.*` - __required__.
         * @summary List export versions.
         * @param {string} sessionId Session ID.
         * @param {string} exportId Export ID.
         * @param {QueryComputationStatus} [statusComputation] Filter export versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter export versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportVersions: async (sessionId: string, exportId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listExportVersions', 'sessionId', sessionId)
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists('listExportVersions', 'exportId', exportId)
            const localVarPath = `/api/v2/session/{sessionId}/export/{exportId}/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (statusComputation !== undefined) {
                localVarQueryParameter['statusComputation'] = statusComputation;
            }

            if (statusCollect !== undefined) {
                localVarQueryParameter['statusCollect'] = statusCollect;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `set.export.ui` - __required__.
         * @summary Update definition of exports.
         * @param {string} modelId Model ID.
         * @param {ReqExportDefinitions} reqExportDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportDefinitions: async (modelId: string, reqExportDefinitions: ReqExportDefinitions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateExportDefinitions', 'modelId', modelId)
            // verify required parameter 'reqExportDefinitions' is not null or undefined
            assertParamExists('updateExportDefinitions', 'reqExportDefinitions', reqExportDefinitions)
            const localVarPath = `/api/v2/model/{modelId}/export`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqExportDefinitions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions:  * `compute.export.*` - __required__. * `compute.output.*` - __required__ when _outputs_ are requested.
         * @summary Compute a Grasshopper exports for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqExport} reqExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeExports(sessionId: string, reqExport: ReqExport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResComputeExports>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeExports(sessionId, reqExport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.computeExports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `cache.export.get.*` - __required__. * `cache.output.get.*` - __required__ when _outputs_ are requested.
         * @summary Get Export from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqExportOrCache} reqExportOrCache 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCachedExports(sessionId: string, reqExportOrCache: ReqExportOrCache, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetCachedExports>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCachedExports(sessionId, reqExportOrCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.getCachedExports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `cache.export.list.*` - __required__.
         * @summary List export versions.
         * @param {string} sessionId Session ID.
         * @param {string} exportId Export ID.
         * @param {QueryComputationStatus} [statusComputation] Filter export versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter export versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExportVersions(sessionId: string, exportId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListExportVersions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExportVersions(sessionId, exportId, statusComputation, statusCollect, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.listExportVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `set.export.ui` - __required__.
         * @summary Update definition of exports.
         * @param {string} modelId Model ID.
         * @param {ReqExportDefinitions} reqExportDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExportDefinitions(modelId: string, reqExportDefinitions: ReqExportDefinitions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateExportDefinitions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExportDefinitions(modelId, reqExportDefinitions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.updateExportDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportApiFp(configuration)
    return {
        /**
         * Permissions:  * `compute.export.*` - __required__. * `compute.output.*` - __required__ when _outputs_ are requested.
         * @summary Compute a Grasshopper exports for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqExport} reqExport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeExports(sessionId: string, reqExport: ReqExport, options?: RawAxiosRequestConfig): AxiosPromise<ResComputeExports> {
            return localVarFp.computeExports(sessionId, reqExport, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `cache.export.get.*` - __required__. * `cache.output.get.*` - __required__ when _outputs_ are requested.
         * @summary Get Export from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqExportOrCache} reqExportOrCache 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedExports(sessionId: string, reqExportOrCache: ReqExportOrCache, options?: RawAxiosRequestConfig): AxiosPromise<ResGetCachedExports> {
            return localVarFp.getCachedExports(sessionId, reqExportOrCache, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `cache.export.list.*` - __required__.
         * @summary List export versions.
         * @param {string} sessionId Session ID.
         * @param {string} exportId Export ID.
         * @param {QueryComputationStatus} [statusComputation] Filter export versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter export versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportVersions(sessionId: string, exportId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListExportVersions> {
            return localVarFp.listExportVersions(sessionId, exportId, statusComputation, statusCollect, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `set.export.ui` - __required__.
         * @summary Update definition of exports.
         * @param {string} modelId Model ID.
         * @param {ReqExportDefinitions} reqExportDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportDefinitions(modelId: string, reqExportDefinitions: ReqExportDefinitions, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateExportDefinitions> {
            return localVarFp.updateExportDefinitions(modelId, reqExportDefinitions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * Permissions:  * `compute.export.*` - __required__. * `compute.output.*` - __required__ when _outputs_ are requested.
     * @summary Compute a Grasshopper exports for given parameter values.
     * @param {string} sessionId Session ID.
     * @param {ReqExport} reqExport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public computeExports(sessionId: string, reqExport: ReqExport, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).computeExports(sessionId, reqExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `cache.export.get.*` - __required__. * `cache.output.get.*` - __required__ when _outputs_ are requested.
     * @summary Get Export from cache / check if computation is done.
     * @param {string} sessionId Session ID.
     * @param {ReqExportOrCache} reqExportOrCache 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public getCachedExports(sessionId: string, reqExportOrCache: ReqExportOrCache, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).getCachedExports(sessionId, reqExportOrCache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `cache.export.list.*` - __required__.
     * @summary List export versions.
     * @param {string} sessionId Session ID.
     * @param {string} exportId Export ID.
     * @param {QueryComputationStatus} [statusComputation] Filter export versions by &#x60;status_computation&#x60;.
     * @param {QueryComputationStatus} [statusCollect] Filter export versions by &#x60;status_collect&#x60;.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public listExportVersions(sessionId: string, exportId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).listExportVersions(sessionId, exportId, statusComputation, statusCollect, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `set.export.ui` - __required__.
     * @summary Update definition of exports.
     * @param {string} modelId Model ID.
     * @param {ReqExportDefinitions} reqExportDefinitions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public updateExportDefinitions(modelId: string, reqExportDefinitions: ReqExportDefinitions, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).updateExportDefinitions(modelId, reqExportDefinitions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions:  * `asset.file.delete.*` - __required__.
         * @summary Delete a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (sessionId: string, paramId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteFile', 'sessionId', sessionId)
            // verify required parameter 'paramId' is not null or undefined
            assertParamExists('deleteFile', 'paramId', paramId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFile', 'fileId', fileId)
            const localVarPath = `/api/v2/session/{sessionId}/file/{paramId}/{fileId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"paramId"}}`, encodeURIComponent(String(paramId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `asset.file.get.*` - __required__.
         * @summary Download a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (sessionId: string, paramId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadFile', 'sessionId', sessionId)
            // verify required parameter 'paramId' is not null or undefined
            assertParamExists('downloadFile', 'paramId', paramId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadFile', 'fileId', fileId)
            const localVarPath = `/api/v2/session/{sessionId}/file/{paramId}/{fileId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"paramId"}}`, encodeURIComponent(String(paramId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about a file-asset of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMetadata: async (sessionId: string, paramId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getFileMetadata', 'sessionId', sessionId)
            // verify required parameter 'paramId' is not null or undefined
            assertParamExists('getFileMetadata', 'paramId', paramId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileMetadata', 'fileId', fileId)
            const localVarPath = `/api/v2/session/{sessionId}/file/{paramId}/{fileId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"paramId"}}`, encodeURIComponent(String(paramId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:   * `asset.file.list.*` - __required__.
         * @summary List all file-assets of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (sessionId: string, paramId: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listFiles', 'sessionId', sessionId)
            // verify required parameter 'paramId' is not null or undefined
            assertParamExists('listFiles', 'paramId', paramId)
            const localVarPath = `/api/v2/session/{sessionId}/file/{paramId}/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"paramId"}}`, encodeURIComponent(String(paramId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `asset.file.create.*` - __required__.
         * @summary Request upload URL for a file-asset.
         * @param {string} sessionId Session ID.
         * @param {ReqFileUpload} reqFileUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (sessionId: string, reqFileUpload: ReqFileUpload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('uploadFile', 'sessionId', sessionId)
            // verify required parameter 'reqFileUpload' is not null or undefined
            assertParamExists('uploadFile', 'reqFileUpload', reqFileUpload)
            const localVarPath = `/api/v2/session/{sessionId}/file/upload`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqFileUpload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions:  * `asset.file.delete.*` - __required__.
         * @summary Delete a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(sessionId, paramId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.deleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `asset.file.get.*` - __required__.
         * @summary Download a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(sessionId, paramId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about a file-asset of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileMetadata(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileMetadata(sessionId, paramId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getFileMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:   * `asset.file.list.*` - __required__.
         * @summary List all file-assets of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(sessionId: string, paramId: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListFiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(sessionId, paramId, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.listFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `asset.file.create.*` - __required__.
         * @summary Request upload URL for a file-asset.
         * @param {string} sessionId Session ID.
         * @param {ReqFileUpload} reqFileUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(sessionId: string, reqFileUpload: ReqFileUpload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUploadFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(sessionId, reqFileUpload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Permissions:  * `asset.file.delete.*` - __required__.
         * @summary Delete a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteFile> {
            return localVarFp.deleteFile(sessionId, paramId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `asset.file.get.*` - __required__.
         * @summary Download a file-asset.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadFile(sessionId, paramId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about a file-asset of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} fileId ID of the file asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMetadata(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getFileMetadata(sessionId, paramId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:   * `asset.file.list.*` - __required__.
         * @summary List all file-assets of a parameter.
         * @param {string} sessionId Session ID.
         * @param {string} paramId Parameter ID of the file asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(sessionId: string, paramId: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListFiles> {
            return localVarFp.listFiles(sessionId, paramId, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `asset.file.create.*` - __required__.
         * @summary Request upload URL for a file-asset.
         * @param {string} sessionId Session ID.
         * @param {ReqFileUpload} reqFileUpload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(sessionId: string, reqFileUpload: ReqFileUpload, options?: RawAxiosRequestConfig): AxiosPromise<ResUploadFile> {
            return localVarFp.uploadFile(sessionId, reqFileUpload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Permissions:  * `asset.file.delete.*` - __required__.
     * @summary Delete a file-asset.
     * @param {string} sessionId Session ID.
     * @param {string} paramId Parameter ID of the file asset.
     * @param {string} fileId ID of the file asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public deleteFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).deleteFile(sessionId, paramId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `asset.file.get.*` - __required__.
     * @summary Download a file-asset.
     * @param {string} sessionId Session ID.
     * @param {string} paramId Parameter ID of the file asset.
     * @param {string} fileId ID of the file asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public downloadFile(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).downloadFile(sessionId, paramId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about a file-asset of a parameter.
     * @param {string} sessionId Session ID.
     * @param {string} paramId Parameter ID of the file asset.
     * @param {string} fileId ID of the file asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getFileMetadata(sessionId: string, paramId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getFileMetadata(sessionId, paramId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:   * `asset.file.list.*` - __required__.
     * @summary List all file-assets of a parameter.
     * @param {string} sessionId Session ID.
     * @param {string} paramId Parameter ID of the file asset.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public listFiles(sessionId: string, paramId: string, offset?: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).listFiles(sessionId, paramId, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `asset.file.create.*` - __required__.
     * @summary Request upload URL for a file-asset.
     * @param {string} sessionId Session ID.
     * @param {ReqFileUpload} reqFileUpload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public uploadFile(sessionId: string, reqFileUpload: ReqFileUpload, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).uploadFile(sessionId, reqFileUpload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GltfApi - axios parameter creator
 * @export
 */
export const GltfApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload and optionally convert a glTF object.
         * @param {string} sessionId Session ID.
         * @param {File} body 
         * @param {QueryGltfConversion} [conversion] Specify to convert the uploaded glTF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGltf: async (sessionId: string, body: File, conversion?: QueryGltfConversion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('uploadGltf', 'sessionId', sessionId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadGltf', 'body', body)
            const localVarPath = `/api/v2/session/{sessionId}/gltf`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (conversion !== undefined) {
                localVarQueryParameter['conversion'] = conversion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'model/gltf-binary';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GltfApi - functional programming interface
 * @export
 */
export const GltfApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GltfApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload and optionally convert a glTF object.
         * @param {string} sessionId Session ID.
         * @param {File} body 
         * @param {QueryGltfConversion} [conversion] Specify to convert the uploaded glTF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadGltf(sessionId: string, body: File, conversion?: QueryGltfConversion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUploadGltf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadGltf(sessionId, body, conversion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GltfApi.uploadGltf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GltfApi - factory interface
 * @export
 */
export const GltfApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GltfApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload and optionally convert a glTF object.
         * @param {string} sessionId Session ID.
         * @param {File} body 
         * @param {QueryGltfConversion} [conversion] Specify to convert the uploaded glTF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGltf(sessionId: string, body: File, conversion?: QueryGltfConversion, options?: RawAxiosRequestConfig): AxiosPromise<ResUploadGltf> {
            return localVarFp.uploadGltf(sessionId, body, conversion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GltfApi - object-oriented interface
 * @export
 * @class GltfApi
 * @extends {BaseAPI}
 */
export class GltfApi extends BaseAPI {
    /**
     * 
     * @summary Upload and optionally convert a glTF object.
     * @param {string} sessionId Session ID.
     * @param {File} body 
     * @param {QueryGltfConversion} [conversion] Specify to convert the uploaded glTF.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GltfApi
     */
    public uploadGltf(sessionId: string, body: File, conversion?: QueryGltfConversion, options?: RawAxiosRequestConfig) {
        return GltfApiFp(this.configuration).uploadGltf(sessionId, body, conversion, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogApi - axios parameter creator
 * @export
 */
export const LogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Log message.
         * @param {string} sessionId Session ID.
         * @param {ReqLogMessage} reqLogMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logMessage: async (sessionId: string, reqLogMessage: ReqLogMessage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('logMessage', 'sessionId', sessionId)
            // verify required parameter 'reqLogMessage' is not null or undefined
            assertParamExists('logMessage', 'reqLogMessage', reqLogMessage)
            const localVarPath = `/api/v2/session/{sessionId}/log/message`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqLogMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogApi - functional programming interface
 * @export
 */
export const LogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Log message.
         * @param {string} sessionId Session ID.
         * @param {ReqLogMessage} reqLogMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logMessage(sessionId: string, reqLogMessage: ReqLogMessage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResLogMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logMessage(sessionId, reqLogMessage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogApi.logMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogApi - factory interface
 * @export
 */
export const LogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogApiFp(configuration)
    return {
        /**
         * 
         * @summary Log message.
         * @param {string} sessionId Session ID.
         * @param {ReqLogMessage} reqLogMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logMessage(sessionId: string, reqLogMessage: ReqLogMessage, options?: RawAxiosRequestConfig): AxiosPromise<ResLogMessage> {
            return localVarFp.logMessage(sessionId, reqLogMessage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export class LogApi extends BaseAPI {
    /**
     * 
     * @summary Log message.
     * @param {string} sessionId Session ID.
     * @param {ReqLogMessage} reqLogMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logMessage(sessionId: string, reqLogMessage: ReqLogMessage, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logMessage(sessionId, reqLogMessage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelApi - axios parameter creator
 * @export
 */
export const ModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions:  * `cache.export.delete.*` - __required__.
         * @summary Delete old export components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupExports: async (modelId: string, untilLastSeen: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('cleanupExports', 'modelId', modelId)
            // verify required parameter 'untilLastSeen' is not null or undefined
            assertParamExists('cleanupExports', 'untilLastSeen', untilLastSeen)
            const localVarPath = `/api/v2/model/{modelId}/cleanup/export`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (untilLastSeen !== undefined) {
                localVarQueryParameter['untilLastSeen'] = untilLastSeen;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:   * `cache.output.delete.*` - __required__.
         * @summary Delete old output components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupOutputs: async (modelId: string, untilLastSeen: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('cleanupOutputs', 'modelId', modelId)
            // verify required parameter 'untilLastSeen' is not null or undefined
            assertParamExists('cleanupOutputs', 'untilLastSeen', untilLastSeen)
            const localVarPath = `/api/v2/model/{modelId}/cleanup/output`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (untilLastSeen !== undefined) {
                localVarQueryParameter['untilLastSeen'] = untilLastSeen;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `cache.texture.delete.*` - __required__.
         * @summary Delete old texture components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupTextures: async (modelId: string, untilLastSeen: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('cleanupTextures', 'modelId', modelId)
            // verify required parameter 'untilLastSeen' is not null or undefined
            assertParamExists('cleanupTextures', 'untilLastSeen', untilLastSeen)
            const localVarPath = `/api/v2/model/{modelId}/cleanup/texture`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (untilLastSeen !== undefined) {
                localVarQueryParameter['untilLastSeen'] = untilLastSeen;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `create` - __required__ * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response if no model has already been   uploaded. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create model.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModel: async (reqModel: ReqModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqModel' is not null or undefined
            assertParamExists('createModel', 'reqModel', reqModel)
            const localVarPath = `/api/v2/model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `setting.viewer.set.*` - __required__.
         * @summary Create model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelConfig: async (modelId: string, reqConfigure: ReqConfigure, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('createModelConfig', 'modelId', modelId)
            // verify required parameter 'reqConfigure' is not null or undefined
            assertParamExists('createModelConfig', 'reqConfigure', reqConfigure)
            const localVarPath = `/api/v2/model/{modelId}/config`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqConfigure, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `delete.soft` - __required__.
         * @summary Delete model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('deleteModel', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:   * `file.download` - __required__.
         * @summary Download Grasshopper file.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadModelFile: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('downloadModelFile', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/file/download`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of all running model cleanup processes.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCleanupStatus: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getCleanupStatus', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/cleanup/status`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_. * `setting.compute.get.*` - optional: adds _settings.compute_. * `file.upload` - optional: adds _file.upload_. * `file.download` - optional: adds _file.download_. * `get.statistic.*` - optional: adds _statistic_. * `setting.viewer.get.*` - optional: adds _viewer_. * `get.parameter.*` - optional: adds _parameters_. * `get.output*` - optional: adds _output definitions_. * `get.export*` - optional: adds _export definitions_.
         * @summary Get model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getModel', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:   * `analytics.model.get.*` - __required__.
         * @summary Get model computation statistics.
         * @param {string} modelId Model ID.
         * @param {QueryOrder} [order] Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60;
         * @param {string} [timestampFrom] Timestamp to query from.  _Default:_ &#x60;0&#x60;
         * @param {string} [timestampTo] Timestamp to query to.  _Default:_ &#x60;infinity&#x60;
         * @param {QueryComputationStatisticsStatus} [status] Filter computations by the result status.  _Default:_ &#x60;*&#x60;
         * @param {QueryComputationType} [type] Filter computations by type.  _Default:_ &#x60;*&#x60;
         * @param {number} [limit] How many items to return at most.  _Default:_ &#x60;100&#x60;
         * @param {boolean} [strictLimit] Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60;
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelComputations: async (modelId: string, order?: QueryOrder, timestampFrom?: string, timestampTo?: string, status?: QueryComputationStatisticsStatus, type?: QueryComputationType, limit?: number, strictLimit?: boolean, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getModelComputations', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/computations`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (timestampFrom !== undefined) {
                localVarQueryParameter['timestamp_from'] = timestampFrom;
            }

            if (timestampTo !== undefined) {
                localVarQueryParameter['timestamp_to'] = timestampTo;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (strictLimit !== undefined) {
                localVarQueryParameter['strict_limit'] = strictLimit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `setting.viewer.get.*` - __required__.
         * @summary Get model config.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelConfig: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getModelConfig', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/config`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List models.
         * @param {QueryModelStatus} [modelStatus] Filter models by &#x60;stat&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (modelStatus?: QueryModelStatus, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/model/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (modelStatus !== undefined) {
                localVarQueryParameter['modelStatus'] = modelStatus;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Restore a soft-deleted model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('restoreModel', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/restore`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Update model.
         * @param {string} modelId Model ID.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel: async (modelId: string, reqModel: ReqModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateModel', 'modelId', modelId)
            // verify required parameter 'reqModel' is not null or undefined
            assertParamExists('updateModel', 'reqModel', reqModel)
            const localVarPath = `/api/v2/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating the model configuration requires _model authoring privilege_.  Permissions:  * `setting.viewer.set.*` - __required__.
         * @summary Update model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModelConfig: async (modelId: string, reqConfigure: ReqConfigure, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateModelConfig', 'modelId', modelId)
            // verify required parameter 'reqConfigure' is not null or undefined
            assertParamExists('updateModelConfig', 'reqConfigure', reqConfigure)
            const localVarPath = `/api/v2/model/{modelId}/config`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqConfigure, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating default parameter values requires model authoring privilege.  Permissions:   * `set.parameter.defval` - __required__.
         * @summary Update default value of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameterDefaultValues: async (modelId: string, reqCustomization: ReqCustomization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateParameterDefaultValues', 'modelId', modelId)
            // verify required parameter 'reqCustomization' is not null or undefined
            assertParamExists('updateParameterDefaultValues', 'reqCustomization', reqCustomization)
            const localVarPath = `/api/v2/model/{modelId}/parameter/defval`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCustomization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `set.parameter.ui` - __required__.
         * @summary Update definition of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqParameterDefinitions} reqParameterDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameterDefinitions: async (modelId: string, reqParameterDefinitions: ReqParameterDefinitions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateParameterDefinitions', 'modelId', modelId)
            // verify required parameter 'reqParameterDefinitions' is not null or undefined
            assertParamExists('updateParameterDefinitions', 'reqParameterDefinitions', reqParameterDefinitions)
            const localVarPath = `/api/v2/model/{modelId}/parameter`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqParameterDefinitions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelApi - functional programming interface
 * @export
 */
export const ModelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions:  * `cache.export.delete.*` - __required__.
         * @summary Delete old export components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupExports(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCleanupExports>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupExports(modelId, untilLastSeen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.cleanupExports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:   * `cache.output.delete.*` - __required__.
         * @summary Delete old output components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupOutputs(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCleanupOutputs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupOutputs(modelId, untilLastSeen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.cleanupOutputs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `cache.texture.delete.*` - __required__.
         * @summary Delete old texture components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanupTextures(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCleanupTextures>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanupTextures(modelId, untilLastSeen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.cleanupTextures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `create` - __required__ * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response if no model has already been   uploaded. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create model.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModel(reqModel: ReqModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModel(reqModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.createModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `setting.viewer.set.*` - __required__.
         * @summary Create model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateModelConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModelConfig(modelId, reqConfigure, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.createModelConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `delete.soft` - __required__.
         * @summary Delete model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.deleteModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:   * `file.download` - __required__.
         * @summary Download Grasshopper file.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadModelFile(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadModelFile(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.downloadModelFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the status of all running model cleanup processes.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCleanupStatus(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetCleanupStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCleanupStatus(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.getCleanupStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_. * `setting.compute.get.*` - optional: adds _settings.compute_. * `file.upload` - optional: adds _file.upload_. * `file.download` - optional: adds _file.download_. * `get.statistic.*` - optional: adds _statistic_. * `setting.viewer.get.*` - optional: adds _viewer_. * `get.parameter.*` - optional: adds _parameters_. * `get.output*` - optional: adds _output definitions_. * `get.export*` - optional: adds _export definitions_.
         * @summary Get model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.getModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:   * `analytics.model.get.*` - __required__.
         * @summary Get model computation statistics.
         * @param {string} modelId Model ID.
         * @param {QueryOrder} [order] Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60;
         * @param {string} [timestampFrom] Timestamp to query from.  _Default:_ &#x60;0&#x60;
         * @param {string} [timestampTo] Timestamp to query to.  _Default:_ &#x60;infinity&#x60;
         * @param {QueryComputationStatisticsStatus} [status] Filter computations by the result status.  _Default:_ &#x60;*&#x60;
         * @param {QueryComputationType} [type] Filter computations by type.  _Default:_ &#x60;*&#x60;
         * @param {number} [limit] How many items to return at most.  _Default:_ &#x60;100&#x60;
         * @param {boolean} [strictLimit] Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60;
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelComputations(modelId: string, order?: QueryOrder, timestampFrom?: string, timestampTo?: string, status?: QueryComputationStatisticsStatus, type?: QueryComputationType, limit?: number, strictLimit?: boolean, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelComputations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelComputations(modelId, order, timestampFrom, timestampTo, status, type, limit, strictLimit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.getModelComputations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `setting.viewer.get.*` - __required__.
         * @summary Get model config.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelConfig(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelConfig(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.getModelConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List models.
         * @param {QueryModelStatus} [modelStatus] Filter models by &#x60;stat&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(modelStatus?: QueryModelStatus, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListModels>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(modelStatus, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.listModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Restore a soft-deleted model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.restoreModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Update model.
         * @param {string} modelId Model ID.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModel(modelId: string, reqModel: ReqModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModel(modelId, reqModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.updateModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updating the model configuration requires _model authoring privilege_.  Permissions:  * `setting.viewer.set.*` - __required__.
         * @summary Update model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateModelConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModelConfig(modelId, reqConfigure, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.updateModelConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updating default parameter values requires model authoring privilege.  Permissions:   * `set.parameter.defval` - __required__.
         * @summary Update default value of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateParameterDefaultValues(modelId: string, reqCustomization: ReqCustomization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateParameterDefaultValues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateParameterDefaultValues(modelId, reqCustomization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.updateParameterDefaultValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `set.parameter.ui` - __required__.
         * @summary Update definition of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqParameterDefinitions} reqParameterDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateParameterDefinitions(modelId: string, reqParameterDefinitions: ReqParameterDefinitions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateParameterDefinitions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateParameterDefinitions(modelId, reqParameterDefinitions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelApi.updateParameterDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelApi - factory interface
 * @export
 */
export const ModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelApiFp(configuration)
    return {
        /**
         * Permissions:  * `cache.export.delete.*` - __required__.
         * @summary Delete old export components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupExports(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): AxiosPromise<ResCleanupExports> {
            return localVarFp.cleanupExports(modelId, untilLastSeen, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:   * `cache.output.delete.*` - __required__.
         * @summary Delete old output components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupOutputs(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): AxiosPromise<ResCleanupOutputs> {
            return localVarFp.cleanupOutputs(modelId, untilLastSeen, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `cache.texture.delete.*` - __required__.
         * @summary Delete old texture components.
         * @param {string} modelId Model ID.
         * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanupTextures(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig): AxiosPromise<ResCleanupTextures> {
            return localVarFp.cleanupTextures(modelId, untilLastSeen, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions: * `create` - __required__ * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response if no model has already been   uploaded. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create model.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModel(reqModel: ReqModel, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateModel> {
            return localVarFp.createModel(reqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `setting.viewer.set.*` - __required__.
         * @summary Create model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateModelConfig> {
            return localVarFp.createModelConfig(modelId, reqConfigure, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `delete.soft` - __required__.
         * @summary Delete model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteModel> {
            return localVarFp.deleteModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:   * `file.download` - __required__.
         * @summary Download Grasshopper file.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadModelFile(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadModelFile(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of all running model cleanup processes.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCleanupStatus(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetCleanupStatus> {
            return localVarFp.getCleanupStatus(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_. * `setting.compute.get.*` - optional: adds _settings.compute_. * `file.upload` - optional: adds _file.upload_. * `file.download` - optional: adds _file.download_. * `get.statistic.*` - optional: adds _statistic_. * `setting.viewer.get.*` - optional: adds _viewer_. * `get.parameter.*` - optional: adds _parameters_. * `get.output*` - optional: adds _output definitions_. * `get.export*` - optional: adds _export definitions_.
         * @summary Get model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModel> {
            return localVarFp.getModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:   * `analytics.model.get.*` - __required__.
         * @summary Get model computation statistics.
         * @param {string} modelId Model ID.
         * @param {QueryOrder} [order] Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60;
         * @param {string} [timestampFrom] Timestamp to query from.  _Default:_ &#x60;0&#x60;
         * @param {string} [timestampTo] Timestamp to query to.  _Default:_ &#x60;infinity&#x60;
         * @param {QueryComputationStatisticsStatus} [status] Filter computations by the result status.  _Default:_ &#x60;*&#x60;
         * @param {QueryComputationType} [type] Filter computations by type.  _Default:_ &#x60;*&#x60;
         * @param {number} [limit] How many items to return at most.  _Default:_ &#x60;100&#x60;
         * @param {boolean} [strictLimit] Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60;
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelComputations(modelId: string, order?: QueryOrder, timestampFrom?: string, timestampTo?: string, status?: QueryComputationStatisticsStatus, type?: QueryComputationType, limit?: number, strictLimit?: boolean, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelComputations> {
            return localVarFp.getModelComputations(modelId, order, timestampFrom, timestampTo, status, type, limit, strictLimit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `setting.viewer.get.*` - __required__.
         * @summary Get model config.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelConfig(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelConfig> {
            return localVarFp.getModelConfig(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List models.
         * @param {QueryModelStatus} [modelStatus] Filter models by &#x60;stat&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(modelStatus?: QueryModelStatus, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListModels> {
            return localVarFp.listModels(modelStatus, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Restore a soft-deleted model.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteModel> {
            return localVarFp.restoreModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Update model.
         * @param {string} modelId Model ID.
         * @param {ReqModel} reqModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel(modelId: string, reqModel: ReqModel, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateModel> {
            return localVarFp.updateModel(modelId, reqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating the model configuration requires _model authoring privilege_.  Permissions:  * `setting.viewer.set.*` - __required__.
         * @summary Update model config.
         * @param {string} modelId Model ID.
         * @param {ReqConfigure} reqConfigure 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateModelConfig> {
            return localVarFp.updateModelConfig(modelId, reqConfigure, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating default parameter values requires model authoring privilege.  Permissions:   * `set.parameter.defval` - __required__.
         * @summary Update default value of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameterDefaultValues(modelId: string, reqCustomization: ReqCustomization, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateParameterDefaultValues> {
            return localVarFp.updateParameterDefaultValues(modelId, reqCustomization, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `set.parameter.ui` - __required__.
         * @summary Update definition of parameters.
         * @param {string} modelId Model ID.
         * @param {ReqParameterDefinitions} reqParameterDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParameterDefinitions(modelId: string, reqParameterDefinitions: ReqParameterDefinitions, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateParameterDefinitions> {
            return localVarFp.updateParameterDefinitions(modelId, reqParameterDefinitions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelApi - object-oriented interface
 * @export
 * @class ModelApi
 * @extends {BaseAPI}
 */
export class ModelApi extends BaseAPI {
    /**
     * Permissions:  * `cache.export.delete.*` - __required__.
     * @summary Delete old export components.
     * @param {string} modelId Model ID.
     * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public cleanupExports(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).cleanupExports(modelId, untilLastSeen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:   * `cache.output.delete.*` - __required__.
     * @summary Delete old output components.
     * @param {string} modelId Model ID.
     * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public cleanupOutputs(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).cleanupOutputs(modelId, untilLastSeen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `cache.texture.delete.*` - __required__.
     * @summary Delete old texture components.
     * @param {string} modelId Model ID.
     * @param {string} untilLastSeen Delete all components that have been used last at or before this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public cleanupTextures(modelId: string, untilLastSeen: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).cleanupTextures(modelId, untilLastSeen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions: * `create` - __required__ * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response if no model has already been   uploaded. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
     * @summary Create model.
     * @param {ReqModel} reqModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public createModel(reqModel: ReqModel, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).createModel(reqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `setting.viewer.set.*` - __required__.
     * @summary Create model config.
     * @param {string} modelId Model ID.
     * @param {ReqConfigure} reqConfigure 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public createModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).createModelConfig(modelId, reqConfigure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions:  * `delete.soft` - __required__.
     * @summary Delete model.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public deleteModel(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).deleteModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:   * `file.download` - __required__.
     * @summary Download Grasshopper file.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public downloadModelFile(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).downloadModelFile(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of all running model cleanup processes.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public getCleanupStatus(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).getCleanupStatus(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_. * `setting.compute.get.*` - optional: adds _settings.compute_. * `file.upload` - optional: adds _file.upload_. * `file.download` - optional: adds _file.download_. * `get.statistic.*` - optional: adds _statistic_. * `setting.viewer.get.*` - optional: adds _viewer_. * `get.parameter.*` - optional: adds _parameters_. * `get.output*` - optional: adds _output definitions_. * `get.export*` - optional: adds _export definitions_.
     * @summary Get model.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public getModel(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).getModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:   * `analytics.model.get.*` - __required__.
     * @summary Get model computation statistics.
     * @param {string} modelId Model ID.
     * @param {QueryOrder} [order] Order in which to query computation stats items.  _Default:_ &#x60;desc&#x60;
     * @param {string} [timestampFrom] Timestamp to query from.  _Default:_ &#x60;0&#x60;
     * @param {string} [timestampTo] Timestamp to query to.  _Default:_ &#x60;infinity&#x60;
     * @param {QueryComputationStatisticsStatus} [status] Filter computations by the result status.  _Default:_ &#x60;*&#x60;
     * @param {QueryComputationType} [type] Filter computations by type.  _Default:_ &#x60;*&#x60;
     * @param {number} [limit] How many items to return at most.  _Default:_ &#x60;100&#x60;
     * @param {boolean} [strictLimit] Whether the limit shall be attained (if there are enough items).  _Default:_ &#x60;false&#x60;
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public getModelComputations(modelId: string, order?: QueryOrder, timestampFrom?: string, timestampTo?: string, status?: QueryComputationStatisticsStatus, type?: QueryComputationType, limit?: number, strictLimit?: boolean, offset?: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).getModelComputations(modelId, order, timestampFrom, timestampTo, status, type, limit, strictLimit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `setting.viewer.get.*` - __required__.
     * @summary Get model config.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public getModelConfig(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).getModelConfig(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary List models.
     * @param {QueryModelStatus} [modelStatus] Filter models by &#x60;stat&#x60;.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public listModels(modelStatus?: QueryModelStatus, offset?: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).listModels(modelStatus, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary Restore a soft-deleted model.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public restoreModel(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).restoreModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
     * @summary Update model.
     * @param {string} modelId Model ID.
     * @param {ReqModel} reqModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public updateModel(modelId: string, reqModel: ReqModel, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).updateModel(modelId, reqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating the model configuration requires _model authoring privilege_.  Permissions:  * `setting.viewer.set.*` - __required__.
     * @summary Update model config.
     * @param {string} modelId Model ID.
     * @param {ReqConfigure} reqConfigure 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public updateModelConfig(modelId: string, reqConfigure: ReqConfigure, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).updateModelConfig(modelId, reqConfigure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating default parameter values requires model authoring privilege.  Permissions:   * `set.parameter.defval` - __required__.
     * @summary Update default value of parameters.
     * @param {string} modelId Model ID.
     * @param {ReqCustomization} reqCustomization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public updateParameterDefaultValues(modelId: string, reqCustomization: ReqCustomization, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).updateParameterDefaultValues(modelId, reqCustomization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `set.parameter.ui` - __required__.
     * @summary Update definition of parameters.
     * @param {string} modelId Model ID.
     * @param {ReqParameterDefinitions} reqParameterDefinitions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public updateParameterDefinitions(modelId: string, reqParameterDefinitions: ReqParameterDefinitions, options?: RawAxiosRequestConfig) {
        return ModelApiFp(this.configuration).updateParameterDefinitions(modelId, reqParameterDefinitions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelStateApi - axios parameter creator
 * @export
 */
export const ModelStateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Model-State.
         * @param {string} sessionId Session ID.
         * @param {ReqModelState} reqModelState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelState: async (sessionId: string, reqModelState: ReqModelState, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('createModelState', 'sessionId', sessionId)
            // verify required parameter 'reqModelState' is not null or undefined
            assertParamExists('createModelState', 'reqModelState', reqModelState)
            const localVarPath = `/api/v2/session/{sessionId}/model-state`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqModelState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Delete a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelState: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('deleteModelState', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads the Model-State image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadModelStateImage: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('downloadModelStateImage', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}/image`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelState: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('getModelState', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Model-State\'s parameter and additional data.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateData: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('getModelStateData', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}/data`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the Model-State has an image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateImageMetadata: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('getModelStateImageMetadata', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}/image`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks the existence of a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateMetadata: async (modelStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelStateId' is not null or undefined
            assertParamExists('getModelStateMetadata', 'modelStateId', modelStateId)
            const localVarPath = `/api/v2/model-state/{modelStateId}`
                .replace(`{${"modelStateId"}}`, encodeURIComponent(String(modelStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List Model-States of a ShapeDiver model.
         * @param {string} modelId Model ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelStates: async (modelId: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('listModelStates', 'modelId', modelId)
            const localVarPath = `/api/v2/model-state/model/{modelId}/list`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelStateApi - functional programming interface
 * @export
 */
export const ModelStateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelStateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Model-State.
         * @param {string} sessionId Session ID.
         * @param {ReqModelState} reqModelState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModelState(sessionId: string, reqModelState: ReqModelState, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateModelState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModelState(sessionId, reqModelState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.createModelState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Delete a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModelState(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteModelState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModelState(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.deleteModelState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Downloads the Model-State image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadModelStateImage(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadModelStateImage(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.downloadModelStateImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelState(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelState(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.getModelState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a Model-State\'s parameter and additional data.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelStateData(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetModelStateData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelStateData(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.getModelStateData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the Model-State has an image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelStateImageMetadata(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelStateImageMetadata(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.getModelStateImageMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Checks the existence of a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelStateMetadata(modelStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelStateMetadata(modelStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.getModelStateMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List Model-States of a ShapeDiver model.
         * @param {string} modelId Model ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModelStates(modelId: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListModelStates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModelStates(modelId, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelStateApi.listModelStates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelStateApi - factory interface
 * @export
 */
export const ModelStateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelStateApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Model-State.
         * @param {string} sessionId Session ID.
         * @param {ReqModelState} reqModelState 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelState(sessionId: string, reqModelState: ReqModelState, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateModelState> {
            return localVarFp.createModelState(sessionId, reqModelState, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Delete a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelState(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteModelState> {
            return localVarFp.deleteModelState(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads the Model-State image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadModelStateImage(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadModelStateImage(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelState(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelState> {
            return localVarFp.getModelState(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Model-State\'s parameter and additional data.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateData(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetModelStateData> {
            return localVarFp.getModelStateData(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the Model-State has an image.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateImageMetadata(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getModelStateImageMetadata(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks the existence of a Model-State.
         * @param {string} modelStateId Model-State ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelStateMetadata(modelStateId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getModelStateMetadata(modelStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary List Model-States of a ShapeDiver model.
         * @param {string} modelId Model ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelStates(modelId: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListModelStates> {
            return localVarFp.listModelStates(modelId, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelStateApi - object-oriented interface
 * @export
 * @class ModelStateApi
 * @extends {BaseAPI}
 */
export class ModelStateApi extends BaseAPI {
    /**
     * 
     * @summary Create new Model-State.
     * @param {string} sessionId Session ID.
     * @param {ReqModelState} reqModelState 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelStateApi
     */
    public createModelState(sessionId: string, reqModelState: ReqModelState, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).createModelState(sessionId, reqModelState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary Delete a Model-State.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelStateApi
     */
    public deleteModelState(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).deleteModelState(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads the Model-State image.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelStateApi
     */
    public downloadModelStateImage(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).downloadModelStateImage(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Model-State.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelStateApi
     */
    public getModelState(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).getModelState(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Model-State\'s parameter and additional data.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelStateApi
     */
    public getModelStateData(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).getModelStateData(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the Model-State has an image.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelStateApi
     */
    public getModelStateImageMetadata(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).getModelStateImageMetadata(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks the existence of a Model-State.
     * @param {string} modelStateId Model-State ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelStateApi
     */
    public getModelStateMetadata(modelStateId: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).getModelStateMetadata(modelStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary List Model-States of a ShapeDiver model.
     * @param {string} modelId Model ID.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelStateApi
     */
    public listModelStates(modelId: string, offset?: string, options?: RawAxiosRequestConfig) {
        return ModelStateApiFp(this.configuration).listModelStates(modelId, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OutputApi - axios parameter creator
 * @export
 */
export const OutputApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions:   * `compute.output.*` - __required__.
         * @summary Compute all outputs for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeOutputs: async (sessionId: string, reqCustomization: ReqCustomization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('computeOutputs', 'sessionId', sessionId)
            // verify required parameter 'reqCustomization' is not null or undefined
            assertParamExists('computeOutputs', 'reqCustomization', reqCustomization)
            const localVarPath = `/api/v2/session/{sessionId}/output`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCustomization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `cache.output.get.*` - __required__.
         * @summary Get output from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqCache | ReqCustomization} reqCacheReqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedOutputs: async (sessionId: string, reqCacheReqCustomization: ReqCache | ReqCustomization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getCachedOutputs', 'sessionId', sessionId)
            // verify required parameter 'reqCacheReqCustomization' is not null or undefined
            assertParamExists('getCachedOutputs', 'reqCacheReqCustomization', reqCacheReqCustomization)
            const localVarPath = `/api/v2/session/{sessionId}/output/cache`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCacheReqCustomization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `cache.output.list.*` - __required__.
         * @summary List output versions.
         * @param {string} sessionId Session ID.
         * @param {string} outputId Output ID.
         * @param {QueryComputationStatus} [statusComputation] Filter output versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter output versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutputVersions: async (sessionId: string, outputId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listOutputVersions', 'sessionId', sessionId)
            // verify required parameter 'outputId' is not null or undefined
            assertParamExists('listOutputVersions', 'outputId', outputId)
            const localVarPath = `/api/v2/session/{sessionId}/output/{outputId}/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"outputId"}}`, encodeURIComponent(String(outputId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (statusComputation !== undefined) {
                localVarQueryParameter['statusComputation'] = statusComputation;
            }

            if (statusCollect !== undefined) {
                localVarQueryParameter['statusCollect'] = statusCollect;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `set.output.ui` - __required__.
         * @summary Update definition of outputs.
         * @param {string} modelId Model ID.
         * @param {ReqOutputDefinitions} reqOutputDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOutputDefinitions: async (modelId: string, reqOutputDefinitions: ReqOutputDefinitions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('updateOutputDefinitions', 'modelId', modelId)
            // verify required parameter 'reqOutputDefinitions' is not null or undefined
            assertParamExists('updateOutputDefinitions', 'reqOutputDefinitions', reqOutputDefinitions)
            const localVarPath = `/api/v2/model/{modelId}/output`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqOutputDefinitions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OutputApi - functional programming interface
 * @export
 */
export const OutputApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OutputApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions:   * `compute.output.*` - __required__.
         * @summary Compute all outputs for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeOutputs(sessionId: string, reqCustomization: ReqCustomization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResComputeOutputs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeOutputs(sessionId, reqCustomization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputApi.computeOutputs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `cache.output.get.*` - __required__.
         * @summary Get output from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqCache | ReqCustomization} reqCacheReqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCachedOutputs(sessionId: string, reqCacheReqCustomization: ReqCache | ReqCustomization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetCachedOutputs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCachedOutputs(sessionId, reqCacheReqCustomization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputApi.getCachedOutputs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `cache.output.list.*` - __required__.
         * @summary List output versions.
         * @param {string} sessionId Session ID.
         * @param {string} outputId Output ID.
         * @param {QueryComputationStatus} [statusComputation] Filter output versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter output versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOutputVersions(sessionId: string, outputId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListOutputVersions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOutputVersions(sessionId, outputId, statusComputation, statusCollect, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputApi.listOutputVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `set.output.ui` - __required__.
         * @summary Update definition of outputs.
         * @param {string} modelId Model ID.
         * @param {ReqOutputDefinitions} reqOutputDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOutputDefinitions(modelId: string, reqOutputDefinitions: ReqOutputDefinitions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUpdateOutputDefinitions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOutputDefinitions(modelId, reqOutputDefinitions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OutputApi.updateOutputDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OutputApi - factory interface
 * @export
 */
export const OutputApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OutputApiFp(configuration)
    return {
        /**
         * Permissions:   * `compute.output.*` - __required__.
         * @summary Compute all outputs for given parameter values.
         * @param {string} sessionId Session ID.
         * @param {ReqCustomization} reqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeOutputs(sessionId: string, reqCustomization: ReqCustomization, options?: RawAxiosRequestConfig): AxiosPromise<ResComputeOutputs> {
            return localVarFp.computeOutputs(sessionId, reqCustomization, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `cache.output.get.*` - __required__.
         * @summary Get output from cache / check if computation is done.
         * @param {string} sessionId Session ID.
         * @param {ReqCache | ReqCustomization} reqCacheReqCustomization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCachedOutputs(sessionId: string, reqCacheReqCustomization: ReqCache | ReqCustomization, options?: RawAxiosRequestConfig): AxiosPromise<ResGetCachedOutputs> {
            return localVarFp.getCachedOutputs(sessionId, reqCacheReqCustomization, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `cache.output.list.*` - __required__.
         * @summary List output versions.
         * @param {string} sessionId Session ID.
         * @param {string} outputId Output ID.
         * @param {QueryComputationStatus} [statusComputation] Filter output versions by &#x60;status_computation&#x60;.
         * @param {QueryComputationStatus} [statusCollect] Filter output versions by &#x60;status_collect&#x60;.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOutputVersions(sessionId: string, outputId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListOutputVersions> {
            return localVarFp.listOutputVersions(sessionId, outputId, statusComputation, statusCollect, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `set.output.ui` - __required__.
         * @summary Update definition of outputs.
         * @param {string} modelId Model ID.
         * @param {ReqOutputDefinitions} reqOutputDefinitions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOutputDefinitions(modelId: string, reqOutputDefinitions: ReqOutputDefinitions, options?: RawAxiosRequestConfig): AxiosPromise<ResUpdateOutputDefinitions> {
            return localVarFp.updateOutputDefinitions(modelId, reqOutputDefinitions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OutputApi - object-oriented interface
 * @export
 * @class OutputApi
 * @extends {BaseAPI}
 */
export class OutputApi extends BaseAPI {
    /**
     * Permissions:   * `compute.output.*` - __required__.
     * @summary Compute all outputs for given parameter values.
     * @param {string} sessionId Session ID.
     * @param {ReqCustomization} reqCustomization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutputApi
     */
    public computeOutputs(sessionId: string, reqCustomization: ReqCustomization, options?: RawAxiosRequestConfig) {
        return OutputApiFp(this.configuration).computeOutputs(sessionId, reqCustomization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `cache.output.get.*` - __required__.
     * @summary Get output from cache / check if computation is done.
     * @param {string} sessionId Session ID.
     * @param {ReqCache | ReqCustomization} reqCacheReqCustomization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutputApi
     */
    public getCachedOutputs(sessionId: string, reqCacheReqCustomization: ReqCache | ReqCustomization, options?: RawAxiosRequestConfig) {
        return OutputApiFp(this.configuration).getCachedOutputs(sessionId, reqCacheReqCustomization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `cache.output.list.*` - __required__.
     * @summary List output versions.
     * @param {string} sessionId Session ID.
     * @param {string} outputId Output ID.
     * @param {QueryComputationStatus} [statusComputation] Filter output versions by &#x60;status_computation&#x60;.
     * @param {QueryComputationStatus} [statusCollect] Filter output versions by &#x60;status_collect&#x60;.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutputApi
     */
    public listOutputVersions(sessionId: string, outputId: string, statusComputation?: QueryComputationStatus, statusCollect?: QueryComputationStatus, offset?: string, options?: RawAxiosRequestConfig) {
        return OutputApiFp(this.configuration).listOutputVersions(sessionId, outputId, statusComputation, statusCollect, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `set.output.ui` - __required__.
     * @summary Update definition of outputs.
     * @param {string} modelId Model ID.
     * @param {ReqOutputDefinitions} reqOutputDefinitions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutputApi
     */
    public updateOutputDefinitions(modelId: string, reqOutputDefinitions: ReqOutputDefinitions, options?: RawAxiosRequestConfig) {
        return OutputApiFp(this.configuration).updateOutputDefinitions(modelId, reqOutputDefinitions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScriptApi - axios parameter creator
 * @export
 */
export const ScriptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions:   * `script.confirm.*` - __required__.
         * @summary Confirm script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmScript: async (scriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptId' is not null or undefined
            assertParamExists('confirmScript', 'scriptId', scriptId)
            const localVarPath = `/api/v2/script/{scriptId}/confirm`
                .replace(`{${"scriptId"}}`, encodeURIComponent(String(scriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:   * `script.deny.*` - __required__.
         * @summary Deny script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyScript: async (scriptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptId' is not null or undefined
            assertParamExists('denyScript', 'scriptId', scriptId)
            const localVarPath = `/api/v2/script/{scriptId}/deny`
                .replace(`{${"scriptId"}}`, encodeURIComponent(String(scriptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScriptApi - functional programming interface
 * @export
 */
export const ScriptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScriptApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions:   * `script.confirm.*` - __required__.
         * @summary Confirm script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmScript(scriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmScript(scriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScriptApi.confirmScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:   * `script.deny.*` - __required__.
         * @summary Deny script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denyScript(scriptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denyScript(scriptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScriptApi.denyScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScriptApi - factory interface
 * @export
 */
export const ScriptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScriptApiFp(configuration)
    return {
        /**
         * Permissions:   * `script.confirm.*` - __required__.
         * @summary Confirm script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmScript(scriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.confirmScript(scriptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:   * `script.deny.*` - __required__.
         * @summary Deny script.
         * @param {string} scriptId Script ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyScript(scriptId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.denyScript(scriptId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScriptApi - object-oriented interface
 * @export
 * @class ScriptApi
 * @extends {BaseAPI}
 */
export class ScriptApi extends BaseAPI {
    /**
     * Permissions:   * `script.confirm.*` - __required__.
     * @summary Confirm script.
     * @param {string} scriptId Script ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public confirmScript(scriptId: string, options?: RawAxiosRequestConfig) {
        return ScriptApiFp(this.configuration).confirmScript(scriptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:   * `script.deny.*` - __required__.
     * @summary Deny script.
     * @param {string} scriptId Script ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptApi
     */
    public denyScript(scriptId: string, options?: RawAxiosRequestConfig) {
        return ScriptApiFp(this.configuration).denyScript(scriptId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SdtfApi - axios parameter creator
 * @export
 */
export const SdtfApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions:  * `asset.sdtf.delete.*` - __required__.
         * @summary Delete a sdTF-assets.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSdtf: async (sessionId: string, namespace: string, sdtfId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteSdtf', 'sessionId', sessionId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteSdtf', 'namespace', namespace)
            // verify required parameter 'sdtfId' is not null or undefined
            assertParamExists('deleteSdtf', 'sdtfId', sdtfId)
            const localVarPath = `/api/v2/session/{sessionId}/sdtf/{namespace}/{sdtfId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"sdtfId"}}`, encodeURIComponent(String(sdtfId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `asset.sdtf.get.*` - __required__.
         * @summary Download a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSdtf: async (sessionId: string, namespace: string, sdtfId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('downloadSdtf', 'sessionId', sessionId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('downloadSdtf', 'namespace', namespace)
            // verify required parameter 'sdtfId' is not null or undefined
            assertParamExists('downloadSdtf', 'sdtfId', sdtfId)
            const localVarPath = `/api/v2/session/{sessionId}/sdtf/{namespace}/{sdtfId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"sdtfId"}}`, encodeURIComponent(String(sdtfId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `asset.sdtf.list.*` - __required__.
         * @summary List all sdTF-assets of a namespace.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSdtfs: async (sessionId: string, namespace: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listSdtfs', 'sessionId', sessionId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listSdtfs', 'namespace', namespace)
            const localVarPath = `/api/v2/session/{sessionId}/sdtf/{namespace}/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:   * `asset.sdtf.create.*` - __required__.
         * @summary Request upload URL for a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {Array<ReqSdtfDefinition>} reqSdtfDefinition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSdtf: async (sessionId: string, reqSdtfDefinition: Array<ReqSdtfDefinition>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('uploadSdtf', 'sessionId', sessionId)
            // verify required parameter 'reqSdtfDefinition' is not null or undefined
            assertParamExists('uploadSdtf', 'reqSdtfDefinition', reqSdtfDefinition)
            const localVarPath = `/api/v2/session/{sessionId}/sdtf/upload`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqSdtfDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SdtfApi - functional programming interface
 * @export
 */
export const SdtfApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SdtfApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions:  * `asset.sdtf.delete.*` - __required__.
         * @summary Delete a sdTF-assets.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteSdtf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSdtf(sessionId, namespace, sdtfId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SdtfApi.deleteSdtf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `asset.sdtf.get.*` - __required__.
         * @summary Download a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSdtf(sessionId, namespace, sdtfId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SdtfApi.downloadSdtf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `asset.sdtf.list.*` - __required__.
         * @summary List all sdTF-assets of a namespace.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSdtfs(sessionId: string, namespace: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListSdtfs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSdtfs(sessionId, namespace, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SdtfApi.listSdtfs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:   * `asset.sdtf.create.*` - __required__.
         * @summary Request upload URL for a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {Array<ReqSdtfDefinition>} reqSdtfDefinition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSdtf(sessionId: string, reqSdtfDefinition: Array<ReqSdtfDefinition>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResUploadSdtf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSdtf(sessionId, reqSdtfDefinition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SdtfApi.uploadSdtf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SdtfApi - factory interface
 * @export
 */
export const SdtfApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SdtfApiFp(configuration)
    return {
        /**
         * Permissions:  * `asset.sdtf.delete.*` - __required__.
         * @summary Delete a sdTF-assets.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteSdtf> {
            return localVarFp.deleteSdtf(sessionId, namespace, sdtfId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `asset.sdtf.get.*` - __required__.
         * @summary Download a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} sdtfId ID of the sdTF asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadSdtf(sessionId, namespace, sdtfId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `asset.sdtf.list.*` - __required__.
         * @summary List all sdTF-assets of a namespace.
         * @param {string} sessionId Session ID.
         * @param {string} namespace Namespace of the sdTF asset.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSdtfs(sessionId: string, namespace: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListSdtfs> {
            return localVarFp.listSdtfs(sessionId, namespace, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:   * `asset.sdtf.create.*` - __required__.
         * @summary Request upload URL for a sdTF-asset.
         * @param {string} sessionId Session ID.
         * @param {Array<ReqSdtfDefinition>} reqSdtfDefinition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSdtf(sessionId: string, reqSdtfDefinition: Array<ReqSdtfDefinition>, options?: RawAxiosRequestConfig): AxiosPromise<ResUploadSdtf> {
            return localVarFp.uploadSdtf(sessionId, reqSdtfDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SdtfApi - object-oriented interface
 * @export
 * @class SdtfApi
 * @extends {BaseAPI}
 */
export class SdtfApi extends BaseAPI {
    /**
     * Permissions:  * `asset.sdtf.delete.*` - __required__.
     * @summary Delete a sdTF-assets.
     * @param {string} sessionId Session ID.
     * @param {string} namespace Namespace of the sdTF asset.
     * @param {string} sdtfId ID of the sdTF asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdtfApi
     */
    public deleteSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig) {
        return SdtfApiFp(this.configuration).deleteSdtf(sessionId, namespace, sdtfId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `asset.sdtf.get.*` - __required__.
     * @summary Download a sdTF-asset.
     * @param {string} sessionId Session ID.
     * @param {string} namespace Namespace of the sdTF asset.
     * @param {string} sdtfId ID of the sdTF asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdtfApi
     */
    public downloadSdtf(sessionId: string, namespace: string, sdtfId: string, options?: RawAxiosRequestConfig) {
        return SdtfApiFp(this.configuration).downloadSdtf(sessionId, namespace, sdtfId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `asset.sdtf.list.*` - __required__.
     * @summary List all sdTF-assets of a namespace.
     * @param {string} sessionId Session ID.
     * @param {string} namespace Namespace of the sdTF asset.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdtfApi
     */
    public listSdtfs(sessionId: string, namespace: string, offset?: string, options?: RawAxiosRequestConfig) {
        return SdtfApiFp(this.configuration).listSdtfs(sessionId, namespace, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:   * `asset.sdtf.create.*` - __required__.
     * @summary Request upload URL for a sdTF-asset.
     * @param {string} sessionId Session ID.
     * @param {Array<ReqSdtfDefinition>} reqSdtfDefinition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdtfApi
     */
    public uploadSdtf(sessionId: string, reqSdtfDefinition: Array<ReqSdtfDefinition>, options?: RawAxiosRequestConfig) {
        return SdtfApiFp(this.configuration).uploadSdtf(sessionId, reqSdtfDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Close session.
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('closeSession', 'sessionId', sessionId)
            const localVarPath = `/api/v2/session/{sessionId}/close`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `auth.session` - __required__. * `get.parameter.*` - optional: adds _parameters_ to response. * Output:    * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:     * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by model ID.
         * @param {string} modelId Model ID.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [strictValidation] When &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model is ignored. However, when set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionByModel: async (modelId: string, modelStateId?: string, strictValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('createSessionByModel', 'modelId', modelId)
            const localVarPath = `/api/v2/model/{modelId}/session`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (modelStateId !== undefined) {
                localVarQueryParameter['modelStateId'] = modelStateId;
            }

            if (strictValidation !== undefined) {
                localVarQueryParameter['strictValidation'] = strictValidation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCustomizationOrExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `get.parameter.*` - optional: adds _parameters_ to response. * Output:    * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by ticket.
         * @param {string} ticketId Encrypted ticket.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [strictValidation] When &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model is ignored. However, when set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionByTicket: async (ticketId: string, modelStateId?: string, strictValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('createSessionByTicket', 'ticketId', ticketId)
            const localVarPath = `/api/v2/ticket/{ticketId}`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (modelStateId !== undefined) {
                localVarQueryParameter['modelStateId'] = modelStateId;
            }

            if (strictValidation !== undefined) {
                localVarQueryParameter['strictValidation'] = strictValidation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqCustomizationOrExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:   * `setting.auth.ticket.create.*` - __required__. * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create a new ticket that allows to initialize a new session.
         * @param {string} modelId Model ID.
         * @param {ReqTicket} reqTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (modelId: string, reqTicket: ReqTicket, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('createTicket', 'modelId', modelId)
            // verify required parameter 'reqTicket' is not null or undefined
            assertParamExists('createTicket', 'reqTicket', reqTicket)
            const localVarPath = `/api/v2/model/{modelId}/ticket`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reqTicket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `setting.auth.ticket.decrypt.*` - __required__.
         * @summary Decrypt the given ticket and return its details.
         * @param {string} ticketEncrypted Encrypted ShapeDiver ticket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decryptTicket: async (ticketEncrypted: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketEncrypted' is not null or undefined
            assertParamExists('decryptTicket', 'ticketEncrypted', ticketEncrypted)
            const localVarPath = `/api/v2/ticket/{ticketEncrypted}`
                .replace(`{${"ticketEncrypted"}}`, encodeURIComponent(String(ticketEncrypted)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permissions:  * `get.parameter.*` - optional: adds _parameter defaults_ to response. * `get.export.*` - optional: adds _export definitions_ to response. * `compute.output.*` - optional: adds _outputs for default parameters_ to response. * `get.output.*` - optional: adds _output definitions_ to response.
         * @summary Get session defaults (corresponds to the content of the session initialization request).
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionDefaults: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSessionDefaults', 'sessionId', sessionId)
            const localVarPath = `/api/v2/session/{sessionId}/default`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Close session.
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCloseSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.closeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `auth.session` - __required__. * `get.parameter.*` - optional: adds _parameters_ to response. * Output:    * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:     * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by model ID.
         * @param {string} modelId Model ID.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [strictValidation] When &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model is ignored. However, when set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSessionByModel(modelId: string, modelStateId?: string, strictValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateSessionByModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSessionByModel(modelId, modelStateId, strictValidation, reqCustomizationOrExport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.createSessionByModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `get.parameter.*` - optional: adds _parameters_ to response. * Output:    * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by ticket.
         * @param {string} ticketId Encrypted ticket.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [strictValidation] When &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model is ignored. However, when set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSessionByTicket(ticketId: string, modelStateId?: string, strictValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateSessionByTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSessionByTicket(ticketId, modelStateId, strictValidation, reqCustomizationOrExport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.createSessionByTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:   * `setting.auth.ticket.create.*` - __required__. * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create a new ticket that allows to initialize a new session.
         * @param {string} modelId Model ID.
         * @param {ReqTicket} reqTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(modelId: string, reqTicket: ReqTicket, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResCreateTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(modelId, reqTicket, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.createTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `setting.auth.ticket.decrypt.*` - __required__.
         * @summary Decrypt the given ticket and return its details.
         * @param {string} ticketEncrypted Encrypted ShapeDiver ticket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decryptTicket(ticketEncrypted: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDecryptTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decryptTicket(ticketEncrypted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.decryptTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permissions:  * `get.parameter.*` - optional: adds _parameter defaults_ to response. * `get.export.*` - optional: adds _export definitions_ to response. * `compute.output.*` - optional: adds _outputs for default parameters_ to response. * `get.output.*` - optional: adds _output definitions_ to response.
         * @summary Get session defaults (corresponds to the content of the session initialization request).
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionDefaults(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetSessionDefaults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionDefaults(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.getSessionDefaults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary Close session.
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeSession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResCloseSession> {
            return localVarFp.closeSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `auth.session` - __required__. * `get.parameter.*` - optional: adds _parameters_ to response. * Output:    * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:     * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by model ID.
         * @param {string} modelId Model ID.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [strictValidation] When &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model is ignored. However, when set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionByModel(modelId: string, modelStateId?: string, strictValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateSessionByModel> {
            return localVarFp.createSessionByModel(modelId, modelStateId, strictValidation, reqCustomizationOrExport, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `get.parameter.*` - optional: adds _parameters_ to response. * Output:    * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
         * @summary Initialize new session by ticket.
         * @param {string} ticketId Encrypted ticket.
         * @param {string} [modelStateId] ID of the Model-State to apply.
         * @param {boolean} [strictValidation] When &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model is ignored. However, when set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
         * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionByTicket(ticketId: string, modelStateId?: string, strictValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateSessionByTicket> {
            return localVarFp.createSessionByTicket(ticketId, modelStateId, strictValidation, reqCustomizationOrExport, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:   * `setting.auth.ticket.create.*` - __required__. * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
         * @summary Create a new ticket that allows to initialize a new session.
         * @param {string} modelId Model ID.
         * @param {ReqTicket} reqTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(modelId: string, reqTicket: ReqTicket, options?: RawAxiosRequestConfig): AxiosPromise<ResCreateTicket> {
            return localVarFp.createTicket(modelId, reqTicket, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `setting.auth.ticket.decrypt.*` - __required__.
         * @summary Decrypt the given ticket and return its details.
         * @param {string} ticketEncrypted Encrypted ShapeDiver ticket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decryptTicket(ticketEncrypted: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDecryptTicket> {
            return localVarFp.decryptTicket(ticketEncrypted, options).then((request) => request(axios, basePath));
        },
        /**
         * Permissions:  * `get.parameter.*` - optional: adds _parameter defaults_ to response. * `get.export.*` - optional: adds _export definitions_ to response. * `compute.output.*` - optional: adds _outputs for default parameters_ to response. * `get.output.*` - optional: adds _output definitions_ to response.
         * @summary Get session defaults (corresponds to the content of the session initialization request).
         * @param {string} sessionId Session ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionDefaults(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResGetSessionDefaults> {
            return localVarFp.getSessionDefaults(sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Close session.
     * @param {string} sessionId Session ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public closeSession(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).closeSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `auth.session` - __required__. * `get.parameter.*` - optional: adds _parameters_ to response. * Output:    * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:     * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
     * @summary Initialize new session by model ID.
     * @param {string} modelId Model ID.
     * @param {string} [modelStateId] ID of the Model-State to apply.
     * @param {boolean} [strictValidation] When &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model is ignored. However, when set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
     * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public createSessionByModel(modelId: string, modelStateId?: string, strictValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).createSessionByModel(modelId, modelStateId, strictValidation, reqCustomizationOrExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `get.parameter.*` - optional: adds _parameters_ to response. * Output:    * If body contains a computation request: `compute.output.*` - __required__.   * If no computation request: `compute.output.*` - optional: adds _output for default     parameter_ to response.   * otherwise tries: `get.output.*` - optional: adds _output definitions_ to response. * Export:   * Body contains an export request: `compute.export.*` - __required__.   * No export request: `get.export.*` - optional: adds _export definitions_ to response.
     * @summary Initialize new session by ticket.
     * @param {string} ticketId Encrypted ticket.
     * @param {string} [modelStateId] ID of the Model-State to apply.
     * @param {boolean} [strictValidation] When &#x60;false&#x60;, any Model-State parameter that cannot be applied to the model is ignored. However, when set to &#x60;true&#x60;, any validation error will result in an error response.  Defaults to &#x60;false&#x60;.
     * @param {ReqCustomizationOrExport} [reqCustomizationOrExport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public createSessionByTicket(ticketId: string, modelStateId?: string, strictValidation?: boolean, reqCustomizationOrExport?: ReqCustomizationOrExport, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).createSessionByTicket(ticketId, modelStateId, strictValidation, reqCustomizationOrExport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions:   * `setting.auth.ticket.create.*` - __required__. * `setting.auth.ticket.get.*` - optional: adds _settings.auth.ticket_ to response. * `setting.auth.token.get.*` - optional: adds _settings.auth.token_ to response. * `setting.compute.get.*` - optional: adds _settings.compute_ to response. * `file.upload` - optional: adds _file.upload_ to response. * `file.download` - optional: adds _file.download_ to response. * `get.statistic.*` - optional: adds _statistic_ to response.
     * @summary Create a new ticket that allows to initialize a new session.
     * @param {string} modelId Model ID.
     * @param {ReqTicket} reqTicket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public createTicket(modelId: string, reqTicket: ReqTicket, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).createTicket(modelId, reqTicket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions:  * `setting.auth.ticket.decrypt.*` - __required__.
     * @summary Decrypt the given ticket and return its details.
     * @param {string} ticketEncrypted Encrypted ShapeDiver ticket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public decryptTicket(ticketEncrypted: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).decryptTicket(ticketEncrypted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permissions:  * `get.parameter.*` - optional: adds _parameter defaults_ to response. * `get.export.*` - optional: adds _export definitions_ to response. * `compute.output.*` - optional: adds _outputs for default parameters_ to response. * `get.output.*` - optional: adds _output definitions_ to response.
     * @summary Get session defaults (corresponds to the content of the session initialization request).
     * @param {string} sessionId Session ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getSessionDefaults(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).getSessionDefaults(sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Subject-Restriction: __backend__.
         * @summary Create a signed URL for the specified endpoint and target.
         * @param {string} endpoint CDN endpoint.
         * @param {string} encodedUri Base64 encoded target URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignedUrl: async (endpoint: string, encodedUri: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpoint' is not null or undefined
            assertParamExists('createSignedUrl', 'endpoint', endpoint)
            // verify required parameter 'encodedUri' is not null or undefined
            assertParamExists('createSignedUrl', 'encodedUri', encodedUri)
            const localVarPath = `/api/v2/system/sign/cdn/{endpoint}/{encodedUri}`
                .replace(`{${"endpoint"}}`, encodeURIComponent(String(endpoint)))
                .replace(`{${"encodedUri"}}`, encodeURIComponent(String(encodedUri)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `delete.hard` - __required__.
         * @summary Delete model permanently.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eraseModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('eraseModel', 'modelId', modelId)
            const localVarPath = `/api/v2/system/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Get system information about the Geometry Minions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMinionsInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/system/minions/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A __backend__ subject adds `system.plugins.inconsistent`.
         * @summary Get system information about the Geometry Workers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkersInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/system/workers/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication CredentialsAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Subject-Restriction: __backend__.
         * @summary Create a signed URL for the specified endpoint and target.
         * @param {string} endpoint CDN endpoint.
         * @param {string} encodedUri Base64 encoded target URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSignedUrl(endpoint: string, encodedUri: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSignedUrl(endpoint, encodedUri, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.createSignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `delete.hard` - __required__.
         * @summary Delete model permanently.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eraseModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResDeleteModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eraseModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.eraseModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Get system information about the Geometry Minions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMinionsInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetMinionsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMinionsInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getMinionsInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A __backend__ subject adds `system.plugins.inconsistent`.
         * @summary Get system information about the Geometry Workers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkersInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResGetWorkersInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkersInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getWorkersInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Subject-Restriction: __backend__.
         * @summary Create a signed URL for the specified endpoint and target.
         * @param {string} endpoint CDN endpoint.
         * @param {string} encodedUri Base64 encoded target URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignedUrl(endpoint: string, encodedUri: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createSignedUrl(endpoint, encodedUri, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.  Permissions:  * `delete.hard` - __required__.
         * @summary Delete model permanently.
         * @param {string} modelId Model ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eraseModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResDeleteModel> {
            return localVarFp.eraseModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subject-Restriction: __backend__.
         * @summary Get system information about the Geometry Minions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMinionsInfo(options?: RawAxiosRequestConfig): AxiosPromise<ResGetMinionsInfo> {
            return localVarFp.getMinionsInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * A __backend__ subject adds `system.plugins.inconsistent`.
         * @summary Get system information about the Geometry Workers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkersInfo(options?: RawAxiosRequestConfig): AxiosPromise<ResGetWorkersInfo> {
            return localVarFp.getWorkersInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Subject-Restriction: __backend__.
     * @summary Create a signed URL for the specified endpoint and target.
     * @param {string} endpoint CDN endpoint.
     * @param {string} encodedUri Base64 encoded target URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public createSignedUrl(endpoint: string, encodedUri: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).createSignedUrl(endpoint, encodedUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.  Permissions:  * `delete.hard` - __required__.
     * @summary Delete model permanently.
     * @param {string} modelId Model ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public eraseModel(modelId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).eraseModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subject-Restriction: __backend__.
     * @summary Get system information about the Geometry Minions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getMinionsInfo(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getMinionsInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A __backend__ subject adds `system.plugins.inconsistent`.
     * @summary Get system information about the Geometry Workers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getWorkersInfo(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getWorkersInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextureApi - axios parameter creator
 * @export
 */
export const TextureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permissions:  * `cache.texture.list.*` - __required__.
         * @summary List model textures.
         * @param {string} sessionId Session ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTextures: async (sessionId: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('listTextures', 'sessionId', sessionId)
            const localVarPath = `/api/v2/session/{sessionId}/texture/list`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextureApi - functional programming interface
 * @export
 */
export const TextureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextureApiAxiosParamCreator(configuration)
    return {
        /**
         * Permissions:  * `cache.texture.list.*` - __required__.
         * @summary List model textures.
         * @param {string} sessionId Session ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTextures(sessionId: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResListTextures>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTextures(sessionId, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextureApi.listTextures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextureApi - factory interface
 * @export
 */
export const TextureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextureApiFp(configuration)
    return {
        /**
         * Permissions:  * `cache.texture.list.*` - __required__.
         * @summary List model textures.
         * @param {string} sessionId Session ID.
         * @param {string} [offset] Continuation token for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTextures(sessionId: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResListTextures> {
            return localVarFp.listTextures(sessionId, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextureApi - object-oriented interface
 * @export
 * @class TextureApi
 * @extends {BaseAPI}
 */
export class TextureApi extends BaseAPI {
    /**
     * Permissions:  * `cache.texture.list.*` - __required__.
     * @summary List model textures.
     * @param {string} sessionId Session ID.
     * @param {string} [offset] Continuation token for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextureApi
     */
    public listTextures(sessionId: string, offset?: string, options?: RawAxiosRequestConfig) {
        return TextureApiFp(this.configuration).listTextures(sessionId, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



